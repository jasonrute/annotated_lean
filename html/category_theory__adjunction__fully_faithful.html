<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.adjunction.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.yoneda</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  universes v₁ v₂ u₁ u₂</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  open category</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  variables {C : Type u₁} [𝒞 : category.{v₁} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  variables {D : Type u₂} [𝒟 : category.{v₂} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  variables {L : C ⥤ D} {R : D ⥤ C} (h : L ⊣ R)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  -- Lemma 4.5.13 from [Riehl][riehl2017]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  -- Proof in &lt;https://stacks.math.columbia.edu/tag/0036&gt;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  -- or at &lt;https://math.stackexchange.com/a/2727177&gt;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  instance unit_is_iso_of_L_fully_faithful [full L] [faithful L] : is_iso (adjunction.unit h) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  @nat_iso.is_iso_of_is_iso_app _ _ _ _ _ _ (adjunction.unit h) $ λ X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  @yoneda.is_iso _ _ _ _ ((adjunction.unit h).app X)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  { inv := { app := λ Y f, L.preimage ((h.hom_equiv (unop Y) (L.obj X)).symm f) },</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    inv_hom_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32      simp only [adjunction.hom_equiv_counit, preimage_comp, preimage_map, category.assoc],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33      rw ←h.unit_naturality,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34      simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    hom_inv_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
X : C
⊢ @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)))
    ((λ
      (_x _x_1 _x_2 :
        @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
      (α :
        @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.has_hom.mk.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (λ
              (F G :
                @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}),
                @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  F
                  G))
          _x
          _x_1)
      (β :
        @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.has_hom.mk.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (λ
              (F G :
                @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}),
                @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  F
                  G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          _x
          _x_1
          _x_2
          α
          β)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
             X))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X))
       (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
             (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
             X))
       (@category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                X))
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X))
          (λ (Y : opposite.{u₁+1} C)
           (f :
             @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                     (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                     X))
               Y),
             @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
               (@opposite.unop.{u₁+1} C Y)
               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                  (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                  X)
               (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                  (equiv.{v₁+1 v₂+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@opposite.unop.{u₁+1} C Y)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@opposite.unop.{u₁+1} C Y))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                  (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@opposite.unop.{u₁+1} C Y)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@opposite.unop.{u₁+1} C Y))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                  (@equiv.symm.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@opposite.unop.{u₁+1} C Y))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@opposite.unop.{u₁+1} C Y)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                        (@opposite.unop.{u₁+1} C Y)
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                  f))
          (λ (X_1 Y : opposite.{u₁+1} C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                  (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
               X_1
               Y),
             @id.{0}
               (∀ (X : C) ⦃X_1 Y : opposite.{u₁+1} C⦄
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    X_1
                    Y),
                  @eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          Y))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          Y)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          Y)
                       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          X_1
                          Y
                          f)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}
                            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                     R)
                                  X))
                            Y),
                          @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                            (@opposite.unop.{u₁+1} C Y)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                               (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                               X)
                            (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                               (equiv.{v₁+1 v₂+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C Y)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C Y))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C Y)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C Y))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               (@equiv.symm.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C Y))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C Y)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@opposite.unop.{u₁+1} C Y)
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               f)))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          Y)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}
                            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                     R)
                                  X))
                            X_1),
                          @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                            (@opposite.unop.{u₁+1} C X_1)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                               (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                               X)
                            (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                               (equiv.{v₁+1 v₂+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X_1)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C X_1))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X_1)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C X_1))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               (@equiv.symm.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C X_1))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X_1)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@opposite.unop.{u₁+1} C X_1)
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               f))
                       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          X_1
                          Y
                          f)))
               (λ (X : C) ⦃X_1 Y : opposite.{u₁+1} C⦄
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X_1)
                          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)) →
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C Y)
                          X)
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             X)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C Y)
                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))),
                             @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                               (@opposite.unop.{u₁+1} C Y)
                               X
                               (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                                  (equiv.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C Y))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C Y))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.symm.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C Y))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  f))
                          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             X)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             X)
                          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                X)
                             X_1
                             Y
                             f)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X_1)
                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))),
                             @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                               (@opposite.unop.{u₁+1} C X_1)
                               X
                               (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                                  (equiv.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C X_1))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C X_1))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.symm.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C X_1))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  f))))
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X_1)
                          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)) →
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C Y)
                          X)
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             X)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C Y)
                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C Y)
                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                               X
                               f
                               (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                  X
                                  (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                                        R
                                        L)
                                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                     (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))))
                          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C … … X)
                          …
                          …
                          …))
                    …
                    …)
               X
               X_1
               Y
               f)))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
X : C
⊢ @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)))
    ((λ
      (_x _x_1 _x_2 :
        @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
      (α :
        @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.has_hom.mk.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (λ
              (F G :
                @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}),
                @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  F
                  G))
          _x
          _x_1)
      (β :
        @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.has_hom.mk.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (λ
              (F G :
                @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}),
                @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  F
                  G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          _x
          _x_1
          _x_2
          α
          β)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
             X))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X))
       (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
             (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
             X))
       (@category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                X))
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X))
          (λ (Y : opposite.{u₁+1} C)
           (f :
             @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                     (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                     X))
               Y),
             @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
               (@opposite.unop.{u₁+1} C Y)
               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                  (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                  X)
               (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                  (equiv.{v₁+1 v₂+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@opposite.unop.{u₁+1} C Y)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@opposite.unop.{u₁+1} C Y))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                  (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@opposite.unop.{u₁+1} C Y)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@opposite.unop.{u₁+1} C Y))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                  (@equiv.symm.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@opposite.unop.{u₁+1} C Y))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@opposite.unop.{u₁+1} C Y)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                        (@opposite.unop.{u₁+1} C Y)
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                  f))
          (λ (X_1 Y : opposite.{u₁+1} C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                  (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
               X_1
               Y),
             @id.{0}
               (∀ (X : C) ⦃X_1 Y : opposite.{u₁+1} C⦄
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    X_1
                    Y),
                  @eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          Y))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          Y)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          Y)
                       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          X_1
                          Y
                          f)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}
                            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                     R)
                                  X))
                            Y),
                          @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                            (@opposite.unop.{u₁+1} C Y)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                               (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                               X)
                            (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                               (equiv.{v₁+1 v₂+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C Y)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C Y))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C Y)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C Y))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               (@equiv.symm.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C Y))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C Y)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@opposite.unop.{u₁+1} C Y)
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               f)))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          Y)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}
                            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                     R)
                                  X))
                            X_1),
                          @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                            (@opposite.unop.{u₁+1} C X_1)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                               (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                               X)
                            (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                               (equiv.{v₁+1 v₂+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X_1)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C X_1))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X_1)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C X_1))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               (@equiv.symm.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@opposite.unop.{u₁+1} C X_1))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X_1)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@opposite.unop.{u₁+1} C X_1)
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                               f))
                       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X))
                          X_1
                          Y
                          f)))
               (λ (X : C) ⦃X_1 Y : opposite.{u₁+1} C⦄
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X_1)
                          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)) →
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C Y)
                          X)
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             X)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C Y)
                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))),
                             @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                               (@opposite.unop.{u₁+1} C Y)
                               X
                               (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                                  (equiv.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C Y))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C Y))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.symm.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C Y))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  f))
                          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             X)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             X)
                          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                X)
                             X_1
                             Y
                             f)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X_1)
                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))),
                             @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                               (@opposite.unop.{u₁+1} C X_1)
                               X
                               (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                                  (equiv.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C X_1))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C X_1))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.symm.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C X_1))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  f))))
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X_1)
                          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)) →
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C Y)
                          X)
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             X)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C Y)
                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C Y)
                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                               X
                               f
                               (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                  X
                                  (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                                        R
                                        L)
                                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                     (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))))
                          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                          (@category_theory.has_hom.hom.{v₁ u₁} C … … X)
                          …
                          …
                          …))
                    …
                    …)
               X
               X_1
               Y
               f)))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
X : C,
x : opposite.{u₁+1} C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X))
    x
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X))
       x)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X))
       ((λ
         (_x _x_1 _x_2 :
           @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
         (α :
           @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.has_hom.mk.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (λ
                 (F G :
                   @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}),
                   @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}
                     F
                     G))
             _x
             _x_1)
         (β :
           @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.has_hom.mk.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (λ
                 (F G :
                   @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}),
                   @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}
                     F
                     G))
             _x_1
             _x_2),
           @category_theory.nat_trans.vcomp.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             _x
             _x_1
             _x_2
             α
             β)
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X))
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                X))
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X))
          (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                X)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                X))
          (@category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                   X))
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (λ (Y : opposite.{u₁+1} C)
              (f :
                @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                        (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                        X))
                  Y),
                @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                  (@opposite.unop.{u₁+1} C Y)
                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                     (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                     X)
                  (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                     (equiv.{v₁+1 v₂+1}
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@opposite.unop.{u₁+1} C Y)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                        (@category_theory.has_hom.hom.{v₂ u₂} D
                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                              (@opposite.unop.{u₁+1} C Y))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                     (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@opposite.unop.{u₁+1} C Y)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                        (@category_theory.has_hom.hom.{v₂ u₂} D
                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                              (@opposite.unop.{u₁+1} C Y))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                     (@equiv.symm.{v₂+1 v₁+1}
                        (@category_theory.has_hom.hom.{v₂ u₂} D
                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                              (@opposite.unop.{u₁+1} C Y))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@opposite.unop.{u₁+1} C Y)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                        (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                           (@opposite.unop.{u₁+1} C Y)
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                     f))
             (λ (X_1 Y : opposite.{u₁+1} C)
              (f :
                @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                     (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                  X_1
                  Y),
                @id.{0}
                  (∀ (X : C) ⦃X_1 Y : opposite.{u₁+1} C⦄
                   (f :
                     @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                       X_1
                       Y),
                     @eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
                             (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   X))
                             X_1)
                          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   X))
                             Y))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   X))
                             X_1)
                          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   X))
                             Y)
                          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   X))
                             Y)
                          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   X))
                             X_1
                             Y
                             f)
                          (λ
                           (f :
                             @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                     (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                                        L
                                        R)
                                     X))
                               Y),
                             @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                               (@opposite.unop.{u₁+1} C Y)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                  X)
                               (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                                  (equiv.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C Y))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C Y))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.symm.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C Y))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@opposite.unop.{u₁+1} C Y)
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  f)))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   X))
                             X_1)
                          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   X))
                             X_1)
                          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   X))
                             Y)
                          (λ
                           (f :
                             @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                     (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                                        L
                                        R)
                                     X))
                               X_1),
                             @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                               (@opposite.unop.{u₁+1} C X_1)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                  X)
                               (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                                  (equiv.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C X_1))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C X_1))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  (@equiv.symm.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@opposite.unop.{u₁+1} C X_1))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@opposite.unop.{u₁+1} C X_1)
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                  f))
                          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   X))
                             X_1
                             Y
                             f)))
                  (λ (X : C) ⦃X_1 Y : opposite.{u₁+1} C⦄
                   (f :
                     @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                       X_1
                       Y),
                     @eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)) →
                           @category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             X)
                          (@function.comp.{v₁+1 v₁+1 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X_1)
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C Y)
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C Y)
                                X)
                             (λ
                              (f :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C Y)
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))),
                                @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                                  (@opposite.unop.{u₁+1} C Y)
                                  X
                                  (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                                     (equiv.{v₁+1 v₂+1}
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@opposite.unop.{u₁+1} C Y)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@opposite.unop.{u₁+1} C Y))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@opposite.unop.{u₁+1} C Y)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@opposite.unop.{u₁+1} C Y))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@equiv.symm.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@opposite.unop.{u₁+1} C Y))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@opposite.unop.{u₁+1} C Y)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                        (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                           (@opposite.unop.{u₁+1} C Y)
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     f))
                             (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                   𝒞
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                X_1
                                Y
                                f))
                          (@function.comp.{v₁+1 v₁+1 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X_1)
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X_1)
                                X)
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C Y)
                                X)
                             (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                   𝒞
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                   X)
                                X_1
                                Y
                                f)
                             (λ
                              (f :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C X_1)
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))),
                                @category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                                  (@opposite.unop.{u₁+1} C X_1)
                                  X
                                  (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                                     (equiv.{v₁+1 v₂+1}
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@opposite.unop.{u₁+1} C X_1)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@opposite.unop.{u₁+1} C X_1))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@opposite.unop.{u₁+1} C X_1)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@opposite.unop.{u₁+1} C X_1))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     (@equiv.symm.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@opposite.unop.{u₁+1} C X_1))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@opposite.unop.{u₁+1} C X_1)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                        (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                           (@opposite.unop.{u₁+1} C X_1)
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                     f))))
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X_1)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)) →
                           @category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Y)
                             X)
                          (@function.comp.{v₁+1 v₁+1 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X_1)
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C Y)
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C Y)
                                X)
                             (λ
                              (f :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C Y)
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))),
                                @category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@opposite.unop.{u₁+1} C Y)
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                  X
                                  f
                                  (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                                     X
                                     (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                        (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                           𝒟
                                           R
                                           L)
                                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                        (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))))
                             (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                   𝒞
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                                X_1
                                Y
                                f))
                          (@function.comp.{v₁+1 v₁+1 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X_1)
                                (… R …))
                             …
                             …
                             …
                             …))
                       …
                       …)
                  X
                  X_1
                  Y
                  f)))
       x
       x_1)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
X : C,
x : opposite.{u₁+1} C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X))
    x
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@opposite.unop.{u₁+1} C x)
       X)
    (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1 (@opposite.unop.{u₁+1} C x) X
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                (@opposite.unop.{u₁+1} C x)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C x)
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
             x_1
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                X))))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      apply L.injectivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
X : C,
x : opposite.{u₁+1} C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X))
    x
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@opposite.unop.{u₁+1} C x)
       X)
    (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1 (@opposite.unop.{u₁+1} C x) X
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                (@opposite.unop.{u₁+1} C x)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C x)
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
             x_1
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                X))))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
X : C,
x : opposite.{u₁+1} C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X))
    x
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x) X
       (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1 (@opposite.unop.{u₁+1} C x) X
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.unop.{u₁+1} C x)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.unop.{u₁+1} C x)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.unop.{u₁+1} C x)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                   (@opposite.unop.{u₁+1} C x)
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C x)
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                x_1
                (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                   (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                   X)))))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x) X x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40      simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L,
X : C,
x : opposite.{u₁+1} C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X))
    x
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x) X
       (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L _inst_1 (@opposite.unop.{u₁+1} C x) X
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.unop.{u₁+1} C x)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.unop.{u₁+1} C x)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.unop.{u₁+1} C x)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
                (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                   (@opposite.unop.{u₁+1} C x)
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C x)
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L X))
                x_1
                (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                   (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                   X)))))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@opposite.unop.{u₁+1} C x) X x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    end }.</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  instance counit_is_iso_of_R_fully_faithful [full R] [faithful R] : is_iso (adjunction.counit h) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → Type (max u₂ v₂ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  @nat_iso.is_iso_of_is_iso_app _ _ _ _ _ _ (adjunction.counit h) $ λ X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_iso.is_iso_of_is_iso_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_isomorphism.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) [_inst_1 : Π (X : C), @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)], @category_theory.is_iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  @is_iso_of_op _ _ _ _ _ $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.is_iso_of_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) [_inst_1 : @category_theory.is_iso.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@opposite.op.{u₁+1} C Y) (@opposite.op.{u₁+1} C X) (@category_theory.has_hom.hom.op.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y f)], @category_theory.is_iso.{v₁ u₁} C 𝒞 X Y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  @coyoneda.is_iso _ _ _ _ ((adjunction.counit h).app X).op</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.coyoneda.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {X Y : opposite.{u₁+1} C} (f : @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))) X Y) [_inst_1 : @category_theory.is_iso.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) Y) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X Y f)], @category_theory.is_iso.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) X Y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.has_hom.{v₂ u₂} C] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C 𝒞 X Y → @category_theory.has_hom.hom.{v₂ u₂} (opposite.{u₂+1} C) (@category_theory.has_hom.opposite.{v₂ u₂} C 𝒞) (@opposite.op.{u₂+1} C Y) (@opposite.op.{u₂+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  { inv := { app := λ Y f, R.preimage ((h.hom_equiv (R.obj X) Y) f) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟) (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}) (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}) (@category_theory.coyoneda.{v₂ u₂} D 𝒟) (@opposite.op.{u₂+1} D (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L) X))) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] (F : @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟) (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}) (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}) (@category_theory.coyoneda.{v₂ u₂} D 𝒟) (@opposite.op.{u₂+1} D (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L) X))) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48    inv_hom_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X : D
⊢ @eq.{(max u₂ v₂)+1}
    (@category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                category_theory.types.{v₂})))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X))))
    (@category_theory.category_struct.comp.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)))
       (@category_theory.nat_trans.mk.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          (λ (Y : D)
           (f :
             @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
               (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
                  (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                  (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                  (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                     category_theory.types.{v₂})
                  (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                  (@opposite.op.{u₂+1} D
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                        X)))
               Y),
             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
               (@opposite.unop.{u₂+1} D
                  (@opposite.op.{u₂+1} D
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                        X)))
               Y
               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                  (equiv.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                        Y)
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                        Y)
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     Y)
                  f))
          (λ (X_1 Y : D)
           (f :
             @category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               X_1
               Y),
             @id.{0}
               (∀ (X : D) ⦃X_1 Y : D⦄
                (f :
                  @category_theory.has_hom.hom.{v₂ u₂} D
                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                    X_1
                    Y),
                  @eq.{v₂+1}
                    (@category_theory.has_hom.hom.{v₂ v₂+1} (Type v₂)
                       (@category_theory.category_struct.to_has_hom.{v₂ v₂+1} (Type v₂)
                          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                             category_theory.types.{v₂}))
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          Y))
                    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                          category_theory.types.{v₂})
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          Y)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          Y)
                       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1
                          Y
                          f)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                            category_theory.types.{v₂}
                            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                               (opposite.{u₂+1} D)
                               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                                        R
                                        L)
                                     X)))
                            Y),
                          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                            (@opposite.unop.{u₂+1} D
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                     X)))
                            Y
                            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                               (equiv.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                  Y)
                               f)))
                    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                          category_theory.types.{v₂})
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          Y)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                            category_theory.types.{v₂}
                            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                               (opposite.{u₂+1} D)
                               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                                        R
                                        L)
                                     X)))
                            X_1),
                          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                            (@opposite.unop.{u₂+1} D
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                     X)))
                            X_1
                            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                               (equiv.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                  X_1)
                               f))
                       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          X_1
                          Y
                          f)))
               (λ (X : D) ⦃X_1 Y : D⦄
                (f :
                  @category_theory.has_hom.hom.{v₂ u₂} D
                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{v₂+1}
                       (@category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                          X_1 →
                        @category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          X
                          Y)
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             Y)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₂ u₂} D
                               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                               Y),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     Y)
                                  f))
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D X))
                             X_1
                             Y
                             f)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₂ u₂} D
                               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                               X_1),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X X_1
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     X_1)
                                  f))))
                    (@eq.{v₂+1}
                       (@category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                          X_1 →
                        @category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          X
                          Y)
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             Y)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@category_theory.category_struct.comp.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                             X
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             Y
                             (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D X))
                             X_1
                             Y
                             f)
                          (@category_theory.category_struct.comp.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                             X
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1
                             (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1 →
                              @category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (@function.comp.{v₂+1 v₂+1 v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   Y)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   Y)
                                (λ
                                 (f :
                                   @category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     Y),
                                   @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
                                     (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1))
                                        (max (v₂+1) (v₁+1))}
                                        (equiv.{v₂+1 v₁+1}
                                           (@category_theory.has_hom.hom.{v₂ u₂} D
                                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{v₁ u₁} C
                                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                        (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                           (@category_theory.has_hom.hom.{v₂ u₂} D
                                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{v₁ u₁} C
                                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                        (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           Y)
                                        f))
                                (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂}
                                   (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                      (opposite.{u₂+1} D)
                                      (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                      (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                      (@opposite.op.{u₂+1} D
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                                   X_1
                                   Y
                                   f))
                             (@function.comp.{v₂+1 v₂+1 v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   X_1)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   Y)
                                (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂}
                                   (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                      (opposite.{u₂+1} D)
                                      (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                      (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                      (@opposite.op.{u₂+1} D X))
                                   X_1
                                   Y
                                   f)
                                (λ
                                 (f :
                                   @category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     X_1),
                                   @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X X_1
                                     (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1))
                                        (max (v₂+1) (v₁+1))}
                                        (equiv.{v₂+1 v₁+1}
                                           (@category_theory.has_hom.hom.{v₂ u₂} D
                                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                              X_1)
                                           (@category_theory.has_hom.hom.{v₁ u₁} C
                                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                        (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                           (@category_theory.has_hom.hom.{v₂ u₂} D
                                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                              X_1)
                                           (@category_theory.has_hom.hom.{v₁ u₁} C
                                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                        (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           X_1)
                                        f))))
                          …)
                       …)
                    …)
               X
               X_1
               Y
               f))
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X_1
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ v₂+1} (Type v₂)
       (@category_theory.category_struct.to_has_hom.{v₂ v₂+1} (Type v₂)
          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂}))
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y))
    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          Y)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y)
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1
          Y
          f)
       (λ
        (f :
          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                  category_theory.types.{v₂})
               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                     X)))
            Y),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
            (@opposite.unop.{u₂+1} D
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            Y
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  Y)
               f)))
    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y)
       (λ
        (f :
          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                  category_theory.types.{v₂})
               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                     X)))
            X_1),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
            (@opposite.unop.{u₂+1} D
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            X_1
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  X_1)
               f))
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          X_1
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X_1
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ v₂+1} (Type v₂)
       (@category_theory.category_struct.to_has_hom.{v₂ v₂+1} (Type v₂)
          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂}))
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y))
    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          Y)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y)
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1
          Y
          f)
       (λ
        (f :
          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                  category_theory.types.{v₂})
               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                     X)))
            Y),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
            (@opposite.unop.{u₂+1} D
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            Y
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  Y)
               f)))
    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y)
       (λ
        (f :
          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                  category_theory.types.{v₂})
               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                     X)))
            X_1),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
            (@opposite.unop.{u₂+1} D
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            X_1
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  X_1)
               f))
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          X_1
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X x : D,
x_1 :
  @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
    (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
       (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
       (@opposite.op.{u₂+1} D
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
             X)))
    x
⊢ @eq.{v₂+1}
    (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)))
       x)
    (@category_theory.nat_trans.app.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)))
       (@category_theory.category_struct.comp.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                category_theory.types.{v₂}))
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          (@category_theory.nat_trans.mk.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                   category_theory.types.{v₂})
                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                (@opposite.op.{u₂+1} D
                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                      X)))
             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                   category_theory.types.{v₂})
                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                (@opposite.op.{u₂+1} D
                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                      X)))
             (λ (Y : D)
              (f :
                @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
                  (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                     (opposite.{u₂+1} D)
                     (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                     (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                     (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                        category_theory.types.{v₂})
                     (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                     (@opposite.op.{u₂+1} D
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                           X)))
                  Y),
                @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                  (@opposite.unop.{u₂+1} D
                     (@opposite.op.{u₂+1} D
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X)))
                  Y
                  (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                     (equiv.{v₂+1 v₁+1}
                        (@category_theory.has_hom.hom.{v₂ u₂} D
                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                           Y)
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                     (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                        (@category_theory.has_hom.hom.{v₂ u₂} D
                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                           Y)
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                        Y)
                     f))
             (λ (X_1 Y : D)
              (f :
                @category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  X_1
                  Y),
                @id.{0}
                  (∀ (X : D) ⦃X_1 Y : D⦄
                   (f :
                     @category_theory.has_hom.hom.{v₂ u₂} D
                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                       X_1
                       Y),
                     @eq.{v₂+1}
                       (@category_theory.has_hom.hom.{v₂ v₂+1} (Type v₂)
                          (@category_theory.category_struct.to_has_hom.{v₂ v₂+1} (Type v₂)
                             (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                                category_theory.types.{v₂}))
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             Y))
                       (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                             category_theory.types.{v₂})
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             Y)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             Y)
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             X_1
                             Y
                             f)
                          (λ
                           (f :
                             @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                               category_theory.types.{v₂}
                               (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                  (opposite.{u₂+1} D)
                                  (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                  (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                     category_theory.types.{v₂})
                                  (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                     category_theory.types.{v₂})
                                  (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                  (@opposite.op.{u₂+1} D
                                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                        (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                           𝒟
                                           R
                                           L)
                                        X)))
                               Y),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                               (@opposite.unop.{u₂+1} D
                                  (@opposite.op.{u₂+1} D
                                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                        X)))
                               Y
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     Y)
                                  f)))
                       (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                             category_theory.types.{v₂})
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             Y)
                          (λ
                           (f :
                             @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                               category_theory.types.{v₂}
                               (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                  (opposite.{u₂+1} D)
                                  (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                  (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                     category_theory.types.{v₂})
                                  (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                     category_theory.types.{v₂})
                                  (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                  (@opposite.op.{u₂+1} D
                                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                        (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                           𝒟
                                           R
                                           L)
                                        X)))
                               X_1),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                               (@opposite.unop.{u₂+1} D
                                  (@opposite.op.{u₂+1} D
                                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                        X)))
                               X_1
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     X_1)
                                  f))
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             X_1
                             Y
                             f)))
                  (λ (X : D) ⦃X_1 Y : D⦄
                   (f :
                     @category_theory.has_hom.hom.{v₂ u₂} D
                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                       X_1
                       Y),
                     @eq.mpr.{0}
                       (@eq.{v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1 →
                           @category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@function.comp.{v₂+1 v₂+1 v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                Y)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (λ
                              (f :
                                @category_theory.has_hom.hom.{v₂ u₂} D
                                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                  Y),
                                @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
                                  (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                     (equiv.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                           Y)
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                     (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                           Y)
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        Y)
                                     f))
                             (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂}
                                (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                   (opposite.{u₂+1} D)
                                   (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                   (@opposite.op.{u₂+1} D
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                                X_1
                                Y
                                f))
                          (@function.comp.{v₂+1 v₂+1 v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂}
                                (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                   (opposite.{u₂+1} D)
                                   (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                   (@opposite.op.{u₂+1} D X))
                                X_1
                                Y
                                f)
                             (λ
                              (f :
                                @category_theory.has_hom.hom.{v₂ u₂} D
                                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                  X_1),
                                @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X X_1
                                  (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                     (equiv.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                           X_1)
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                     (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                           X_1)
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        X_1)
                                     f))))
                       (@eq.{v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1 →
                           @category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@function.comp.{v₂+1 v₂+1 v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                Y)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                Y
                                (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         L
                                         R)
                                      (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                             (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂}
                                (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                   (opposite.{u₂+1} D)
                                   (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                   (@opposite.op.{u₂+1} D
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                                X_1
                                Y
                                f))
                          (@function.comp.{v₂+1 v₂+1 v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂}
                                (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                   (opposite.{u₂+1} D)
                                   (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                   (@opposite.op.{u₂+1} D X))
                                X_1
                                Y
                                f)
                             (@category_theory.category_struct.comp.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1
                                (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         L
                                         R)
                                      (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   X_1 →
                                 @category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   Y)
                                (@function.comp.{v₂+1 v₂+1 v₂+1}
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                      X_1)
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                      Y)
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      X
                                      Y)
                                   (λ
                                    (f :
                                      @category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y),
                                      @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                        Y
                                        (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1))
                                           (max (v₂+1) (v₁+1))}
                                           (equiv.{v₂+1 v₁+1}
                                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                       X))
                                                 Y)
                                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                    Y)))
                                           (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                       X))
                                                 Y)
                                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                    Y)))
                                           (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              R
                                              h
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              Y)
                                           f))
                                   (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂}
                                      (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                         (opposite.{u₂+1} D)
                                         (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                         (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                            category_theory.types.{v₂})
                                         (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                            category_theory.types.{v₂})
                                         (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                         (@opposite.op.{u₂+1} D
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                                      X_1
                                      Y
                                      f))
                                (@function.comp.{v₂+1 v₂+1 v₂+1}
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                      X_1)
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      X
                                      X_1)
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      X
                                      Y)
                                   (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂}
                                      (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                         (opposite.{u₂+1} D)
                                         (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                         (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                            category_theory.types.{v₂})
                                         (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                            category_theory.types.{v₂})
                                         (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                         (@opposite.op.{u₂+1} D X))
                                      X_1
                                      Y
                                      f)
                                   (λ
                                    (f :
                                      @category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1),
                                      @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                        X_1
                                        (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1))
                                           (max (v₂+1) (v₁+1))}
                                           (equiv.{v₂+1 v₁+1}
                                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                       X))
                                                 X_1)
                                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                    X_1)))
                                           (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                       X))
                                                 X_1)
                                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                                 …
                                                 …))
                                           …
                                           f))))
                             …)
                          …)
                       …)
                  X
                  X_1
                  Y
                  f))
          …)
       x
       x_1)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X_1
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ v₂+1} (Type v₂)
       (@category_theory.category_struct.to_has_hom.{v₂ v₂+1} (Type v₂)
          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂}))
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y))
    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          Y)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y)
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1
          Y
          f)
       (λ
        (f :
          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                  category_theory.types.{v₂})
               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                     X)))
            Y),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
            (@opposite.unop.{u₂+1} D
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            Y
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  Y)
               f)))
    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y)
       (λ
        (f :
          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                  category_theory.types.{v₂})
               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                     X)))
            X_1),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
            (@opposite.unop.{u₂+1} D
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            X_1
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  X_1)
               f))
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          X_1
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51      simp only [adjunction.hom_equiv_unit, preimage_comp, preimage_map],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.preimage_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.preimage_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [𝒟 : category_theory.category.{?l_4 ?l_3} D] {F : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟} {G : @category_theory.functor.{?l_4 ?l_2 ?l_3 ?l_1} D 𝒟 C 𝒞} (c : @category_theory.adjunction.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F G) {X : C} {Y : D} {f : @category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) Y}, @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D 𝒟 C 𝒞 G Y)) (@coe_fn.{(max 1 (max (?l_4+1) (?l_2+1)) (?l_2+1) (?l_4+1)) (max (?l_4+1) (?l_2+1))} (equiv.{?l_4+1 ?l_2+1} (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{?l_4+1 ?l_2+1} (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D 𝒟 C 𝒞 G Y))) (@category_theory.adjunction.hom_equiv.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F G c X Y) f) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) X (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D 𝒟 C 𝒞 G Y) (@category_theory.nat_trans.app.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 (@category_theory.functor.id.{?l_2 ?l_1} C 𝒞) (@category_theory.functor.comp.{?l_2 ?l_4 ?l_2 ?l_1 ?l_3 ?l_1} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F G c) X) (@category_theory.functor.map.{?l_4 ?l_2 ?l_3 ?l_1} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [𝒟 : category_theory.category.{?l_4 ?l_3} D] {F : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟} [_inst_1 : @category_theory.full.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F] [_inst_2 : @category_theory.faithful.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F] {X Y Z : C} (f : @category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F Y)) (g : @category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F Z)), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X Z) (@category_theory.functor.preimage.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F _inst_1 X Z (@category_theory.category_struct.comp.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F Z) f g)) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) X Y Z (@category_theory.functor.preimage.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F _inst_1 X Y f) (@category_theory.functor.preimage.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F _inst_1 Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [𝒟 : category_theory.category.{?l_4 ?l_3} D] {F : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟} [_inst_1 : @category_theory.full.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F] [_inst_2 : @category_theory.faithful.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F] {X Y : C} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X Y) (@category_theory.functor.preimage.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F _inst_1 X Y (@category_theory.functor.map.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X Y f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X_1
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ v₂+1} (Type v₂)
       (@category_theory.category_struct.to_has_hom.{v₂ v₂+1} (Type v₂)
          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂}))
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y))
    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          Y)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y)
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1
          Y
          f)
       (λ
        (f :
          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                  category_theory.types.{v₂})
               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                     X)))
            Y),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
            (@opposite.unop.{u₂+1} D
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            Y
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  Y)
               f)))
    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          X_1)
       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          Y)
       (λ
        (f :
          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                  category_theory.types.{v₂})
               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                     X)))
            X_1),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
            (@opposite.unop.{u₂+1} D
               (@opposite.op.{u₂+1} D
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            X_1
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  X_1)
               f))
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          X_1
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X_1
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
       X_1 →
     @category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       X
       Y)
    (@function.comp.{v₂+1 v₂+1 v₂+1}
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
          X_1)
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
          Y)
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          X
          Y)
       (λ
        (f :
          @category_theory.has_hom.hom.{v₂ u₂} D
            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
            Y),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  Y)
               f))
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
          X_1
          Y
          f))
    (@function.comp.{v₂+1 v₂+1 v₂+1}
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
          X_1)
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          X
          X_1)
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          X
          Y)
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D X))
          X_1
          Y
          f)
       (λ
        (f :
          @category_theory.has_hom.hom.{v₂ u₂} D
            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
            X_1),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X X_1
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  X_1)
               f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52      rw ←h.counit_naturality,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) X x), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) x)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) x) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X x f)) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h) x)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) x) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h) X) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X_1
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
       X_1 →
     @category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       X
       Y)
    (@function.comp.{v₂+1 v₂+1 v₂+1}
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
          X_1)
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
          Y)
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          X
          Y)
       (λ
        (f :
          @category_theory.has_hom.hom.{v₂ u₂} D
            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
            Y),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     Y)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  Y)
               f))
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
          X_1
          Y
          f))
    (@function.comp.{v₂+1 v₂+1 v₂+1}
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
          X_1)
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          X
          X_1)
       (@category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          X
          Y)
       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D X))
          X_1
          Y
          f)
       (λ
        (f :
          @category_theory.has_hom.hom.{v₂ u₂} D
            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
            X_1),
          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X X_1
            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
               (equiv.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                     X_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                  X_1)
               f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X x : D,
x_1 :
  @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
    (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
       (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
       (@opposite.op.{u₂+1} D
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
             X)))
    x
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
       x)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          x)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X x
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                X
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                x
                (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                   (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                      (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)))
                x_1)))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
          x))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53      simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X x : D,
x_1 :
  @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
    (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
       (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
       (@opposite.op.{u₂+1} D
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
             X)))
    x
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
       x)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          x)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X x
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                X
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                x
                (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                   (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L R)
                      (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)))
                x_1)))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
          x))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    hom_inv_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X : D
⊢ @eq.{(max u₂ v₂)+1}
    (@category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                category_theory.types.{v₂})))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))))
    ((λ
      (_x _x_1 _x_2 : @category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
      (α :
        @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.has_hom.mk.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (λ
              (F G : @category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}),
                @category_theory.nat_trans.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} F G))
          _x
          _x_1)
      (β :
        @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.has_hom.mk.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (λ
              (F G : @category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}),
                @category_theory.nat_trans.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} F G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} _x _x_1
          _x_2
          α
          β)
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       (@category_theory.functor.map.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X))
          (@category_theory.has_hom.hom.op.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                X)))
       (@category_theory.nat_trans.mk.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          (λ (Y : D)
           (f :
             @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
               (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
                  (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                  (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                  (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                     category_theory.types.{v₂})
                  (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                  (@opposite.op.{u₂+1} D
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                        X)))
               Y),
             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
               (@opposite.unop.{u₂+1} D
                  (@opposite.op.{u₂+1} D
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                        X)))
               Y
               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                  (equiv.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                        Y)
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                        Y)
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     Y)
                  f))
          (λ (X_1 Y : D)
           (f :
             @category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               X_1
               Y),
             @id.{0}
               (∀ (X : D) ⦃X_1 Y : D⦄
                (f :
                  @category_theory.has_hom.hom.{v₂ u₂} D
                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                    X_1
                    Y),
                  @eq.{v₂+1}
                    (@category_theory.has_hom.hom.{v₂ v₂+1} (Type v₂)
                       (@category_theory.category_struct.to_has_hom.{v₂ v₂+1} (Type v₂)
                          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                             category_theory.types.{v₂}))
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          Y))
                    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                          category_theory.types.{v₂})
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          Y)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          Y)
                       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1
                          Y
                          f)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                            category_theory.types.{v₂}
                            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                               (opposite.{u₂+1} D)
                               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                                        R
                                        L)
                                     X)))
                            Y),
                          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                            (@opposite.unop.{u₂+1} D
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                     X)))
                            Y
                            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                               (equiv.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                  Y)
                               f)))
                    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                          category_theory.types.{v₂})
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          Y)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                            category_theory.types.{v₂}
                            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                               (opposite.{u₂+1} D)
                               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                                        R
                                        L)
                                     X)))
                            X_1),
                          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                            (@opposite.unop.{u₂+1} D
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                     X)))
                            X_1
                            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                               (equiv.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                  X_1)
                               f))
                       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          X_1
                          Y
                          f)))
               (λ (X : D) ⦃X_1 Y : D⦄
                (f :
                  @category_theory.has_hom.hom.{v₂ u₂} D
                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{v₂+1}
                       (@category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                          X_1 →
                        @category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          X
                          Y)
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             Y)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₂ u₂} D
                               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                               Y),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     Y)
                                  f))
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D X))
                             X_1
                             Y
                             f)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₂ u₂} D
                               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                               X_1),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X X_1
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     X_1)
                                  f))))
                    (@eq.{v₂+1}
                       (@category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                          X_1 →
                        @category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          X
                          Y)
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             Y)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@category_theory.category_struct.comp.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                             X
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             Y
                             (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D X))
                             X_1
                             Y
                             f)
                          (@category_theory.category_struct.comp.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                             X
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1
                             (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1 →
                              @category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (@function.comp.{v₂+1 v₂+1 v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   Y)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   Y)
                                (λ
                                 (f :
                                   @category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     Y),
                                   @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
                                     (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1))
                                        (max (v₂+1) (v₁+1))}
                                        (equiv.{v₂+1 v₁+1}
                                           (@category_theory.has_hom.hom.{v₂ u₂} D
                                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{v₁ u₁} C
                                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                        (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                           (@category_theory.has_hom.hom.{v₂ u₂} D
                                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{v₁ u₁} C
                                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                        (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           Y)
                                        f))
                                (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂}
                                   (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                      (opposite.{u₂+1} D)
                                      (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                      (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                      (@opposite.op.{u₂+1} D
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                                   X_1
                                   Y
                                   f))
                             (@function.comp.{v₂+1 v₂+1 v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   X_1)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   Y)
                                (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂}
                                   (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                      (opposite.{u₂+1} D)
                                      (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                      (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                      …)
                                   X_1
                                   Y
                                   f)
                                …))
                          …)
                       …)
                    …)
               X
               X_1
               Y
               f)))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X : D
⊢ @eq.{(max u₂ v₂)+1}
    (@category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                category_theory.types.{v₂})))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))))
    ((λ
      (_x _x_1 _x_2 : @category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
      (α :
        @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.has_hom.mk.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (λ
              (F G : @category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}),
                @category_theory.nat_trans.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} F G))
          _x
          _x_1)
      (β :
        @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.has_hom.mk.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (λ
              (F G : @category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}),
                @category_theory.nat_trans.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} F G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} _x _x_1
          _x_2
          α
          β)
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       (@category_theory.functor.map.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X))
          (@category_theory.has_hom.hom.op.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                X)))
       (@category_theory.nat_trans.mk.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          (λ (Y : D)
           (f :
             @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
               (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
                  (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                  (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                  (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                     category_theory.types.{v₂})
                  (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                  (@opposite.op.{u₂+1} D
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                        X)))
               Y),
             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
               (@opposite.unop.{u₂+1} D
                  (@opposite.op.{u₂+1} D
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                        X)))
               Y
               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                  (equiv.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                        Y)
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                        Y)
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                     Y)
                  f))
          (λ (X_1 Y : D)
           (f :
             @category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               X_1
               Y),
             @id.{0}
               (∀ (X : D) ⦃X_1 Y : D⦄
                (f :
                  @category_theory.has_hom.hom.{v₂ u₂} D
                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                    X_1
                    Y),
                  @eq.{v₂+1}
                    (@category_theory.has_hom.hom.{v₂ v₂+1} (Type v₂)
                       (@category_theory.category_struct.to_has_hom.{v₂ v₂+1} (Type v₂)
                          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                             category_theory.types.{v₂}))
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          Y))
                    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                          category_theory.types.{v₂})
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          Y)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          Y)
                       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1
                          Y
                          f)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                            category_theory.types.{v₂}
                            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                               (opposite.{u₂+1} D)
                               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                                        R
                                        L)
                                     X)))
                            Y),
                          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                            (@opposite.unop.{u₂+1} D
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                     X)))
                            Y
                            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                               (equiv.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                  Y)
                               f)))
                    (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                       (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                          category_theory.types.{v₂})
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          Y)
                       (λ
                        (f :
                          @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                            category_theory.types.{v₂}
                            (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                               (opposite.{u₂+1} D)
                               (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                               (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                  category_theory.types.{v₂})
                               (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                                        R
                                        L)
                                     X)))
                            X_1),
                          @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                            (@opposite.unop.{u₂+1} D
                               (@opposite.op.{u₂+1} D
                                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                     X)))
                            X_1
                            (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                               (equiv.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                               (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                  (@category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                               (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                  X_1)
                               f))
                       (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                          category_theory.types.{v₂}
                          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                             (opposite.{u₂+1} D)
                             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂})
                             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                             (@opposite.op.{u₂+1} D
                                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                   X)))
                          X_1
                          Y
                          f)))
               (λ (X : D) ⦃X_1 Y : D⦄
                (f :
                  @category_theory.has_hom.hom.{v₂ u₂} D
                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{v₂+1}
                       (@category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                          X_1 →
                        @category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          X
                          Y)
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             Y)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₂ u₂} D
                               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                               Y),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     Y)
                                  f))
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D X))
                             X_1
                             Y
                             f)
                          (λ
                           (f :
                             @category_theory.has_hom.hom.{v₂ u₂} D
                               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                               X_1),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X X_1
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     X_1)
                                  f))))
                    (@eq.{v₂+1}
                       (@category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                          X_1 →
                        @category_theory.has_hom.hom.{v₂ u₂} D
                          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                          X
                          Y)
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             Y)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@category_theory.category_struct.comp.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                             X
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             Y
                             (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{v₂+1 v₂+1 v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D X))
                             X_1
                             Y
                             f)
                          (@category_theory.category_struct.comp.{v₂ u₂} D
                             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                             X
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1
                             (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 L
                                      R)
                                   (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1 →
                              @category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (@function.comp.{v₂+1 v₂+1 v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   Y)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   Y)
                                (λ
                                 (f :
                                   @category_theory.has_hom.hom.{v₂ u₂} D
                                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                     Y),
                                   @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
                                     (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1))
                                        (max (v₂+1) (v₁+1))}
                                        (equiv.{v₂+1 v₁+1}
                                           (@category_theory.has_hom.hom.{v₂ u₂} D
                                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{v₁ u₁} C
                                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                        (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                           (@category_theory.has_hom.hom.{v₂ u₂} D
                                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{v₁ u₁} C
                                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                        (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           Y)
                                        f))
                                (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂}
                                   (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                      (opposite.{u₂+1} D)
                                      (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                      (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                      (@opposite.op.{u₂+1} D
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                                   X_1
                                   Y
                                   f))
                             (@function.comp.{v₂+1 v₂+1 v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   X_1)
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   Y)
                                (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂}
                                   (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                      (opposite.{u₂+1} D)
                                      (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                      (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                         category_theory.types.{v₂})
                                      (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                      …)
                                   X_1
                                   Y
                                   f)
                                …))
                          …)
                       …)
                    …)
               X
               X_1
               Y
               f)))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X x : D,
x_1 :
  @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
    (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
       (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
       (@opposite.op.{u₂+1} D
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             X)))
    x
⊢ @eq.{v₂+1}
    (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       x)
    (@category_theory.nat_trans.app.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
          (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
          (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
          (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
          (@opposite.op.{u₂+1} D
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)))
       ((λ
         (_x _x_1 _x_2 :
           @category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
         (α :
           @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.has_hom.mk.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                (λ
                 (F G :
                   @category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}),
                   @category_theory.nat_trans.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} F
                     G))
             _x
             _x_1)
         (β :
           @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.has_hom.mk.{(max u₂ v₂) (max v₂ u₂ (v₂+1))}
                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                (λ
                 (F G :
                   @category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}),
                   @category_theory.nat_trans.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} F
                     G))
             _x_1
             _x_2),
           @category_theory.nat_trans.vcomp.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂} _x
             _x_1
             _x_2
             α
             β)
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)))
          (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          (@category_theory.functor.map.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
             (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
             (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
             (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X))
             (@opposite.op.{u₂+1} D
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X))
             (@category_theory.has_hom.hom.op.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   X)
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)
                (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                   X)))
          (@category_theory.nat_trans.mk.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                   category_theory.types.{v₂})
                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                (@opposite.op.{u₂+1} D
                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                      X)))
             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                   category_theory.types.{v₂})
                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                (@opposite.op.{u₂+1} D
                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                      X)))
             (λ (Y : D)
              (f :
                @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
                  (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                     (opposite.{u₂+1} D)
                     (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                     (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
                     (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                        category_theory.types.{v₂})
                     (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                     (@opposite.op.{u₂+1} D
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                           X)))
                  Y),
                @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                  (@opposite.unop.{u₂+1} D
                     (@opposite.op.{u₂+1} D
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X)))
                  Y
                  (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                     (equiv.{v₂+1 v₁+1}
                        (@category_theory.has_hom.hom.{v₂ u₂} D
                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                           Y)
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                     (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                        (@category_theory.has_hom.hom.{v₂ u₂} D
                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                           Y)
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                        Y)
                     f))
             (λ (X_1 Y : D)
              (f :
                @category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  X_1
                  Y),
                @id.{0}
                  (∀ (X : D) ⦃X_1 Y : D⦄
                   (f :
                     @category_theory.has_hom.hom.{v₂ u₂} D
                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                       X_1
                       Y),
                     @eq.{v₂+1}
                       (@category_theory.has_hom.hom.{v₂ v₂+1} (Type v₂)
                          (@category_theory.category_struct.to_has_hom.{v₂ v₂+1} (Type v₂)
                             (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                                category_theory.types.{v₂}))
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             Y))
                       (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                             category_theory.types.{v₂})
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             Y)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             Y)
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             X_1
                             Y
                             f)
                          (λ
                           (f :
                             @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                               category_theory.types.{v₂}
                               (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                  (opposite.{u₂+1} D)
                                  (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                  (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                     category_theory.types.{v₂})
                                  (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                     category_theory.types.{v₂})
                                  (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                  (@opposite.op.{u₂+1} D
                                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                        (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                           𝒟
                                           R
                                           L)
                                        X)))
                               Y),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                               (@opposite.unop.{u₂+1} D
                                  (@opposite.op.{u₂+1} D
                                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                        X)))
                               Y
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     Y)
                                  f)))
                       (@category_theory.category_struct.comp.{v₂ v₂+1} (Type v₂)
                          (@category_theory.category.to_category_struct.{v₂ v₂+1} (Type v₂)
                             category_theory.types.{v₂})
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             Y)
                          (λ
                           (f :
                             @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                               category_theory.types.{v₂}
                               (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                  (opposite.{u₂+1} D)
                                  (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                  (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                     category_theory.types.{v₂})
                                  (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                     category_theory.types.{v₂})
                                  (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                  (@opposite.op.{u₂+1} D
                                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                        (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                           𝒟
                                           R
                                           L)
                                        X)))
                               X_1),
                             @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1
                               (@opposite.unop.{u₂+1} D
                                  (@opposite.op.{u₂+1} D
                                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                        X)))
                               X_1
                               (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                  (equiv.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                     (@category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                     X_1)
                                  f))
                          (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                             category_theory.types.{v₂}
                             (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                (opposite.{u₂+1} D)
                                (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                   category_theory.types.{v₂})
                                (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                (@opposite.op.{u₂+1} D
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)))
                             X_1
                             Y
                             f)))
                  (λ (X : D) ⦃X_1 Y : D⦄
                   (f :
                     @category_theory.has_hom.hom.{v₂ u₂} D
                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                       X_1
                       Y),
                     @eq.mpr.{0}
                       (@eq.{v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1 →
                           @category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@function.comp.{v₂+1 v₂+1 v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                Y)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (λ
                              (f :
                                @category_theory.has_hom.hom.{v₂ u₂} D
                                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                  Y),
                                @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X Y
                                  (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                     (equiv.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                           Y)
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                     (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                           Y)
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R Y)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        Y)
                                     f))
                             (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂}
                                (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                   (opposite.{u₂+1} D)
                                   (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                   (@opposite.op.{u₂+1} D
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                                X_1
                                Y
                                f))
                          (@function.comp.{v₂+1 v₂+1 v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂}
                                (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                   (opposite.{u₂+1} D)
                                   (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                   (@opposite.op.{u₂+1} D X))
                                X_1
                                Y
                                f)
                             (λ
                              (f :
                                @category_theory.has_hom.hom.{v₂ u₂} D
                                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                  X_1),
                                @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X X_1
                                  (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                     (equiv.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                           X_1)
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                     (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                        (@category_theory.has_hom.hom.{v₂ u₂} D
                                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                           X_1)
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X_1)))
                                     (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                        X_1)
                                     f))))
                       (@eq.{v₂+1}
                          (@category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                             X_1 →
                           @category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             X
                             Y)
                          (@function.comp.{v₂+1 v₂+1 v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                Y)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                Y
                                (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         L
                                         R)
                                      (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                             (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂}
                                (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                   (opposite.{u₂+1} D)
                                   (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                   (@opposite.op.{u₂+1} D
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                                X_1
                                Y
                                f))
                          (@function.comp.{v₂+1 v₂+1 v₂+1}
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                X_1)
                             (@category_theory.has_hom.hom.{v₂ u₂} D
                                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                X
                                Y)
                             (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                category_theory.types.{v₂}
                                (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                   (opposite.{u₂+1} D)
                                   (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂})
                                   (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                   (@opposite.op.{u₂+1} D X))
                                X_1
                                Y
                                f)
                             (@category_theory.category_struct.comp.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                X
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                X_1
                                (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         L
                                         R)
                                      (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                   X_1 →
                                 @category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   X
                                   Y)
                                (@function.comp.{v₂+1 v₂+1 v₂+1}
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                      X_1)
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                      Y)
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      X
                                      Y)
                                   (λ
                                    (f :
                                      @category_theory.has_hom.hom.{v₂ u₂} D
                                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                        Y),
                                      @category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X
                                        Y
                                        (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1))
                                           (max (v₂+1) (v₁+1))}
                                           (equiv.{v₂+1 v₁+1}
                                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                       X))
                                                 Y)
                                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                    Y)))
                                           (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                       X))
                                                 Y)
                                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R
                                                    Y)))
                                           (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                              R
                                              h
                                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                                              Y)
                                           f))
                                   (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂}
                                      (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))}
                                         (opposite.{u₂+1} D)
                                         (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
                                         (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                            category_theory.types.{v₂})
                                         (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                            category_theory.types.{v₂})
                                         (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
                                         (@opposite.op.{u₂+1} D
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))))
                                      X_1
                                      Y
                                      f))
                                (@function.comp.{v₂+1 v₂+1 v₂+1}
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                                      X_1)
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      X
                                      X_1)
                                   (@category_theory.has_hom.hom.{v₂ u₂} D
                                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                      X
                                      Y)
                                   (@category_theory.functor.map.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂)
                                      category_theory.types.{v₂}
                                      …
                                      X_1
                                      Y
                                      f)
                                   …))
                             …)
                          …)
                       …)
                  X
                  X_1
                  Y
                  f)))
       x
       x_1)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X x : D,
x_1 :
  @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
    (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
       (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
       (@opposite.op.{u₂+1} D
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             X)))
    x
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       X
       x)
    (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X x
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                x)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                x)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
             x)
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
             X
             x
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                X)
             x_1)))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58      apply R.injectivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X x : D,
x_1 :
  @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
    (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
       (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
       (@opposite.op.{u₂+1} D
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             X)))
    x
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       X
       x)
    (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X x
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                x)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                x)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
             x)
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
             X
             x
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                X)
             x_1)))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X x : D,
x_1 :
  @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
    (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
       (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
       (@opposite.op.{u₂+1} D
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             X)))
    x
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x))
    (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X x
       (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X x
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                   x)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                   x)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                x)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                X
                x
                (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                   X)
                x_1))))
    (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X x x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59      simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
L : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
h : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R,
_inst_1 : @category_theory.full.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
_inst_2 : @category_theory.faithful.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R,
X x : D,
x_1 :
  @category_theory.functor.obj.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂}
    (@category_theory.functor.obj.{v₂ (max u₂ v₂) u₂ (max v₂ u₂ (v₂+1))} (opposite.{u₂+1} D)
       (@category_theory.category.opposite.{v₂ u₂} D 𝒟)
       (@category_theory.functor.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.functor.category.{v₂ v₂ u₂ v₂+1} D 𝒟 (Type v₂) category_theory.types.{v₂})
       (@category_theory.coyoneda.{v₂ u₂} D 𝒟)
       (@opposite.op.{u₂+1} D
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             X)))
    x
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x))
    (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X x
       (@category_theory.functor.preimage.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R _inst_1 X x
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                   x)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                   x)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R x)))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X)
                x)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X))
                X
                x
                (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 R L)
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 L R h)
                   X)
                x_1))))
    (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 R X x x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  -- TODO also prove the converses?</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  -- def L_full_of_unit_is_iso [is_iso (adjunction.unit h)] : full L := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  -- def L_faithful_of_unit_is_iso [is_iso (adjunction.unit h)] : faithful L := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  -- def R_full_of_counit_is_iso [is_iso (adjunction.counit h)] : full R := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  -- def R_faithful_of_counit_is_iso [is_iso (adjunction.counit h)] : faithful R := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  -- TODO also do the statements from Riehl 4.5.13 for full and faithful separately?</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  end category_theory</code></pre>
</body>