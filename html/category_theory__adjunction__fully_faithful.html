<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.adjunction.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.yoneda</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  universes vâ‚ vâ‚‚ uâ‚ uâ‚‚</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  open category</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  variables {C : Type uâ‚} [ğ’ : category.{vâ‚} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u â†’ Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  variables {D : Type uâ‚‚} [ğ’Ÿ : category.{vâ‚‚} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u â†’ Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  include ğ’ ğ’Ÿ</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  variables {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  -- Lemma 4.5.13 from [Riehl][riehl2017]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  -- Proof in &lt;https://stacks.math.columbia.edu/tag/0036&gt;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  -- or at &lt;https://math.stackexchange.com/a/2727177&gt;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  instance unit_is_iso_of_L_fully_faithful [full L] [faithful L] : is_iso (adjunction.unit h) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  @nat_iso.is_iso_of_is_iso_app _ _ _ _ _ _ (adjunction.unit h) $ Î» X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  @yoneda.is_iso _ _ _ _ ((adjunction.unit h).app X)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  { inv := { app := Î» Y f, L.preimage ((h.hom_equiv (unop Y) (L.obj X)).symm f) },</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    inv_hom_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32      simp only [adjunction.hom_equiv_counit, preimage_comp, preimage_map, category.assoc],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33      rw â†h.unit_naturality,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34      simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    hom_inv_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
_inst_2 : @category_theory.faithful.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
X : C
âŠ¢ @eq.{(max uâ‚ vâ‚)+1}
    (@category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
       (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})))
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X))
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)))
    ((Î»
      (_x _x_1 _x_2 :
        @category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
      (Î± :
        @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.has_hom.mk.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (Î»
              (F G :
                @category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                  (Type vâ‚)
                  category_theory.types.{vâ‚}),
                @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                  (Type vâ‚)
                  category_theory.types.{vâ‚}
                  F
                  G))
          _x
          _x_1)
      (Î² :
        @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.has_hom.mk.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (Î»
              (F G :
                @category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                  (Type vâ‚)
                  category_theory.types.{vâ‚}),
                @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                  (Type vâ‚)
                  category_theory.types.{vâ‚}
                  F
                  G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚}
          _x
          _x_1
          _x_2
          Î±
          Î²)
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X))
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
             X))
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X))
       (@category_theory.functor.map.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
             (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
             X))
       (@category_theory.nat_trans.mk.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚}
          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                X))
          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X))
          (Î» (Y : opposite.{uâ‚+1} C)
           (f :
             @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
               (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
               (Type vâ‚)
               category_theory.types.{vâ‚}
               (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                  (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                     (Type vâ‚)
                     category_theory.types.{vâ‚})
                  (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                     (Type vâ‚)
                     category_theory.types.{vâ‚})
                  (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                     (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                     X))
               Y),
             @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
               (@opposite.unop.{uâ‚+1} C Y)
               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                  (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                  X)
               (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                  (equiv.{vâ‚+1 vâ‚‚+1}
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@opposite.unop.{uâ‚+1} C Y)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@opposite.unop.{uâ‚+1} C Y))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                  (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@opposite.unop.{uâ‚+1} C Y)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@opposite.unop.{uâ‚+1} C Y))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                  (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@opposite.unop.{uâ‚+1} C Y))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@opposite.unop.{uâ‚+1} C Y)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                        (@opposite.unop.{uâ‚+1} C Y)
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                  f))
          (Î» (X_1 Y : opposite.{uâ‚+1} C)
           (f :
             @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)))
               X_1
               Y),
             @id.{0}
               (âˆ€ (X : C) â¦ƒX_1 Y : opposite.{uâ‚+1} Câ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)))
                    X_1
                    Y),
                  @eq.{vâ‚+1}
                    (@category_theory.has_hom.hom.{vâ‚ vâ‚+1} (Type vâ‚)
                       (@category_theory.category_struct.to_has_hom.{vâ‚ vâ‚+1} (Type vâ‚)
                          (@category_theory.category.to_category_struct.{vâ‚ vâ‚+1} (Type vâ‚)
                             category_theory.types.{vâ‚}))
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          Y))
                    (@category_theory.category_struct.comp.{vâ‚ vâ‚+1} (Type vâ‚)
                       (@category_theory.category.to_category_struct.{vâ‚ vâ‚+1} (Type vâ‚)
                          category_theory.types.{vâ‚})
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          Y)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          Y)
                       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          X_1
                          Y
                          f)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                            (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                            (Type vâ‚)
                            category_theory.types.{vâ‚}
                            (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                               (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                  (Type vâ‚)
                                  category_theory.types.{vâ‚})
                               (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                  (Type vâ‚)
                                  category_theory.types.{vâ‚})
                               (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                     R)
                                  X))
                            Y),
                          @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                            (@opposite.unop.{uâ‚+1} C Y)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                               (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                               X)
                            (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                               (equiv.{vâ‚+1 vâ‚‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C Y)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C Y))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C Y)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C Y))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C Y))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C Y)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@opposite.unop.{uâ‚+1} C Y)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               f)))
                    (@category_theory.category_struct.comp.{vâ‚ vâ‚+1} (Type vâ‚)
                       (@category_theory.category.to_category_struct.{vâ‚ vâ‚+1} (Type vâ‚)
                          category_theory.types.{vâ‚})
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          Y)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                            (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                            (Type vâ‚)
                            category_theory.types.{vâ‚}
                            (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                               (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                  (Type vâ‚)
                                  category_theory.types.{vâ‚})
                               (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                  (Type vâ‚)
                                  category_theory.types.{vâ‚})
                               (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                     R)
                                  X))
                            X_1),
                          @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                            (@opposite.unop.{uâ‚+1} C X_1)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                               (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                               X)
                            (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                               (equiv.{vâ‚+1 vâ‚‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C X_1)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C X_1))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C X_1)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C X_1))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C X_1))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C X_1)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@opposite.unop.{uâ‚+1} C X_1)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               f))
                       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          X_1
                          Y
                          f)))
               (Î» (X : C) â¦ƒX_1 Y : opposite.{uâ‚+1} Câ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{vâ‚+1}
                       (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                          (@opposite.unop.{uâ‚+1} C X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)) â†’
                        @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                          (@opposite.unop.{uâ‚+1} C Y)
                          X)
                       (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             X)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@opposite.unop.{uâ‚+1} C Y)
                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))),
                             @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                               (@opposite.unop.{uâ‚+1} C Y)
                               X
                               (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                                  (equiv.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C Y))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C Y))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C Y))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  f))
                          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             X)
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             X)
                          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                X)
                             X_1
                             Y
                             f)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@opposite.unop.{uâ‚+1} C X_1)
                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))),
                             @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                               (@opposite.unop.{uâ‚+1} C X_1)
                               X
                               (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                                  (equiv.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C X_1))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C X_1))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C X_1))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  f))))
                    (@eq.{vâ‚+1}
                       (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                          (@opposite.unop.{uâ‚+1} C X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)) â†’
                        @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                          (@opposite.unop.{uâ‚+1} C Y)
                          X)
                       (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             X)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@opposite.unop.{uâ‚+1} C Y)
                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))),
                             @category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@opposite.unop.{uâ‚+1} C Y)
                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                               X
                               f
                               (@category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                  X
                                  (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                                        R
                                        L)
                                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                     (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))))
                          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C â€¦ â€¦ X)
                          â€¦
                          â€¦
                          â€¦))
                    â€¦
                    â€¦)
               X
               X_1
               Y
               f)))
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
_inst_2 : @category_theory.faithful.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
X : C
âŠ¢ @eq.{(max uâ‚ vâ‚)+1}
    (@category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
       (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})))
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X))
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)))
    ((Î»
      (_x _x_1 _x_2 :
        @category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
      (Î± :
        @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.has_hom.mk.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (Î»
              (F G :
                @category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                  (Type vâ‚)
                  category_theory.types.{vâ‚}),
                @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                  (Type vâ‚)
                  category_theory.types.{vâ‚}
                  F
                  G))
          _x
          _x_1)
      (Î² :
        @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.has_hom.mk.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (Î»
              (F G :
                @category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                  (Type vâ‚)
                  category_theory.types.{vâ‚}),
                @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                  (Type vâ‚)
                  category_theory.types.{vâ‚}
                  F
                  G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚}
          _x
          _x_1
          _x_2
          Î±
          Î²)
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X))
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
             X))
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X))
       (@category_theory.functor.map.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
             (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
             X))
       (@category_theory.nat_trans.mk.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚}
          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                X))
          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X))
          (Î» (Y : opposite.{uâ‚+1} C)
           (f :
             @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
               (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
               (Type vâ‚)
               category_theory.types.{vâ‚}
               (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                  (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                     (Type vâ‚)
                     category_theory.types.{vâ‚})
                  (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                     (Type vâ‚)
                     category_theory.types.{vâ‚})
                  (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                     (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                     X))
               Y),
             @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
               (@opposite.unop.{uâ‚+1} C Y)
               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                  (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                  X)
               (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                  (equiv.{vâ‚+1 vâ‚‚+1}
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@opposite.unop.{uâ‚+1} C Y)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@opposite.unop.{uâ‚+1} C Y))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                  (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@opposite.unop.{uâ‚+1} C Y)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@opposite.unop.{uâ‚+1} C Y))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                  (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@opposite.unop.{uâ‚+1} C Y))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@opposite.unop.{uâ‚+1} C Y)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                        (@opposite.unop.{uâ‚+1} C Y)
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                  f))
          (Î» (X_1 Y : opposite.{uâ‚+1} C)
           (f :
             @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)))
               X_1
               Y),
             @id.{0}
               (âˆ€ (X : C) â¦ƒX_1 Y : opposite.{uâ‚+1} Câ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)))
                    X_1
                    Y),
                  @eq.{vâ‚+1}
                    (@category_theory.has_hom.hom.{vâ‚ vâ‚+1} (Type vâ‚)
                       (@category_theory.category_struct.to_has_hom.{vâ‚ vâ‚+1} (Type vâ‚)
                          (@category_theory.category.to_category_struct.{vâ‚ vâ‚+1} (Type vâ‚)
                             category_theory.types.{vâ‚}))
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          Y))
                    (@category_theory.category_struct.comp.{vâ‚ vâ‚+1} (Type vâ‚)
                       (@category_theory.category.to_category_struct.{vâ‚ vâ‚+1} (Type vâ‚)
                          category_theory.types.{vâ‚})
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          Y)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          Y)
                       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          X_1
                          Y
                          f)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                            (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                            (Type vâ‚)
                            category_theory.types.{vâ‚}
                            (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                               (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                  (Type vâ‚)
                                  category_theory.types.{vâ‚})
                               (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                  (Type vâ‚)
                                  category_theory.types.{vâ‚})
                               (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                     R)
                                  X))
                            Y),
                          @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                            (@opposite.unop.{uâ‚+1} C Y)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                               (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                               X)
                            (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                               (equiv.{vâ‚+1 vâ‚‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C Y)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C Y))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C Y)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C Y))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C Y))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C Y)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@opposite.unop.{uâ‚+1} C Y)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               f)))
                    (@category_theory.category_struct.comp.{vâ‚ vâ‚+1} (Type vâ‚)
                       (@category_theory.category.to_category_struct.{vâ‚ vâ‚+1} (Type vâ‚)
                          category_theory.types.{vâ‚})
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          Y)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                            (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                            (Type vâ‚)
                            category_theory.types.{vâ‚}
                            (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                               (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                  (Type vâ‚)
                                  category_theory.types.{vâ‚})
                               (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                  (Type vâ‚)
                                  category_theory.types.{vâ‚})
                               (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                     R)
                                  X))
                            X_1),
                          @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                            (@opposite.unop.{uâ‚+1} C X_1)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                               (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                               X)
                            (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                               (equiv.{vâ‚+1 vâ‚‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C X_1)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C X_1))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C X_1)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C X_1))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@opposite.unop.{uâ‚+1} C X_1))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@opposite.unop.{uâ‚+1} C X_1)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@opposite.unop.{uâ‚+1} C X_1)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                               f))
                       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                          (Type vâ‚)
                          category_theory.types.{vâ‚}
                          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚})
                             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X))
                          X_1
                          Y
                          f)))
               (Î» (X : C) â¦ƒX_1 Y : opposite.{uâ‚+1} Câ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{vâ‚+1}
                       (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                          (@opposite.unop.{uâ‚+1} C X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)) â†’
                        @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                          (@opposite.unop.{uâ‚+1} C Y)
                          X)
                       (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             X)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@opposite.unop.{uâ‚+1} C Y)
                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))),
                             @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                               (@opposite.unop.{uâ‚+1} C Y)
                               X
                               (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                                  (equiv.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C Y))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C Y))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C Y))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  f))
                          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             X)
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             X)
                          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                X)
                             X_1
                             Y
                             f)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@opposite.unop.{uâ‚+1} C X_1)
                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))),
                             @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                               (@opposite.unop.{uâ‚+1} C X_1)
                               X
                               (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                                  (equiv.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C X_1))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C X_1))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C X_1))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  f))))
                    (@eq.{vâ‚+1}
                       (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                          (@opposite.unop.{uâ‚+1} C X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)) â†’
                        @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                          (@opposite.unop.{uâ‚+1} C Y)
                          X)
                       (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             X)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@opposite.unop.{uâ‚+1} C Y)
                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))),
                             @category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@opposite.unop.{uâ‚+1} C Y)
                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                               X
                               f
                               (@category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                  X
                                  (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                                        R
                                        L)
                                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                     (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))))
                          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C â€¦ â€¦ X)
                          â€¦
                          â€¦
                          â€¦))
                    â€¦
                    â€¦)
               X
               X_1
               Y
               f)))
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
_inst_2 : @category_theory.faithful.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
X : C,
x : opposite.{uâ‚+1} C,
x_1 :
  @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
    (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
    (Type vâ‚)
    category_theory.types.{vâ‚}
    (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
       (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X))
    x
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
       (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
       (Type vâ‚)
       category_theory.types.{vâ‚}
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X))
       x)
    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
       (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
       (Type vâ‚)
       category_theory.types.{vâ‚}
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X))
       (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
          (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
          (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X))
       ((Î»
         (_x _x_1 _x_2 :
           @category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚})
         (Î± :
           @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.has_hom.mk.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                   (Type vâ‚)
                   category_theory.types.{vâ‚})
                (Î»
                 (F G :
                   @category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                     (Type vâ‚)
                     category_theory.types.{vâ‚}),
                   @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                     (Type vâ‚)
                     category_theory.types.{vâ‚}
                     F
                     G))
             _x
             _x_1)
         (Î² :
           @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.has_hom.mk.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))}
                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                   (Type vâ‚)
                   category_theory.types.{vâ‚})
                (Î»
                 (F G :
                   @category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                     (Type vâ‚)
                     category_theory.types.{vâ‚}),
                   @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                     (Type vâ‚)
                     category_theory.types.{vâ‚}
                     F
                     G))
             _x_1
             _x_2),
           @category_theory.nat_trans.vcomp.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚}
             _x
             _x_1
             _x_2
             Î±
             Î²)
          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X))
          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                X))
          (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X))
          (@category_theory.functor.map.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                (Type vâ‚)
                category_theory.types.{vâ‚})
             (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                X)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                X))
          (@category_theory.nat_trans.mk.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
             (Type vâ‚)
             category_theory.types.{vâ‚}
             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                   (Type vâ‚)
                   category_theory.types.{vâ‚})
                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                   (Type vâ‚)
                   category_theory.types.{vâ‚})
                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                   X))
             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                   (Type vâ‚)
                   category_theory.types.{vâ‚})
                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                   (Type vâ‚)
                   category_theory.types.{vâ‚})
                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (Î» (Y : opposite.{uâ‚+1} C)
              (f :
                @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                  (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                  (Type vâ‚)
                  category_theory.types.{vâ‚}
                  (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                     (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                        (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                        (Type vâ‚)
                        category_theory.types.{vâ‚})
                     (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                        (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                        (Type vâ‚)
                        category_theory.types.{vâ‚})
                     (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                        (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                        X))
                  Y),
                @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                  (@opposite.unop.{uâ‚+1} C Y)
                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                     (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                     X)
                  (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                     (equiv.{vâ‚+1 vâ‚‚+1}
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@opposite.unop.{uâ‚+1} C Y)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                              (@opposite.unop.{uâ‚+1} C Y))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                     (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@opposite.unop.{uâ‚+1} C Y)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                              (@opposite.unop.{uâ‚+1} C Y))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                     (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                              (@opposite.unop.{uâ‚+1} C Y))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@opposite.unop.{uâ‚+1} C Y)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                        (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                           (@opposite.unop.{uâ‚+1} C Y)
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                     f))
             (Î» (X_1 Y : opposite.{uâ‚+1} C)
              (f :
                @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                        (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)))
                  X_1
                  Y),
                @id.{0}
                  (âˆ€ (X : C) â¦ƒX_1 Y : opposite.{uâ‚+1} Câ¦„
                   (f :
                     @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)))
                       X_1
                       Y),
                     @eq.{vâ‚+1}
                       (@category_theory.has_hom.hom.{vâ‚ vâ‚+1} (Type vâ‚)
                          (@category_theory.category_struct.to_has_hom.{vâ‚ vâ‚+1} (Type vâ‚)
                             (@category_theory.category.to_category_struct.{vâ‚ vâ‚+1} (Type vâ‚)
                                category_theory.types.{vâ‚}))
                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   X))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   X))
                             Y))
                       (@category_theory.category_struct.comp.{vâ‚ vâ‚+1} (Type vâ‚)
                          (@category_theory.category.to_category_struct.{vâ‚ vâ‚+1} (Type vâ‚)
                             category_theory.types.{vâ‚})
                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   X))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   X))
                             Y)
                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   X))
                             Y)
                          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   X))
                             X_1
                             Y
                             f)
                          (Î»
                           (f :
                             @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                               (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                               (Type vâ‚)
                               category_theory.types.{vâ‚}
                               (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                  (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                     (Type vâ‚)
                                     category_theory.types.{vâ‚})
                                  (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                     (Type vâ‚)
                                     category_theory.types.{vâ‚})
                                  (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                     (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                                        L
                                        R)
                                     X))
                               Y),
                             @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                               (@opposite.unop.{uâ‚+1} C Y)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                  X)
                               (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                                  (equiv.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C Y))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C Y))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C Y))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@opposite.unop.{uâ‚+1} C Y)
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  f)))
                       (@category_theory.category_struct.comp.{vâ‚ vâ‚+1} (Type vâ‚)
                          (@category_theory.category.to_category_struct.{vâ‚ vâ‚+1} (Type vâ‚)
                             category_theory.types.{vâ‚})
                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   X))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   X))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   X))
                             Y)
                          (Î»
                           (f :
                             @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                               (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                               (Type vâ‚)
                               category_theory.types.{vâ‚}
                               (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                  (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                     (Type vâ‚)
                                     category_theory.types.{vâ‚})
                                  (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                     (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                     (Type vâ‚)
                                     category_theory.types.{vâ‚})
                                  (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                     (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                                        L
                                        R)
                                     X))
                               X_1),
                             @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                               (@opposite.unop.{uâ‚+1} C X_1)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                  X)
                               (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                                  (equiv.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C X_1))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C X_1))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@opposite.unop.{uâ‚+1} C X_1))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@opposite.unop.{uâ‚+1} C X_1)
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                  f))
                          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                             (Type vâ‚)
                             category_theory.types.{vâ‚}
                             (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
                                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                   (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                   (Type vâ‚)
                                   category_theory.types.{vâ‚})
                                (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   X))
                             X_1
                             Y
                             f)))
                  (Î» (X : C) â¦ƒX_1 Y : opposite.{uâ‚+1} Câ¦„
                   (f :
                     @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} (opposite.{uâ‚+1} C)
                             (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)))
                       X_1
                       Y),
                     @eq.mpr.{0}
                       (@eq.{vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)) â†’
                           @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             X)
                          (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C X_1)
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C Y)
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C Y)
                                X)
                             (Î»
                              (f :
                                @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@opposite.unop.{uâ‚+1} C Y)
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))),
                                @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                                  (@opposite.unop.{uâ‚+1} C Y)
                                  X
                                  (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                                     (equiv.{vâ‚+1 vâ‚‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@opposite.unop.{uâ‚+1} C Y)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@opposite.unop.{uâ‚+1} C Y))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@opposite.unop.{uâ‚+1} C Y)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@opposite.unop.{uâ‚+1} C Y))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@opposite.unop.{uâ‚+1} C Y))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@opposite.unop.{uâ‚+1} C Y)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                        (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                           (@opposite.unop.{uâ‚+1} C Y)
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     f))
                             (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚}
                                (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C
                                   ğ’
                                   (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                      (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                      (Type vâ‚)
                                      category_theory.types.{vâ‚})
                                   (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                      (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                      (Type vâ‚)
                                      category_theory.types.{vâ‚})
                                   (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                X_1
                                Y
                                f))
                          (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C X_1)
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C X_1)
                                X)
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C Y)
                                X)
                             (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚}
                                (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C
                                   ğ’
                                   (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                      (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                      (Type vâ‚)
                                      category_theory.types.{vâ‚})
                                   (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                      (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                      (Type vâ‚)
                                      category_theory.types.{vâ‚})
                                   (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                   X)
                                X_1
                                Y
                                f)
                             (Î»
                              (f :
                                @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@opposite.unop.{uâ‚+1} C X_1)
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))),
                                @category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                                  (@opposite.unop.{uâ‚+1} C X_1)
                                  X
                                  (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                                     (equiv.{vâ‚+1 vâ‚‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@opposite.unop.{uâ‚+1} C X_1)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@opposite.unop.{uâ‚+1} C X_1))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@opposite.unop.{uâ‚+1} C X_1)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@opposite.unop.{uâ‚+1} C X_1))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@opposite.unop.{uâ‚+1} C X_1))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@opposite.unop.{uâ‚+1} C X_1)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                        (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                           (@opposite.unop.{uâ‚+1} C X_1)
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                     f))))
                       (@eq.{vâ‚+1}
                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C X_1)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)) â†’
                           @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@opposite.unop.{uâ‚+1} C Y)
                             X)
                          (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C X_1)
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C Y)
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C Y)
                                X)
                             (Î»
                              (f :
                                @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@opposite.unop.{uâ‚+1} C Y)
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))),
                                @category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@opposite.unop.{uâ‚+1} C Y)
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                  X
                                  f
                                  (@category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                                     X
                                     (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                        (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                           ğ’Ÿ
                                           R
                                           L)
                                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                        (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))))
                             (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                (Type vâ‚)
                                category_theory.types.{vâ‚}
                                (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C
                                   ğ’
                                   (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                      (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                      (Type vâ‚)
                                      category_theory.types.{vâ‚})
                                   (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
                                      (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
                                      (Type vâ‚)
                                      category_theory.types.{vâ‚})
                                   (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                                X_1
                                Y
                                f))
                          (@function.comp.{vâ‚+1 vâ‚+1 vâ‚+1}
                             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                (@opposite.unop.{uâ‚+1} C X_1)
                                (â€¦ R â€¦))
                             â€¦
                             â€¦
                             â€¦
                             â€¦))
                       â€¦
                       â€¦)
                  X
                  X_1
                  Y
                  f)))
       x
       x_1)
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
_inst_2 : @category_theory.faithful.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
X : C,
x : opposite.{uâ‚+1} C,
x_1 :
  @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
    (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
    (Type vâ‚)
    category_theory.types.{vâ‚}
    (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
       (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X))
    x
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@opposite.unop.{uâ‚+1} C x)
       X)
    (@category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1 (@opposite.unop.{uâ‚+1} C x) X
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@opposite.unop.{uâ‚+1} C x)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@opposite.unop.{uâ‚+1} C x)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@opposite.unop.{uâ‚+1} C x)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                (@opposite.unop.{uâ‚+1} C x)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@opposite.unop.{uâ‚+1} C x)
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
             x_1
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                X))))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      apply L.injectivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
_inst_2 : @category_theory.faithful.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
X : C,
x : opposite.{uâ‚+1} C,
x_1 :
  @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
    (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
    (Type vâ‚)
    category_theory.types.{vâ‚}
    (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
       (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X))
    x
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@opposite.unop.{uâ‚+1} C x)
       X)
    (@category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1 (@opposite.unop.{uâ‚+1} C x) X
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@opposite.unop.{uâ‚+1} C x)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@opposite.unop.{uâ‚+1} C x)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@opposite.unop.{uâ‚+1} C x)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                (@opposite.unop.{uâ‚+1} C x)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@opposite.unop.{uâ‚+1} C x)
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
             x_1
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                X))))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
_inst_2 : @category_theory.faithful.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
X : C,
x : opposite.{uâ‚+1} C,
x_1 :
  @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
    (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
    (Type vâ‚)
    category_theory.types.{vâ‚}
    (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
       (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X))
    x
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
    (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x) X
       (@category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1 (@opposite.unop.{uâ‚+1} C x) X
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@opposite.unop.{uâ‚+1} C x)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@opposite.unop.{uâ‚+1} C x)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@opposite.unop.{uâ‚+1} C x)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                   (@opposite.unop.{uâ‚+1} C x)
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (@opposite.unop.{uâ‚+1} C x)
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                x_1
                (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                   (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                   X)))))
    (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x) X x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40      simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
_inst_2 : @category_theory.faithful.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L,
X : C,
x : opposite.{uâ‚+1} C,
x_1 :
  @category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
    (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
    (Type vâ‚)
    category_theory.types.{vâ‚}
    (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} C ğ’
       (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} (opposite.{uâ‚+1} C)
          (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’)
          (Type vâ‚)
          category_theory.types.{vâ‚})
       (@category_theory.yoneda.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X))
    x
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
    (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x) X
       (@category_theory.functor.preimage.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L _inst_1 (@opposite.unop.{uâ‚+1} C x) X
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@opposite.unop.{uâ‚+1} C x)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@opposite.unop.{uâ‚+1} C x)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@opposite.unop.{uâ‚+1} C x)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
                (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                   (@opposite.unop.{uâ‚+1} C x)
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (@opposite.unop.{uâ‚+1} C x)
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L X))
                x_1
                (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                   (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                   X)))))
    (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@opposite.unop.{uâ‚+1} C x) X x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    end }.</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  instance counit_is_iso_of_R_fully_faithful [full R] [faithful R] : is_iso (adjunction.counit h) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ Type (max uâ‚‚ vâ‚‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) X Y â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='A functor `F : C â¥¤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X âŸ¶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C â¥¤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  @nat_iso.is_iso_of_is_iso_app _ _ _ _ _ _ (adjunction.counit h) $ Î» X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_iso.is_iso_of_is_iso_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_isomorphism.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} (Î± : @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) F G) [_inst_1 : Î  (X : C), @category_theory.is_iso.{vâ‚‚ uâ‚‚} D ğ’Ÿ (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G X) (@category_theory.nat_trans.app.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G Î± X)], @category_theory.is_iso.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) F G Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  @is_iso_of_op _ _ _ _ _ $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.is_iso_of_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {X Y : C} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y) [_inst_1 : @category_theory.is_iso.{vâ‚ uâ‚} (opposite.{uâ‚+1} C) (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’) (@opposite.op.{uâ‚+1} C Y) (@opposite.op.{uâ‚+1} C X) (@category_theory.has_hom.hom.op.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y f)], @category_theory.is_iso.{vâ‚ uâ‚} C ğ’ X Y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  @coyoneda.is_iso _ _ _ _ ((adjunction.counit h).app X).op</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.coyoneda.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {X Y : opposite.{uâ‚+1} C} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} (opposite.{uâ‚+1} C) (@category_theory.has_hom.opposite.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))) X Y) [_inst_1 : @category_theory.is_iso.{(max uâ‚ vâ‚) (max vâ‚ uâ‚ (vâ‚+1))} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} C ğ’ (Type vâ‚) category_theory.types.{vâ‚}) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} C ğ’ (Type vâ‚) category_theory.types.{vâ‚}) (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} (opposite.{uâ‚+1} C) (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} C ğ’ (Type vâ‚) category_theory.types.{vâ‚}) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} C ğ’ (Type vâ‚) category_theory.types.{vâ‚}) (@category_theory.coyoneda.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} (opposite.{uâ‚+1} C) (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} C ğ’ (Type vâ‚) category_theory.types.{vâ‚}) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} C ğ’ (Type vâ‚) category_theory.types.{vâ‚}) (@category_theory.coyoneda.{vâ‚ uâ‚} C ğ’) Y) (@category_theory.functor.map.{vâ‚ (max uâ‚ vâ‚) uâ‚ (max vâ‚ uâ‚ (vâ‚+1))} (opposite.{uâ‚+1} C) (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.{vâ‚ vâ‚ uâ‚ vâ‚+1} C ğ’ (Type vâ‚) category_theory.types.{vâ‚}) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ vâ‚+1} C ğ’ (Type vâ‚) category_theory.types.{vâ‚}) (@category_theory.coyoneda.{vâ‚ uâ‚} C ğ’) X Y f)], @category_theory.is_iso.{vâ‚ uâ‚} (opposite.{uâ‚+1} C) (@category_theory.category.opposite.{vâ‚ uâ‚} C ğ’) X Y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.has_hom.{vâ‚‚ uâ‚‚} C] {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C ğ’ X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} (opposite.{uâ‚‚+1} C) (@category_theory.has_hom.opposite.{vâ‚‚ uâ‚‚} C ğ’) (@opposite.op.{uâ‚‚+1} C Y) (@opposite.op.{uâ‚‚+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  { inv := { app := Î» Y f, R.preimage ((h.hom_equiv (R.obj X) Y) f) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D) (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}) (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@opposite.op.{uâ‚‚+1} D (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L) X))) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] (F : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ) [_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ F] {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ F Y) â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C ğ’)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D) (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}) (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@opposite.op.{uâ‚‚+1} D (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L) X))) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48    inv_hom_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X : D
âŠ¢ @eq.{(max uâ‚‚ vâ‚‚)+1}
    (@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                category_theory.types.{vâ‚‚})))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X))))
    (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)))
       (@category_theory.nat_trans.mk.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          (Î» (Y : D)
           (f :
             @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
               (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
                  (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                  (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                     category_theory.types.{vâ‚‚})
                  (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  (@opposite.op.{uâ‚‚+1} D
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                        X)))
               Y),
             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
               (@opposite.unop.{uâ‚‚+1} D
                  (@opposite.op.{uâ‚‚+1} D
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        X)))
               Y
               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                  (equiv.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                        Y)
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                        Y)
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     Y)
                  f))
          (Î» (X_1 Y : D)
           (f :
             @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               X_1
               Y),
             @id.{0}
               (âˆ€ (X : D) â¦ƒX_1 Y : Dâ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                    X_1
                    Y),
                  @eq.{vâ‚‚+1}
                    (@category_theory.has_hom.hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}))
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          Y))
                    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          category_theory.types.{vâ‚‚})
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          Y)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          Y)
                       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1
                          Y
                          f)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                            category_theory.types.{vâ‚‚}
                            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                               (opposite.{uâ‚‚+1} D)
                               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                                        R
                                        L)
                                     X)))
                            Y),
                          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                            (@opposite.unop.{uâ‚‚+1} D
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                     X)))
                            Y
                            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                               (equiv.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                  Y)
                               f)))
                    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          category_theory.types.{vâ‚‚})
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          Y)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                            category_theory.types.{vâ‚‚}
                            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                               (opposite.{uâ‚‚+1} D)
                               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                                        R
                                        L)
                                     X)))
                            X_1),
                          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                            (@opposite.unop.{uâ‚‚+1} D
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                     X)))
                            X_1
                            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                               (equiv.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                  X_1)
                               f))
                       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          X_1
                          Y
                          f)))
               (Î» (X : D) â¦ƒX_1 Y : Dâ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{vâ‚‚+1}
                       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                          X_1 â†’
                        @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          X
                          Y)
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             Y)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                               Y),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     Y)
                                  f))
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D X))
                             X_1
                             Y
                             f)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                               X_1),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X X_1
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     X_1)
                                  f))))
                    (@eq.{vâ‚‚+1}
                       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                          X_1 â†’
                        @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          X
                          Y)
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             Y)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             X
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             Y
                             (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D X))
                             X_1
                             Y
                             f)
                          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             X
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1
                             (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1 â†’
                              @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   Y)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   Y)
                                (Î»
                                 (f :
                                   @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     Y),
                                   @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
                                     (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1))
                                        (max (vâ‚‚+1) (vâ‚+1))}
                                        (equiv.{vâ‚‚+1 vâ‚+1}
                                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                        (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                        (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           Y)
                                        f))
                                (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚}
                                   (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                      (opposite.{uâ‚‚+1} D)
                                      (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@opposite.op.{uâ‚‚+1} D
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                                   X_1
                                   Y
                                   f))
                             (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   X_1)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   Y)
                                (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚}
                                   (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                      (opposite.{uâ‚‚+1} D)
                                      (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@opposite.op.{uâ‚‚+1} D X))
                                   X_1
                                   Y
                                   f)
                                (Î»
                                 (f :
                                   @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     X_1),
                                   @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X X_1
                                     (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1))
                                        (max (vâ‚‚+1) (vâ‚+1))}
                                        (equiv.{vâ‚‚+1 vâ‚+1}
                                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                              X_1)
                                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                        (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                              X_1)
                                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                        (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           X_1)
                                        f))))
                          â€¦)
                       â€¦)
                    â€¦)
               X
               X_1
               Y
               f))
       â€¦)
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X_1
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚}))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y))
    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y)
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1
          Y
          f)
       (Î»
        (f :
          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                  category_theory.types.{vâ‚‚})
               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                     X)))
            Y),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
            (@opposite.unop.{uâ‚‚+1} D
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            Y
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  Y)
               f)))
    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y)
       (Î»
        (f :
          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                  category_theory.types.{vâ‚‚})
               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                     X)))
            X_1),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
            (@opposite.unop.{uâ‚‚+1} D
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            X_1
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  X_1)
               f))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          X_1
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X_1
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚}))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y))
    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y)
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1
          Y
          f)
       (Î»
        (f :
          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                  category_theory.types.{vâ‚‚})
               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                     X)))
            Y),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
            (@opposite.unop.{uâ‚‚+1} D
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            Y
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  Y)
               f)))
    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y)
       (Î»
        (f :
          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                  category_theory.types.{vâ‚‚})
               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                     X)))
            X_1),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
            (@opposite.unop.{uâ‚‚+1} D
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            X_1
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  X_1)
               f))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          X_1
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X x : D,
x_1 :
  @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
    (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
       (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@opposite.op.{uâ‚‚+1} D
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
             X)))
    x
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)))
       x)
    (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)))
       (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                category_theory.types.{vâ‚‚}))
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          (@category_theory.nat_trans.mk.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                   category_theory.types.{vâ‚‚})
                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@opposite.op.{uâ‚‚+1} D
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                      X)))
             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                   category_theory.types.{vâ‚‚})
                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@opposite.op.{uâ‚‚+1} D
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      X)))
             (Î» (Y : D)
              (f :
                @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
                  (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                     (opposite.{uâ‚‚+1} D)
                     (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                     (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                        category_theory.types.{vâ‚‚})
                     (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     (@opposite.op.{uâ‚‚+1} D
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                           X)))
                  Y),
                @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                  (@opposite.unop.{uâ‚‚+1} D
                     (@opposite.op.{uâ‚‚+1} D
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X)))
                  Y
                  (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                     (equiv.{vâ‚‚+1 vâ‚+1}
                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                           Y)
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                     (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                           Y)
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                        Y)
                     f))
             (Î» (X_1 Y : D)
              (f :
                @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  X_1
                  Y),
                @id.{0}
                  (âˆ€ (X : D) â¦ƒX_1 Y : Dâ¦„
                   (f :
                     @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                       X_1
                       Y),
                     @eq.{vâ‚‚+1}
                       (@category_theory.has_hom.hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                             (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}))
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             Y))
                       (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                             category_theory.types.{vâ‚‚})
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             Y)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             Y)
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             X_1
                             Y
                             f)
                          (Î»
                           (f :
                             @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                               category_theory.types.{vâ‚‚}
                               (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                  (opposite.{uâ‚‚+1} D)
                                  (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                  (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                     category_theory.types.{vâ‚‚})
                                  (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                     category_theory.types.{vâ‚‚})
                                  (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                  (@opposite.op.{uâ‚‚+1} D
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                        (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                           ğ’Ÿ
                                           R
                                           L)
                                        X)))
                               Y),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                               (@opposite.unop.{uâ‚‚+1} D
                                  (@opposite.op.{uâ‚‚+1} D
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                        X)))
                               Y
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     Y)
                                  f)))
                       (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                             category_theory.types.{vâ‚‚})
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             Y)
                          (Î»
                           (f :
                             @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                               category_theory.types.{vâ‚‚}
                               (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                  (opposite.{uâ‚‚+1} D)
                                  (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                  (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                     category_theory.types.{vâ‚‚})
                                  (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                     category_theory.types.{vâ‚‚})
                                  (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                  (@opposite.op.{uâ‚‚+1} D
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                        (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                           ğ’Ÿ
                                           R
                                           L)
                                        X)))
                               X_1),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                               (@opposite.unop.{uâ‚‚+1} D
                                  (@opposite.op.{uâ‚‚+1} D
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                        X)))
                               X_1
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     X_1)
                                  f))
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             X_1
                             Y
                             f)))
                  (Î» (X : D) â¦ƒX_1 Y : Dâ¦„
                   (f :
                     @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                       X_1
                       Y),
                     @eq.mpr.{0}
                       (@eq.{vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1 â†’
                           @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                Y)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (Î»
                              (f :
                                @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                  Y),
                                @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
                                  (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                     (equiv.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                           Y)
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                     (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                           Y)
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        Y)
                                     f))
                             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}
                                (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                   (opposite.{uâ‚‚+1} D)
                                   (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@opposite.op.{uâ‚‚+1} D
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                                X_1
                                Y
                                f))
                          (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}
                                (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                   (opposite.{uâ‚‚+1} D)
                                   (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@opposite.op.{uâ‚‚+1} D X))
                                X_1
                                Y
                                f)
                             (Î»
                              (f :
                                @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                  X_1),
                                @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X X_1
                                  (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                     (equiv.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                           X_1)
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                     (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                           X_1)
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        X_1)
                                     f))))
                       (@eq.{vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1 â†’
                           @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                Y)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                Y
                                (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         L
                                         R)
                                      (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}
                                (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                   (opposite.{uâ‚‚+1} D)
                                   (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@opposite.op.{uâ‚‚+1} D
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                                X_1
                                Y
                                f))
                          (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}
                                (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                   (opposite.{uâ‚‚+1} D)
                                   (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@opposite.op.{uâ‚‚+1} D X))
                                X_1
                                Y
                                f)
                             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1
                                (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         L
                                         R)
                                      (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   X_1 â†’
                                 @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   Y)
                                (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                      X_1)
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                      Y)
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      X
                                      Y)
                                   (Î»
                                    (f :
                                      @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y),
                                      @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                        Y
                                        (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1))
                                           (max (vâ‚‚+1) (vâ‚+1))}
                                           (equiv.{vâ‚‚+1 vâ‚+1}
                                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                       X))
                                                 Y)
                                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                    Y)))
                                           (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                       X))
                                                 Y)
                                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                    Y)))
                                           (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              R
                                              h
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              Y)
                                           f))
                                   (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚}
                                      (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                         (opposite.{uâ‚‚+1} D)
                                         (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                         (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                            category_theory.types.{vâ‚‚})
                                         (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                            category_theory.types.{vâ‚‚})
                                         (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                         (@opposite.op.{uâ‚‚+1} D
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                                      X_1
                                      Y
                                      f))
                                (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                      X_1)
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      X
                                      X_1)
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      X
                                      Y)
                                   (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚}
                                      (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                         (opposite.{uâ‚‚+1} D)
                                         (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                         (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                            category_theory.types.{vâ‚‚})
                                         (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                            category_theory.types.{vâ‚‚})
                                         (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                         (@opposite.op.{uâ‚‚+1} D X))
                                      X_1
                                      Y
                                      f)
                                   (Î»
                                    (f :
                                      @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1),
                                      @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                        X_1
                                        (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1))
                                           (max (vâ‚‚+1) (vâ‚+1))}
                                           (equiv.{vâ‚‚+1 vâ‚+1}
                                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                       X))
                                                 X_1)
                                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                    X_1)))
                                           (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                       X))
                                                 X_1)
                                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                                 â€¦
                                                 â€¦))
                                           â€¦
                                           f))))
                             â€¦)
                          â€¦)
                       â€¦)
                  X
                  X_1
                  Y
                  f))
          â€¦)
       x
       x_1)
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X_1
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚}))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y))
    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y)
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1
          Y
          f)
       (Î»
        (f :
          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                  category_theory.types.{vâ‚‚})
               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                     X)))
            Y),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
            (@opposite.unop.{uâ‚‚+1} D
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            Y
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  Y)
               f)))
    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y)
       (Î»
        (f :
          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                  category_theory.types.{vâ‚‚})
               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                     X)))
            X_1),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
            (@opposite.unop.{uâ‚‚+1} D
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            X_1
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  X_1)
               f))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          X_1
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51      simp only [adjunction.hom_equiv_unit, preimage_comp, preimage_map],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.preimage_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.preimage_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type ?l_1} [ğ’ : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [ğ’Ÿ : category_theory.category.{?l_4 ?l_3} D] {F : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{?l_4 ?l_2 ?l_3 ?l_1} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F G) {X : C} {Y : D} {f : @category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D ğ’Ÿ)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F X) Y}, @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’)) X (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D ğ’Ÿ C ğ’ G Y)) (@coe_fn.{(max 1 (max (?l_4+1) (?l_2+1)) (?l_2+1) (?l_4+1)) (max (?l_4+1) (?l_2+1))} (equiv.{?l_4+1 ?l_2+1} (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D ğ’Ÿ)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’)) X (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{?l_4+1 ?l_2+1} (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D ğ’Ÿ)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’)) X (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D ğ’Ÿ C ğ’ G Y))) (@category_theory.adjunction.hom_equiv.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F G c X Y) f) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’) X (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{?l_4 ?l_2 ?l_3 ?l_1} D ğ’Ÿ C ğ’ G Y) (@category_theory.nat_trans.app.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’ (@category_theory.functor.id.{?l_2 ?l_1} C ğ’) (@category_theory.functor.comp.{?l_2 ?l_4 ?l_2 ?l_1 ?l_3 ?l_1} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F G c) X) (@category_theory.functor.map.{?l_4 ?l_2 ?l_3 ?l_1} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F X) Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type ?l_1} [ğ’ : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [ğ’Ÿ : category_theory.category.{?l_4 ?l_3} D] {F : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ} [_inst_1 : @category_theory.full.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F] [_inst_2 : @category_theory.faithful.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F] {X Y Z : C} (f : @category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D ğ’Ÿ)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F Y)) (g : @category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D ğ’Ÿ)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F Y) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F Z)), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’)) X Z) (@category_theory.functor.preimage.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F _inst_1 X Z (@category_theory.category_struct.comp.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D ğ’Ÿ) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F Y) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F Z) f g)) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’) X Y Z (@category_theory.functor.preimage.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F _inst_1 X Y f) (@category_theory.functor.preimage.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F _inst_1 Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type ?l_1} [ğ’ : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [ğ’Ÿ : category_theory.category.{?l_4 ?l_3} D] {F : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ} [_inst_1 : @category_theory.full.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F] [_inst_2 : @category_theory.faithful.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F] {X Y : C} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’)) X Y) (@category_theory.functor.preimage.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F _inst_1 X Y (@category_theory.functor.map.{?l_2 ?l_4 ?l_1 ?l_3} C ğ’ D ğ’Ÿ F X Y f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X_1
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚}))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y))
    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y)
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1
          Y
          f)
       (Î»
        (f :
          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                  category_theory.types.{vâ‚‚})
               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                     X)))
            Y),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
            (@opposite.unop.{uâ‚‚+1} D
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            Y
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  Y)
               f)))
    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          X_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          Y)
       (Î»
        (f :
          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                  category_theory.types.{vâ‚‚})
               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                     X)))
            X_1),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
            (@opposite.unop.{uâ‚‚+1} D
               (@opposite.op.{uâ‚‚+1} D
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            X_1
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  X_1)
               f))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          X_1
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X_1
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
       X_1 â†’
     @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       X
       Y)
    (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
          X_1)
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
          Y)
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          X
          Y)
       (Î»
        (f :
          @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
            Y),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  Y)
               f))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
          X_1
          Y
          f))
    (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
          X_1)
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          X
          X_1)
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          X
          Y)
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D X))
          X_1
          Y
          f)
       (Î»
        (f :
          @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
            X_1),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X X_1
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  X_1)
               f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52      rw â†h.counit_naturality,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) X x), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) x)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) x) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X x f)) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h) x)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) x) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h) X) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X X_1 Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X_1
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
       X_1 â†’
     @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       X
       Y)
    (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
          X_1)
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
          Y)
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          X
          Y)
       (Î»
        (f :
          @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
            Y),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     Y)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  Y)
               f))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
          X_1
          Y
          f))
    (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
          X_1)
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          X
          X_1)
       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          X
          Y)
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D X))
          X_1
          Y
          f)
       (Î»
        (f :
          @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
            X_1),
          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X X_1
            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
               (equiv.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                     X_1)
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                  X_1)
               f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X x : D,
x_1 :
  @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
    (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
       (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@opposite.op.{uâ‚‚+1} D
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
             X)))
    x
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
       x)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          x)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X x
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                x
                (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                   (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                      (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)))
                x_1)))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
          x))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53      simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X x : D,
x_1 :
  @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
    (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
       (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@opposite.op.{uâ‚‚+1} D
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
             X)))
    x
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
       x)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          x)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X x
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                x
                (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                   (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L R)
                      (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)))
                x_1)))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
          x))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    hom_inv_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X : D
âŠ¢ @eq.{(max uâ‚‚ vâ‚‚)+1}
    (@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                category_theory.types.{vâ‚‚})))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))))
    ((Î»
      (_x _x_1 _x_2 : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
      (Î± :
        @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.has_hom.mk.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (Î»
              (F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}),
                @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} F G))
          _x
          _x_1)
      (Î² :
        @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.has_hom.mk.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (Î»
              (F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}),
                @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} F G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} _x _x_1
          _x_2
          Î±
          Î²)
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       (@category_theory.functor.map.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X))
          (@category_theory.has_hom.hom.op.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                X)))
       (@category_theory.nat_trans.mk.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          (Î» (Y : D)
           (f :
             @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
               (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
                  (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                  (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                     category_theory.types.{vâ‚‚})
                  (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  (@opposite.op.{uâ‚‚+1} D
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                        X)))
               Y),
             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
               (@opposite.unop.{uâ‚‚+1} D
                  (@opposite.op.{uâ‚‚+1} D
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        X)))
               Y
               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                  (equiv.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                        Y)
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                        Y)
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     Y)
                  f))
          (Î» (X_1 Y : D)
           (f :
             @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               X_1
               Y),
             @id.{0}
               (âˆ€ (X : D) â¦ƒX_1 Y : Dâ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                    X_1
                    Y),
                  @eq.{vâ‚‚+1}
                    (@category_theory.has_hom.hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}))
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          Y))
                    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          category_theory.types.{vâ‚‚})
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          Y)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          Y)
                       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1
                          Y
                          f)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                            category_theory.types.{vâ‚‚}
                            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                               (opposite.{uâ‚‚+1} D)
                               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                                        R
                                        L)
                                     X)))
                            Y),
                          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                            (@opposite.unop.{uâ‚‚+1} D
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                     X)))
                            Y
                            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                               (equiv.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                  Y)
                               f)))
                    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          category_theory.types.{vâ‚‚})
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          Y)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                            category_theory.types.{vâ‚‚}
                            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                               (opposite.{uâ‚‚+1} D)
                               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                                        R
                                        L)
                                     X)))
                            X_1),
                          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                            (@opposite.unop.{uâ‚‚+1} D
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                     X)))
                            X_1
                            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                               (equiv.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                  X_1)
                               f))
                       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          X_1
                          Y
                          f)))
               (Î» (X : D) â¦ƒX_1 Y : Dâ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{vâ‚‚+1}
                       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                          X_1 â†’
                        @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          X
                          Y)
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             Y)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                               Y),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     Y)
                                  f))
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D X))
                             X_1
                             Y
                             f)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                               X_1),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X X_1
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     X_1)
                                  f))))
                    (@eq.{vâ‚‚+1}
                       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                          X_1 â†’
                        @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          X
                          Y)
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             Y)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             X
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             Y
                             (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D X))
                             X_1
                             Y
                             f)
                          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             X
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1
                             (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1 â†’
                              @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   Y)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   Y)
                                (Î»
                                 (f :
                                   @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     Y),
                                   @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
                                     (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1))
                                        (max (vâ‚‚+1) (vâ‚+1))}
                                        (equiv.{vâ‚‚+1 vâ‚+1}
                                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                        (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                        (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           Y)
                                        f))
                                (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚}
                                   (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                      (opposite.{uâ‚‚+1} D)
                                      (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@opposite.op.{uâ‚‚+1} D
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                                   X_1
                                   Y
                                   f))
                             (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   X_1)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   Y)
                                (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚}
                                   (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                      (opposite.{uâ‚‚+1} D)
                                      (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      â€¦)
                                   X_1
                                   Y
                                   f)
                                â€¦))
                          â€¦)
                       â€¦)
                    â€¦)
               X
               X_1
               Y
               f)))
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X : D
âŠ¢ @eq.{(max uâ‚‚ vâ‚‚)+1}
    (@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                category_theory.types.{vâ‚‚})))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))))
    ((Î»
      (_x _x_1 _x_2 : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
      (Î± :
        @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.has_hom.mk.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (Î»
              (F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}),
                @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} F G))
          _x
          _x_1)
      (Î² :
        @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.has_hom.mk.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (Î»
              (F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}),
                @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} F G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} _x _x_1
          _x_2
          Î±
          Î²)
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       (@category_theory.functor.map.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X))
          (@category_theory.has_hom.hom.op.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                X)))
       (@category_theory.nat_trans.mk.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          (Î» (Y : D)
           (f :
             @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
               (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
                  (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                  (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                     category_theory.types.{vâ‚‚})
                  (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  (@opposite.op.{uâ‚‚+1} D
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                        X)))
               Y),
             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
               (@opposite.unop.{uâ‚‚+1} D
                  (@opposite.op.{uâ‚‚+1} D
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        X)))
               Y
               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                  (equiv.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                        Y)
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                        Y)
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                     Y)
                  f))
          (Î» (X_1 Y : D)
           (f :
             @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               X_1
               Y),
             @id.{0}
               (âˆ€ (X : D) â¦ƒX_1 Y : Dâ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                    X_1
                    Y),
                  @eq.{vâ‚‚+1}
                    (@category_theory.has_hom.hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}))
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          Y))
                    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          category_theory.types.{vâ‚‚})
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          Y)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          Y)
                       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1
                          Y
                          f)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                            category_theory.types.{vâ‚‚}
                            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                               (opposite.{uâ‚‚+1} D)
                               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                                        R
                                        L)
                                     X)))
                            Y),
                          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                            (@opposite.unop.{uâ‚‚+1} D
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                     X)))
                            Y
                            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                               (equiv.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     Y)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                  Y)
                               f)))
                    (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                       (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          category_theory.types.{vâ‚‚})
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R
                                      L)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          X_1)
                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          Y)
                       (Î»
                        (f :
                          @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                            category_theory.types.{vâ‚‚}
                            (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                               (opposite.{uâ‚‚+1} D)
                               (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                  category_theory.types.{vâ‚‚})
                               (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                                        R
                                        L)
                                     X)))
                            X_1),
                          @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                            (@opposite.unop.{uâ‚‚+1} D
                               (@opposite.op.{uâ‚‚+1} D
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                     X)))
                            X_1
                            (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                               (equiv.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                               (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     X_1)
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                               (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                  X_1)
                               f))
                       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                          category_theory.types.{vâ‚‚}
                          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                             (opposite.{uâ‚‚+1} D)
                             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚})
                             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             (@opposite.op.{uâ‚‚+1} D
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   X)))
                          X_1
                          Y
                          f)))
               (Î» (X : D) â¦ƒX_1 Y : Dâ¦„
                (f :
                  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                    X_1
                    Y),
                  @eq.mpr.{0}
                    (@eq.{vâ‚‚+1}
                       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                          X_1 â†’
                        @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          X
                          Y)
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             Y)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                               Y),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     Y)
                                  f))
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D X))
                             X_1
                             Y
                             f)
                          (Î»
                           (f :
                             @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                               X_1),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X X_1
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     X_1)
                                  f))))
                    (@eq.{vâ‚‚+1}
                       (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                          X_1 â†’
                        @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                          X
                          Y)
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             Y)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             X
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             Y
                             (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                             X_1
                             Y
                             f))
                       (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             X_1)
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D X))
                             X_1
                             Y
                             f)
                          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                             X
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1
                             (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ L
                                      R)
                                   (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1 â†’
                              @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   Y)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   Y)
                                (Î»
                                 (f :
                                   @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                     Y),
                                   @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
                                     (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1))
                                        (max (vâ‚‚+1) (vâ‚+1))}
                                        (equiv.{vâ‚‚+1 vâ‚+1}
                                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                        (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                              Y)
                                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                        (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           Y)
                                        f))
                                (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚}
                                   (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                      (opposite.{uâ‚‚+1} D)
                                      (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@opposite.op.{uâ‚‚+1} D
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                                   X_1
                                   Y
                                   f))
                             (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   X_1)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   X_1)
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   Y)
                                (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚}
                                   (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                      (opposite.{uâ‚‚+1} D)
                                      (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                         category_theory.types.{vâ‚‚})
                                      (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      â€¦)
                                   X_1
                                   Y
                                   f)
                                â€¦))
                          â€¦)
                       â€¦)
                    â€¦)
               X
               X_1
               Y
               f)))
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X x : D,
x_1 :
  @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
    (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
       (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@opposite.op.{uâ‚‚+1} D
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             X)))
    x
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       x)
    (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
          (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
          (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@opposite.op.{uâ‚‚+1} D
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)))
       ((Î»
         (_x _x_1 _x_2 :
           @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
         (Î± :
           @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.has_hom.mk.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                (Î»
                 (F G :
                   @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}),
                   @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} F
                     G))
             _x
             _x_1)
         (Î² :
           @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.has_hom.mk.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                (Î»
                 (F G :
                   @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}),
                   @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} F
                     G))
             _x_1
             _x_2),
           @category_theory.nat_trans.vcomp.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚} _x
             _x_1
             _x_2
             Î±
             Î²)
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)))
          (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          (@category_theory.functor.map.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
             (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
             (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X))
             (@opposite.op.{uâ‚‚+1} D
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X))
             (@category_theory.has_hom.hom.op.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   X)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)
                (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                   X)))
          (@category_theory.nat_trans.mk.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                   category_theory.types.{vâ‚‚})
                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@opposite.op.{uâ‚‚+1} D
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                      X)))
             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                   category_theory.types.{vâ‚‚})
                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@opposite.op.{uâ‚‚+1} D
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      X)))
             (Î» (Y : D)
              (f :
                @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
                  (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                     (opposite.{uâ‚‚+1} D)
                     (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
                     (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                        category_theory.types.{vâ‚‚})
                     (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     (@opposite.op.{uâ‚‚+1} D
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                           X)))
                  Y),
                @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                  (@opposite.unop.{uâ‚‚+1} D
                     (@opposite.op.{uâ‚‚+1} D
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X)))
                  Y
                  (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                     (equiv.{vâ‚‚+1 vâ‚+1}
                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                           Y)
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                     (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                           Y)
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                        Y)
                     f))
             (Î» (X_1 Y : D)
              (f :
                @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  X_1
                  Y),
                @id.{0}
                  (âˆ€ (X : D) â¦ƒX_1 Y : Dâ¦„
                   (f :
                     @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                       X_1
                       Y),
                     @eq.{vâ‚‚+1}
                       (@category_theory.has_hom.hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          (@category_theory.category_struct.to_has_hom.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                             (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}))
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             Y))
                       (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                             category_theory.types.{vâ‚‚})
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             Y)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             Y)
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             X_1
                             Y
                             f)
                          (Î»
                           (f :
                             @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                               category_theory.types.{vâ‚‚}
                               (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                  (opposite.{uâ‚‚+1} D)
                                  (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                  (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                     category_theory.types.{vâ‚‚})
                                  (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                     category_theory.types.{vâ‚‚})
                                  (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                  (@opposite.op.{uâ‚‚+1} D
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                        (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                           ğ’Ÿ
                                           R
                                           L)
                                        X)))
                               Y),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                               (@opposite.unop.{uâ‚‚+1} D
                                  (@opposite.op.{uâ‚‚+1} D
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                        X)))
                               Y
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     Y)
                                  f)))
                       (@category_theory.category_struct.comp.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                          (@category_theory.category.to_category_struct.{vâ‚‚ vâ‚‚+1} (Type vâ‚‚)
                             category_theory.types.{vâ‚‚})
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         R
                                         L)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             X_1)
                          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             Y)
                          (Î»
                           (f :
                             @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                               category_theory.types.{vâ‚‚}
                               (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                  (opposite.{uâ‚‚+1} D)
                                  (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                  (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                     category_theory.types.{vâ‚‚})
                                  (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                     category_theory.types.{vâ‚‚})
                                  (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                  (@opposite.op.{uâ‚‚+1} D
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                        (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                           ğ’Ÿ
                                           R
                                           L)
                                        X)))
                               X_1),
                             @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1
                               (@opposite.unop.{uâ‚‚+1} D
                                  (@opposite.op.{uâ‚‚+1} D
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                        X)))
                               X_1
                               (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                  (equiv.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        X_1)
                                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                  (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                     X_1)
                                  f))
                          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                             category_theory.types.{vâ‚‚}
                             (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                (opposite.{uâ‚‚+1} D)
                                (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                   category_theory.types.{vâ‚‚})
                                (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                (@opposite.op.{uâ‚‚+1} D
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)))
                             X_1
                             Y
                             f)))
                  (Î» (X : D) â¦ƒX_1 Y : Dâ¦„
                   (f :
                     @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                       X_1
                       Y),
                     @eq.mpr.{0}
                       (@eq.{vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1 â†’
                           @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                Y)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (Î»
                              (f :
                                @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                  Y),
                                @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X Y
                                  (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                     (equiv.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                           Y)
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                     (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                           Y)
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R Y)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        Y)
                                     f))
                             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}
                                (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                   (opposite.{uâ‚‚+1} D)
                                   (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@opposite.op.{uâ‚‚+1} D
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                                X_1
                                Y
                                f))
                          (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}
                                (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                   (opposite.{uâ‚‚+1} D)
                                   (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@opposite.op.{uâ‚‚+1} D X))
                                X_1
                                Y
                                f)
                             (Î»
                              (f :
                                @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                  X_1),
                                @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X X_1
                                  (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                     (equiv.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                           X_1)
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                     (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                           X_1)
                                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X_1)))
                                     (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                        X_1)
                                     f))))
                       (@eq.{vâ‚‚+1}
                          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                             X_1 â†’
                           @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             X
                             Y)
                          (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                Y)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                Y
                                (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         L
                                         R)
                                      (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}
                                (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                   (opposite.{uâ‚‚+1} D)
                                   (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@opposite.op.{uâ‚‚+1} D
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                                X_1
                                Y
                                f))
                          (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                X_1)
                             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                X
                                Y)
                             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                category_theory.types.{vâ‚‚}
                                (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                   (opposite.{uâ‚‚+1} D)
                                   (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚})
                                   (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@opposite.op.{uâ‚‚+1} D X))
                                X_1
                                Y
                                f)
                             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                X
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                X_1
                                (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         L
                                         R)
                                      (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                   X_1 â†’
                                 @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   X
                                   Y)
                                (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                      X_1)
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                      Y)
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      X
                                      Y)
                                   (Î»
                                    (f :
                                      @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                        Y),
                                      @category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X
                                        Y
                                        (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1))
                                           (max (vâ‚‚+1) (vâ‚+1))}
                                           (equiv.{vâ‚‚+1 vâ‚+1}
                                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                       X))
                                                 Y)
                                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                    Y)))
                                           (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                       X))
                                                 Y)
                                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R
                                                    Y)))
                                           (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                              R
                                              h
                                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                                              Y)
                                           f))
                                   (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚}
                                      (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))}
                                         (opposite.{uâ‚‚+1} D)
                                         (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                         (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                            category_theory.types.{vâ‚‚})
                                         (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                            category_theory.types.{vâ‚‚})
                                         (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                         (@opposite.op.{uâ‚‚+1} D
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))))
                                      X_1
                                      Y
                                      f))
                                (@function.comp.{vâ‚‚+1 vâ‚‚+1 vâ‚‚+1}
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                                      X_1)
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      X
                                      X_1)
                                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                      X
                                      Y)
                                   (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚)
                                      category_theory.types.{vâ‚‚}
                                      â€¦
                                      X_1
                                      Y
                                      f)
                                   â€¦))
                             â€¦)
                          â€¦)
                       â€¦)
                  X
                  X_1
                  Y
                  f)))
       x
       x_1)
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X x : D,
x_1 :
  @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
    (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
       (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@opposite.op.{uâ‚‚+1} D
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             X)))
    x
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       X
       x)
    (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X x
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                x)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                x)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
             x)
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
             X
             x
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                X)
             x_1)))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58      apply R.injectivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X x : D,
x_1 :
  @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
    (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
       (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@opposite.op.{uâ‚‚+1} D
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             X)))
    x
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       X
       x)
    (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X x
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                x)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                x)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
             x)
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
             X
             x
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                X)
             x_1)))
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X x : D,
x_1 :
  @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
    (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
       (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@opposite.op.{uâ‚‚+1} D
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             X)))
    x
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x))
    (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X x
       (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X x
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                   x)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                   x)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                x)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                X
                x
                (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                   X)
                x_1))))
    (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X x x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59      simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
L : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
R : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
h : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R,
_inst_1 : @category_theory.full.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
_inst_2 : @category_theory.faithful.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R,
X x : D,
x_1 :
  @category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚}
    (@category_theory.functor.obj.{vâ‚‚ (max uâ‚‚ vâ‚‚) uâ‚‚ (max vâ‚‚ uâ‚‚ (vâ‚‚+1))} (opposite.{uâ‚‚+1} D)
       (@category_theory.category.opposite.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚+1} D ğ’Ÿ (Type vâ‚‚) category_theory.types.{vâ‚‚})
       (@category_theory.coyoneda.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@opposite.op.{uâ‚‚+1} D
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             X)))
    x
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x))
    (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X x
       (@category_theory.functor.preimage.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R _inst_1 X x
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                   x)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                   x)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R x)))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X)
                x)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X))
                X
                x
                (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ R L)
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ L R h)
                   X)
                x_1))))
    (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ R X x x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  -- TODO also prove the converses?</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  -- def L_full_of_unit_is_iso [is_iso (adjunction.unit h)] : full L := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  -- def L_faithful_of_unit_is_iso [is_iso (adjunction.unit h)] : faithful L := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  -- def R_full_of_counit_is_iso [is_iso (adjunction.counit h)] : full R := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  -- def R_faithful_of_counit_is_iso [is_iso (adjunction.counit h)] : faithful R := sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  -- TODO also do the statements from Riehl 4.5.13 for full and faithful separately?</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  end category_theory</code></pre>
</body>