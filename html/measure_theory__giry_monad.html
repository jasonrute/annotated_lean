<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johannes Hölzl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import measure_theory.integration</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  # The Giry monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  Let X be a measurable space. The collection of all measures on X again</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  forms a measurable space. This construction forms a monad on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  measurable spaces and measurable functions, called the Giry monad.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  Note that most sources use the term &quot;Giry monad&quot; for the restriction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  to *probability* measures. Here we include all measures on X.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  See also `measure_theory/category/Meas.lean`, containing an upgrade of the type-level</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  monad to an honest monad of the functor `Measure : Meas ⥤ Meas`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  ## References</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  * &lt;https://ncatlab.org/nlab/show/Giry+monad&gt;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  ## Tags</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  giry monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  open_locale classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  open classical set lattice filter</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  variables {α : Type*} {β : Type*} {γ : Type*} {δ : Type*} {ε : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  namespace measure_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  namespace measure</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  variables [measurable_space α] [measurable_space β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measurable_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measurable_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  /-- Measurability structure on `measure`: Measures are measurable w.r.t. all projections -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  instance : measurable_space (measure α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measurable_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  ⨆ (s : set α) (hs : is_measurable s), (borel ennreal).comap (λμ, μ s)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='borel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measurable_space.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 30}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 296, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_1} [_inst_1 : lattice.has_Sup.{u_1} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_1} [_inst_1 : lattice.has_Sup.{u_1} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_1 : topological_space.{u} α], measurable_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type}, (α → β) → measurable_space.{0} β → measurable_space.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Indexed supremum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Indexed supremum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The extended nonnegative real numbers. This is usually denoted [0, ∞],
 and is relevant as the codomain of a measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The reverse image of a measure space under a function. `comap f m` contains the sets `s : set α`
 such that `s` is the `f`-preimage of a measurable set in `β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  lemma measurable_coe {s : set α} (hs : is_measurable s) : measurable (λμ : measure α, μ s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  measurable_space.comap_le_iff_le_map.1 $ le_supr_of_le s $ le_supr_of_le hs $ le_refl _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measurable_space.comap_le_iff_le_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.le_supr_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.le_supr_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 251, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 251, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type} {m : measurable_space.{u_1} α} {m&#x27; : measurable_space.{0} β} {f : α → β}, iff (@has_le.le.{u_1} (measurable_space.{u_1} α) (@preorder.to_has_le.{u_1} (measurable_space.{u_1} α) (@partial_order.to_preorder.{u_1} (measurable_space.{u_1} α) (@measurable_space.partial_order.{u_1} α))) (@measurable_space.comap.{u_1 0} α β f m&#x27;) m) (@has_le.le.{0} (measurable_space.{0} β) (@preorder.to_has_le.{0} (measurable_space.{0} β) (@partial_order.to_preorder.{0} (measurable_space.{0} β) (@measurable_space.partial_order.{0} β))) m&#x27; (@measurable_space.map.{u_1 0} α β f m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {ι : Type u_1} [_inst_1 : lattice.complete_lattice.{u_1} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (s i) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (@lattice.supr.{u_1 (max (u_1+1) 1)} α ι (@lattice.complete_lattice.to_has_Sup.{u_1} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {ι : Prop} [_inst_1 : lattice.complete_lattice.{u_1} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (s i) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (@lattice.supr.{u_1 0} α ι (@lattice.complete_lattice.to_has_Sup.{u_1} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : preorder.{u_1} α] (a : α), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  lemma measurable_of_measurable_coe (f : β → measure α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    (h : ∀(s : set α) (hs : is_measurable s), measurable (λb, f b s)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52    measurable f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  supr_le $ assume s, supr_le $ assume hs, measurable_space.comap_le_iff_le_map.2 $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.supr_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.supr_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measurable_space.comap_le_iff_le_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 254, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 254, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {ι : Type u_1} [_inst_1 : lattice.complete_lattice.{u_1} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) (s i) a) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) (@lattice.supr.{u_1 (max (u_1+1) 1)} α ι (@lattice.complete_lattice.to_has_Sup.{u_1} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {ι : Prop} [_inst_1 : lattice.complete_lattice.{u_1} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) (s i) a) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) (@lattice.supr.{u_1 0} α ι (@lattice.complete_lattice.to_has_Sup.{u_1} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type} {m : measurable_space.{u_1} α} {m&#x27; : measurable_space.{0} β} {f : α → β}, iff (@has_le.le.{u_1} (measurable_space.{u_1} α) (@preorder.to_has_le.{u_1} (measurable_space.{u_1} α) (@partial_order.to_preorder.{u_1} (measurable_space.{u_1} α) (@measurable_space.partial_order.{u_1} α))) (@measurable_space.comap.{u_1 0} α β f m&#x27;) m) (@has_le.le.{0} (measurable_space.{0} β) (@preorder.to_has_le.{0} (measurable_space.{0} β) (@partial_order.to_preorder.{0} (measurable_space.{0} β) (@measurable_space.partial_order.{0} β))) m&#x27; (@measurable_space.map.{u_1 0} α β f m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    by rw [measurable_space.map_comp]; exact h s hs</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_space.map_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 291, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} {γ : Type} {m : measurable_space.{u_2} α} {f : α → β} {g : β → γ}, @eq.{1} (measurable_space.{0} γ) (@measurable_space.map.{u_1 0} β γ g (@measurable_space.map.{u_2 u_1} α β f m)) (@measurable_space.map.{u_2 0} α γ (@function.comp.{u_2+1 u_1+1 1} α β γ g f) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{u_1} α), @is_measurable.{u_1} α _inst_1 s → @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) (λ (b : β), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) (f b) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : β → @measure_theory.measure.{u_1} α _inst_1,
h :
  ∀ (s : set.{u_1} α),
    @is_measurable.{u_1} α _inst_1 s →
    @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space)
      (λ (b : β),
         @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
           (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
           (f b)
           s),
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @has_le.le.{0} (measurable_space.{0} ennreal)
    (@preorder.to_has_le.{0} (measurable_space.{0} ennreal)
       (@partial_order.to_preorder.{0} (measurable_space.{0} ennreal) (@measurable_space.partial_order.{0} ennreal)))
    (@borel.{0} ennreal ennreal.topological_space)
    (@measurable_space.map.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            s)
       (@measurable_space.map.{u_2 u_1} β (@measure_theory.measure.{u_1} α _inst_1) f _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : β → @measure_theory.measure.{u_1} α _inst_1,
h :
  ∀ (s : set.{u_1} α),
    @is_measurable.{u_1} α _inst_1 s →
    @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space)
      (λ (b : β),
         @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
           (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
           (f b)
           s),
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @has_le.le.{0} (measurable_space.{0} ennreal)
    (@preorder.to_has_le.{0} (measurable_space.{0} ennreal)
       (@partial_order.to_preorder.{0} (measurable_space.{0} ennreal) (@measurable_space.partial_order.{0} ennreal)))
    (@borel.{0} ennreal ennreal.topological_space)
    (@measurable_space.map.{u_2 0} β ennreal
       (@function.comp.{u_2+1 u_1+1 1} β (@measure_theory.measure.{u_1} α _inst_1) ennreal
          (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
             @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
               μ
               s)
          f)
       _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : β → @measure_theory.measure.{u_1} α _inst_1,
h :
  ∀ (s : set.{u_1} α),
    @is_measurable.{u_1} α _inst_1 s →
    @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space)
      (λ (b : β),
         @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
           (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
           (f b)
           s),
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @has_le.le.{0} (measurable_space.{0} ennreal)
    (@preorder.to_has_le.{0} (measurable_space.{0} ennreal)
       (@partial_order.to_preorder.{0} (measurable_space.{0} ennreal) (@measurable_space.partial_order.{0} ennreal)))
    (@borel.{0} ennreal ennreal.topological_space)
    (@measurable_space.map.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            s)
       (@measurable_space.map.{u_2 u_1} β (@measure_theory.measure.{u_1} α _inst_1) f _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : β → @measure_theory.measure.{u_1} α _inst_1,
h :
  ∀ (s : set.{u_1} α),
    @is_measurable.{u_1} α _inst_1 s →
    @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space)
      (λ (b : β),
         @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
           (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
           (f b)
           s),
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @has_le.le.{0} (measurable_space.{0} ennreal)
    (@preorder.to_has_le.{0} (measurable_space.{0} ennreal)
       (@partial_order.to_preorder.{0} (measurable_space.{0} ennreal) (@measurable_space.partial_order.{0} ennreal)))
    (@borel.{0} ennreal ennreal.topological_space)
    (@measurable_space.map.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            s)
       (@measurable_space.map.{u_2 u_1} β (@measure_theory.measure.{u_1} α _inst_1) f _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  lemma measurable_map (f : α → β) (hf : measurable f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    measurable (λμ : measure α, μ.map f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 593, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], (α → β) → @measure_theory.measure.{u_1} α _inst_1 → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  measurable_of_measurable_coe _ $ assume s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.measurable_of_measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 50, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β] (f : β → @measure_theory.measure.{u_1} α _inst_1), (∀ (s : set.{u_1} α), @is_measurable.{u_1} α _inst_1 s → @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) (λ (b : β), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) (f b) s)) → @measurable.{u_2 u_1} β (@measure_theory.measure.{u_1} α _inst_1) _inst_2 (@measure_theory.measure.measurable_space.{u_1} α _inst_1) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    suffices measurable (λ (μ : measure α), μ (f ⁻¹&#x27; s)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60      by simpa [map_apply, hs, hf],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    measurable_coe (hf.preimage hs)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {s : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s → @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  lemma measurable_dirac :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    measurable (measure.dirac : α → measure α) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  measurable_of_measurable_coe _ $ assume s hs,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67      simp [hs, lattice.supr_eq_if],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68      exact measurable_const.if hs measurable_const</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='measurable.if'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 376, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u_1} {β : Type} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{0} β] {p : α → Prop} {h : @decidable_pred.{u_1+1} α p} {f g : α → β}, @is_measurable.{u_1} α _inst_1 (@set_of.{u_1} α (λ (a : α), p a)) → @measurable.{u_1 0} α β _inst_1 _inst_2 f → @measurable.{u_1 0} α β _inst_1 _inst_2 g → @measurable.{u_1 0} α β _inst_1 _inst_2 (λ (a : α), @ite.{1} (p a) (h a) β (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : measurable_space.{0} α] [_inst_2 : measurable_space.{u_1} β] {a : α}, @measurable.{u_1 0} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space)
    (λ (b : α),
       @ite.{1} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s)
         (@decidable_of_decidable_of_iff (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s)
            (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s)
            (@set.decidable_mem.{u_1} α s (λ (a : α), classical.prop_decidable (s a)) b)
            (iff.refl (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s)))
         ennreal
         (@has_one.one.{0} ennreal
            (@zero_ne_one_class.to_has_one.{0} ennreal
               (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (@has_zero.zero.{0} ennreal
            (@zero_ne_one_class.to_has_zero.{0} ennreal
               (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space)
    (λ (b : α),
       @ite.{1} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s)
         (@decidable_of_decidable_of_iff (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s)
            (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s)
            (@set.decidable_mem.{u_1} α s (λ (a : α), classical.prop_decidable (s a)) b)
            (iff.refl (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s)))
         ennreal
         (@has_one.one.{0} ennreal
            (@zero_ne_one_class.to_has_one.{0} ennreal
               (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (@has_zero.zero.{0} ennreal
            (@zero_ne_one_class.to_has_zero.{0} ennreal
               (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  lemma measurable_integral (f : α → ennreal) (hf : measurable f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The extended nonnegative real numbers. This is usually denoted [0, ∞],
 and is relevant as the codomain of a measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    measurable (λμ : measure α, μ.integral f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  suffices measurable (λμ : measure α,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    (⨆n:ℕ, @simple_func.integral α { μ := μ } (simple_func.eapprox f n)) : _ → ennreal),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.simple_func.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='measure_theory.simple_func.eapprox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 409, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], @measure_theory.simple_func.{u_1 0} α (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) ennreal → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], (α → ennreal) → nat → @measure_theory.simple_func.{u_1 0} α _inst_1 ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Integral of a simple function whose codomain is `ennreal`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='The extended nonnegative real numbers. This is usually denoted [0, ∞],
 and is relevant as the codomain of a measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    convert this,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    funext μ,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    exact @lintegral_eq_supr_eapprox_integral α {μ := μ} f hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='measure_theory.lintegral_eq_supr_eapprox_integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 815, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α] {f : α → ennreal}, @measurable.{u_1 0} α ennreal (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) f → @eq.{1} ennreal (@measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), f a)) (@lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @measure_theory.simple_func.integral.{u_1} α _inst_1 (@measure_theory.simple_func.eapprox.{u_1} α (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) f n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
       @lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@measure_theory.simple_func.eapprox.{u_1} α
                 (@measure_theory.measure_space.to_measurable_space.{u_1} α
                    (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
                 f
                 n))),
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @eq.{1} ennreal (@measure_theory.measure.integral.{u_1} α _inst_1 μ f)
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
               f
               n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  measurable.supr $ assume n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measurable.supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_2 : topological_space.{0} α] [_inst_3 : lattice.complete_linear_order.{0} α] [_inst_4 : @order_topology.{0} α _inst_2 (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α (@lattice.complete_linear_order.to_complete_lattice.{0} α _inst_3)))))] [_inst_5 : @topological_space.second_countable_topology.{0} α _inst_2] {β : Type u_1} [_inst_6 : measurable_space.{u_1} β] {ι : Type} [_inst_7 : encodable.{0} ι] {f : ι → β → α}, (∀ (i : ι), @measurable.{u_1 0} β α _inst_6 (@borel.{0} α _inst_2) (f i)) → @measurable.{u_1 0} β α _inst_6 (@borel.{0} α _inst_2) (λ (b : β), @lattice.supr.{0 1} α ι (@lattice.conditionally_complete_lattice.to_has_Sup.{0} α (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} α (@lattice.complete_linear_order.to_complete_lattice.{0} α _inst_3))) (λ (i : ι), f i b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
       @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
         (@measure_theory.simple_func.eapprox.{u_1} α
            (@measure_theory.measure_space.to_measurable_space.{u_1} α
               (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
            f
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      dunfold simple_func.integral,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1343, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dunfold_config {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `unfold`, but only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dunfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dunfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
       @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
         (@measure_theory.simple_func.eapprox.{u_1} α
            (@measure_theory.measure_space.to_measurable_space.{u_1} α
               (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
            f
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (@measure_theory.simple_func.range.{u_1 0} α ennreal
            (@measure_theory.measure_space.to_measurable_space.{u_1} α
               (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
               f
               n))
         (λ (x : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              x
              (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                 (@set.preimage.{u_1 0} α ennreal
                    (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                       (@measure_theory.simple_func.{u_1 0} α
                          (@measure_theory.measure_space.to_measurable_space.{u_1} α
                             (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
                          ennreal)
                       (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                          (@measure_theory.measure_space.to_measurable_space.{u_1} α
                             (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)))
                       (@measure_theory.simple_func.eapprox.{u_1} α
                          (@measure_theory.measure_space.to_measurable_space.{u_1} α
                             (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
                          f
                          n))
                    (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                       (@set.has_insert.{0} ennreal)
                       x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      refine measurable_finset_sum (simple_func.eapprox f n).range _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measurable_finset_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.simple_func.eapprox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 199, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : topological_space.{0} α] {ι : Type} [_inst_2 : add_comm_monoid.{0} α] [_inst_3 : @topological_add_monoid.{0} α _inst_1 (@add_comm_monoid.to_add_monoid.{0} α _inst_2)] [_inst_4 : @topological_space.second_countable_topology.{0} α _inst_1] [_inst_5 : measurable_space.{u_1} β] {f : ι → β → α} (s : finset.{0} ι), (∀ (i : ι), @measurable.{u_1 0} β α _inst_5 (@borel.{0} α _inst_1) (f i)) → @measurable.{u_1 0} β α _inst_5 (@borel.{0} α _inst_1) (λ (a : β), @finset.sum.{0 0} ι α _inst_2 s (λ (i : ι), f i a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], (α → ennreal) → nat → @measure_theory.simple_func.{u_1 0} α _inst_1 ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (@measure_theory.simple_func.range.{u_1 0} α ennreal
            (@measure_theory.measure_space.to_measurable_space.{u_1} α
               (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
               f
               n))
         (λ (x : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              x
              (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                 (@set.preimage.{u_1 0} α ennreal
                    (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                       (@measure_theory.simple_func.{u_1 0} α
                          (@measure_theory.measure_space.to_measurable_space.{u_1} α
                             (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
                          ennreal)
                       (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                          (@measure_theory.measure_space.to_measurable_space.{u_1} α
                             (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)))
                       (@measure_theory.simple_func.eapprox.{u_1} α
                          (@measure_theory.measure_space.to_measurable_space.{u_1} α
                             (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
                          f
                          n))
                    (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                       (@set.has_insert.{0} ennreal)
                       x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat
⊢ ∀ (i : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @has_mul.mul.{0} ennreal
           (@mul_zero_class.to_has_mul.{0} ennreal
              (@semiring.to_mul_zero_class.{0} ennreal
                 (@comm_semiring.to_semiring.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1))))
           i
           (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                    (@measure_theory.simple_func.{u_1 0} α
                       (@measure_theory.measure_space.to_measurable_space.{u_1} α
                          (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                       ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                       (@measure_theory.measure_space.to_measurable_space.{u_1} α
                          (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)))
                    (@measure_theory.simple_func.eapprox.{u_1} α
                       (@measure_theory.measure_space.to_measurable_space.{u_1} α
                          (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                       f
                       n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84      assume i,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat
⊢ ∀ (i : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @has_mul.mul.{0} ennreal
           (@mul_zero_class.to_has_mul.{0} ennreal
              (@semiring.to_mul_zero_class.{0} ennreal
                 (@comm_semiring.to_semiring.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1))))
           i
           (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                    (@measure_theory.simple_func.{u_1 0} α
                       (@measure_theory.measure_space.to_measurable_space.{u_1} α
                          (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                       ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                       (@measure_theory.measure_space.to_measurable_space.{u_1} α
                          (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)))
                    (@measure_theory.simple_func.eapprox.{u_1} α
                       (@measure_theory.measure_space.to_measurable_space.{u_1} α
                          (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                       f
                       n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat,
i : ennreal
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : @measure_theory.measure.{u_1} α _inst_1),
       @has_mul.mul.{0} ennreal
         (@mul_zero_class.to_has_mul.{0} ennreal
            (@semiring.to_mul_zero_class.{0} ennreal
               (@comm_semiring.to_semiring.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1))))
         i
         (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)
            (@set.preimage.{u_1 0} α ennreal
               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                  (@measure_theory.simple_func.{u_1 0} α
                     (@measure_theory.measure_space.to_measurable_space.{u_1} α
                        (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                     ennreal)
                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                     (@measure_theory.measure_space.to_measurable_space.{u_1} α
                        (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)))
                  (@measure_theory.simple_func.eapprox.{u_1} α
                     (@measure_theory.measure_space.to_measurable_space.{u_1} α
                        (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                     f
                     n))
               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                  i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85      refine ennreal.measurable.mul measurable_const _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='ennreal.measurable.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 477, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {f g : α → ennreal}, @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f → @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) g → @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) (λ (a : α), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : measurable_space.{0} α] [_inst_2 : measurable_space.{u_1} β] {a : α}, @measurable.{u_1 0} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat,
i : ennreal
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : @measure_theory.measure.{u_1} α _inst_1),
       @has_mul.mul.{0} ennreal
         (@mul_zero_class.to_has_mul.{0} ennreal
            (@semiring.to_mul_zero_class.{0} ennreal
               (@comm_semiring.to_semiring.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1))))
         i
         (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)
            (@set.preimage.{u_1 0} α ennreal
               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                  (@measure_theory.simple_func.{u_1 0} α
                     (@measure_theory.measure_space.to_measurable_space.{u_1} α
                        (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                     ennreal)
                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                     (@measure_theory.measure_space.to_measurable_space.{u_1} α
                        (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)))
                  (@measure_theory.simple_func.eapprox.{u_1} α
                     (@measure_theory.measure_space.to_measurable_space.{u_1} α
                        (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                     f
                     n))
               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                  i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat,
i : ennreal
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : @measure_theory.measure.{u_1} α _inst_1),
       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
               (@measure_theory.simple_func.{u_1 0} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                  ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                  f
                  n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86      exact measurable_coe ((simple_func.eapprox f n).preimage_measurable _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.measure.measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.simple_func.eapprox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {s : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s → @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], (α → ennreal) → nat → @measure_theory.simple_func.{u_1 0} α _inst_1 ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat,
i : ennreal
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : @measure_theory.measure.{u_1} α _inst_1),
       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
               (@measure_theory.simple_func.{u_1 0} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                  ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                  f
                  n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
n : nat,
i : ennreal
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : @measure_theory.measure.{u_1} α _inst_1),
       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
               (@measure_theory.simple_func.{u_1 0} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                  ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1 a)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1 a))
                  f
                  n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  /-- Monadic join on `measure` in the category of measurable spaces and measurable</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  functions. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  def join (m : measure (measure α)) : measure α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  measure.of_measurable</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.of_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (m : Π (s : set.{u_1} α), @is_measurable.{u_1} α _inst_1 s → ennreal), @eq.{1} ennreal (m (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α)) (@is_measurable.empty.{u_1} α _inst_1)) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) → (∀ {f : nat → set.{u_1} α} (h : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i)), @pairwise.{0} nat (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop (@disjoint.{u_1} (set.{u_1} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))) f) → @eq.{1} ennreal (m (@set.Union.{u_1 1} α nat (λ (i : nat), f i)) (@measure_theory.measure.of_measurable._proof_1.{u_1} α _inst_1 f h)) (@tsum.{0 0} ennreal nat (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : nat), m (f i) (h i)))) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93    (λs hs, m.integral (λμ, μ s))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    (by simp [integral])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : measurable_space.{?l_1} α], @measure_theory.measure.{?l_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))))
    (@has_zero.zero.{0} ennreal
       (@zero_ne_one_class.to_has_zero.{0} ennreal
          (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
             ennreal.canonically_ordered_comm_semiring_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
⊢ ∀ {f : nat → set.{u_1} α},
    (∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i)) →
    @pairwise.{0} nat
      (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
         (@disjoint.{u_1} (set.{u_1} α)
            (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
         f) →
    @eq.{1} ennreal
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
              (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
              μ
              (@set.Union.{u_1 1} α nat (λ (i : nat), f i))))
      (@tsum.{0 0} ennreal nat
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         ennreal.topological_space
         (λ (i : nat),
            @measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
              (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
              m
              (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                 @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
                   (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
                   μ
                   (f i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96      assume f hf h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
⊢ ∀ {f : nat → set.{u_1} α},
    (∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i)) →
    @pairwise.{0} nat
      (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
         (@disjoint.{u_1} (set.{u_1} α)
            (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
         f) →
    @eq.{1} ennreal
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
              (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
              μ
              (@set.Union.{u_1 1} α nat (λ (i : nat), f i))))
      (@tsum.{0 0} ennreal nat
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         ennreal.topological_space
         (λ (i : nat),
            @measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
              (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
              m
              (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                 @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
                   (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
                   μ
                   (f i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : nat → set.{u_1} α,
hf : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i),
h :
  @pairwise.{0} nat
    (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
       (@disjoint.{u_1} (set.{u_1} α)
          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
       f)
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            (@set.Union.{u_1 1} α nat (λ (i : nat), f i))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m
            (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
               @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
                 (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
                 μ
                 (f i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97      simp [measure_Union h hf],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.measure_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 328, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {μ : @measure_theory.measure.{u_1} α _inst_1} {β : Type} [_inst_2 : encodable.{0} β] {f : β → set.{u_1} α}, @pairwise.{0} β (@function.on_fun.{1 u_1+1 1} β (set.{u_1} α) Prop (@disjoint.{u_1} (set.{u_1} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))) f) → (∀ (i : β), @is_measurable.{u_1} α _inst_1 (f i)) → @eq.{1} ennreal (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ (@set.Union.{u_1 1} α β (λ (i : β), f i))) (@tsum.{0 0} ennreal β (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : β), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ (f i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@pairwise.{0} nat (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop (@disjoint.{u_1} (set.{u_1} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : nat → set.{u_1} α,
hf : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i),
h :
  @pairwise.{0} nat
    (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
       (@disjoint.{u_1} (set.{u_1} α)
          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
       f)
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            (@set.Union.{u_1 1} α nat (λ (i : nat), f i))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m
            (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
               @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
                 (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
                 μ
                 (f i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : nat → set.{u_1} α,
hf : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i),
h :
  @pairwise.{0} nat
    (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
       (@disjoint.{u_1} (set.{u_1} α)
          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
       f)
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @tsum.{0 0} ennreal nat
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            ennreal.topological_space
            (λ (i : nat),
               @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
                 (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
                 μ
                 (f i))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m
            (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
               @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
                 (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
                 μ
                 (f i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98      apply lintegral_tsum,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.lintegral_tsum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1229, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type} [_inst_1 : measure_theory.measure_space.{u_1} α] [_inst_2 : encodable.{0} β] {f : β → α → ennreal}, (∀ (i : β), @measurable.{u_1 0} α ennreal (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (f i)) → @eq.{1} ennreal (@measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), @tsum.{0 0} ennreal β (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : β), f i a))) (@tsum.{0 0} ennreal β (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : β), @measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), f i a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : nat → set.{u_1} α,
hf : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i),
h :
  @pairwise.{0} nat
    (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
       (@disjoint.{u_1} (set.{u_1} α)
          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
       f)
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @tsum.{0 0} ennreal nat
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            ennreal.topological_space
            (λ (i : nat),
               @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
                 (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
                 μ
                 (f i))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m
            (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
               @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
                 (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
                 μ
                 (f i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : nat → set.{u_1} α,
hf : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i),
h :
  @pairwise.{0} nat
    (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
       (@disjoint.{u_1} (set.{u_1} α)
          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
       f)
⊢ ∀ (i : nat),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m))
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
           (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
           a
           (f i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99      assume i, exact measurable_coe (hf i)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='measure_theory.measure.measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {s : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s → @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : nat → set.{u_1} α,
hf : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i),
h :
  @pairwise.{0} nat
    (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
       (@disjoint.{u_1} (set.{u_1} α)
          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
       f)
⊢ ∀ (i : nat),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m))
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
           (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
           a
           (f i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : nat → set.{u_1} α,
hf : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i),
h :
  @pairwise.{0} nat
    (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
       (@disjoint.{u_1} (set.{u_1} α)
          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
       f),
i : nat
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : @measure_theory.measure.{u_1} α _inst_1),
       @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
         a
         (f i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : nat → set.{u_1} α,
hf : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i),
h :
  @pairwise.{0} nat
    (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop
       (@disjoint.{u_1} (set.{u_1} α)
          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))
       f),
i : nat
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : @measure_theory.measure.{u_1} α _inst_1),
       @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
         a
         (f i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  @[simp] lemma join_apply {m : measure (measure α)} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    ∀{s : set α}, is_measurable s → join m s = m.integral (λμ, μ s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  measure.of_measurable_apply</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.of_measurable_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {m : Π (s : set.{u_1} α), @is_measurable.{u_1} α _inst_1 s → ennreal} {m0 : @eq.{1} ennreal (m (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α)) (@is_measurable.empty.{u_1} α _inst_1)) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))} {mU : ∀ {f : nat → set.{u_1} α} (h : ∀ (i : nat), @is_measurable.{u_1} α _inst_1 (f i)), @pairwise.{0} nat (@function.on_fun.{1 u_1+1 1} nat (set.{u_1} α) Prop (@disjoint.{u_1} (set.{u_1} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))) f) → @eq.{1} ennreal (m (@set.Union.{u_1 1} α nat (λ (i : nat), f i)) (@is_measurable.Union.{u_1 0} α nat _inst_1 encodable.nat (λ (i : nat), f i) h)) (@tsum.{0 0} ennreal nat (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : nat), m (f i) (h i)))} (s : set.{u_1} α) (hs : @is_measurable.{u_1} α _inst_1 s), @eq.{1} ennreal (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) (@measure_theory.measure.of_measurable.{u_1} α _inst_1 m m0 mU) s) (m s hs)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  lemma measurable_join : measurable (join : measure (measure α) → measure α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  measurable_of_measurable_coe _ $ assume s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.measurable_of_measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 50, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_1} β] (f : β → @measure_theory.measure.{u_1} α _inst_1), (∀ (s : set.{u_1} α), @is_measurable.{u_1} α _inst_1 s → @measurable.{u_1 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) (λ (b : β), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) (f b) s)) → @measurable.{u_1 u_1} β (@measure_theory.measure.{u_1} α _inst_1) _inst_2 (@measure_theory.measure.measurable_space.{u_1} α _inst_1) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    by simp [hs]; exact measurable_integral _ (measurable_coe hs)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.measure.measurable_integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure.measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 71, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (f : α → ennreal), @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f → @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {s : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s → @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @measurable.{u_1 0}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    ennreal
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ
     (b :
       @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)),
       @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
         (@measure_theory.measure.join.{u_1} α _inst_1 b)
         s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @measurable.{u_1 0}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    ennreal
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ
     (b :
       @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)),
       @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
         (@measure_theory.measure.join.{u_1} α _inst_1 b)
         s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  lemma integral_join {m : measure (measure α)} {f : α → ennreal} (hf : measurable f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='The extended nonnegative real numbers. This is usually denoted [0, ∞],
 and is relevant as the codomain of a measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    integral (join m) f = integral m (λμ, integral μ f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m) f)
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    transitivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m) f)
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m) f)
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    apply lintegral_eq_supr_eapprox_integral,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.lintegral_eq_supr_eapprox_integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 815, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α] {f : α → ennreal}, @measurable.{u_1 0} α ennreal (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) f → @eq.{1} ennreal (@measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), f a)) (@lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @measure_theory.simple_func.integral.{u_1} α _inst_1 (@measure_theory.simple_func.eapprox.{u_1} α (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) f n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m) f)
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @measurable.{u_1 0} α ennreal
    (@measure_theory.measure_space.to_measurable_space.{u_1} α
       (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : α), f a)

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    { exact hf },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @measurable.{u_1 0} α ennreal
    (@measure_theory.measure_space.to_measurable_space.{u_1} α
       (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : α), f a)

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @measurable.{u_1 0} α ennreal
    (@measure_theory.measure_space.to_measurable_space.{u_1} α
       (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : α), f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    have : ∀n x,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117      @volume α { μ := join m} (⇑(simple_func.eapprox (λ (a : α), f a) n) ⁻¹&#x27; {x}) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='coe_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Type u_1} [_inst_1 : has_coe_to_fun.{(max (u_1+1) 1) (max (u_1+1) 1)} a] (x : a), @has_coe_to_fun.F.{(max (u_1+1) 1) (max (u_1+1) 1)} a _inst_1 x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type}, (α → β) → set.{0} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118      m.integral (λμ, @volume α { μ := μ } ((⇑(simple_func.eapprox (λ (a : α), f a) n) ⁻¹&#x27; {x}))) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='measure_theory.simple_func.eapprox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], (α → ennreal) → nat → @measure_theory.simple_func.{u_1 0} α _inst_1 ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type} [_inst_1 : has_emptyc.{0} γ] [_inst_2 : has_insert.{0 0} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119      assume n x, join_apply (simple_func.measurable_sn _ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='measure_theory.measure.join_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.simple_func.measurable_sn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {m : @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)} {s : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 m) s) (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) m (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {β : Type} (c : @measure_theory.simple_func.{u_1 0} α _inst_1 β) (x : β), @is_measurable.{u_1} α _inst_1 (@set.preimage.{u_1 0} α β (@measure_theory.simple_func.to_fun.{u_1 0} α _inst_1 β c) (@singleton.{0 0} β (set.{0} β) (@set.has_emptyc.{0} β) (@set.has_insert.{0} β) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    conv {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
| @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121      to_lhs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
| @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.simple_func.integral.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@measure_theory.simple_func.eapprox.{u_1} α
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (λ (a : α), f a)
               n)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
| @lattice.supr.{0 1} ennreal nat
    (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
       (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
          (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
    (λ (n : nat),
       @measure_theory.simple_func.integral.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@measure_theory.simple_func.eapprox.{u_1} α
            (@measure_theory.measure_space.to_measurable_space.{u_1} α
               (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
            (λ (a : α), f a)
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122      congr,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
| @lattice.supr.{0 1} ennreal nat
    (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
       (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
          (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
    (λ (n : nat),
       @measure_theory.simple_func.integral.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@measure_theory.simple_func.eapprox.{u_1} α
            (@measure_theory.measure_space.to_measurable_space.{u_1} α
               (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
            (λ (a : α), f a)
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
| λ (n : nat),
    @measure_theory.simple_func.integral.{u_1} α
      (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
      (@measure_theory.simple_func.eapprox.{u_1} α
         (@measure_theory.measure_space.to_measurable_space.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
         (λ (a : α), f a)
         n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123      funext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
| λ (n : nat),
    @measure_theory.simple_func.integral.{u_1} α
      (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
      (@measure_theory.simple_func.eapprox.{u_1} α
         (@measure_theory.measure_space.to_measurable_space.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
         (λ (a : α), f a)
         n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n : nat
| @measure_theory.simple_func.integral.{u_1} α
    (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
    (@measure_theory.simple_func.eapprox.{u_1} α
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
       (λ (a : α), f a)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124      rw [simple_func.integral] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.simple_func.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 409, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : measure_theory.measure_space.{?l_1} α], @measure_theory.simple_func.{?l_1 0} α (@measure_theory.measure_space.to_measurable_space.{?l_1} α _inst_1) ennreal → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Integral of a simple function whose codomain is `ennreal`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n : nat
| @measure_theory.simple_func.integral.{u_1} α
    (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
    (@measure_theory.simple_func.eapprox.{u_1} α
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
       (λ (a : α), f a)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n : nat
| @measure_theory.simple_func.integral.{u_1} α
    (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
    (@measure_theory.simple_func.eapprox.{u_1} α
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
       (λ (a : α), f a)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n : nat
| @finset.sum.{0 0} ennreal ennreal
    (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
       (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
          (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
             ennreal.canonically_ordered_comm_semiring_1)))
    (@measure_theory.simple_func.range.{u_1 0} α ennreal
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
       (@measure_theory.simple_func.eapprox.{u_1} α
          (@measure_theory.measure_space.to_measurable_space.{u_1} α
             (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
          (λ (a : α), f a)
          n))
    (λ (x : ennreal),
       @has_mul.mul.{0} ennreal
         (@mul_zero_class.to_has_mul.{0} ennreal
            (@semiring.to_mul_zero_class.{0} ennreal
               (@comm_semiring.to_semiring.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1))))
         x
         (@measure_theory.volume.{u_1} α
            (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
            (@set.preimage.{u_1 0} α ennreal
               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                  (@measure_theory.simple_func.{u_1 0} α
                     (@measure_theory.measure_space.to_measurable_space.{u_1} α
                        (@measure_theory.measure_space.mk.{u_1} α _inst_1
                           (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                     ennreal)
                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                     (@measure_theory.measure_space.to_measurable_space.{u_1} α
                        (@measure_theory.measure_space.mk.{u_1} α _inst_1
                           (@measure_theory.measure.join.{u_1} α _inst_1 m))))
                  (@measure_theory.simple_func.eapprox.{u_1} α
                     (@measure_theory.measure_space.to_measurable_space.{u_1} α
                        (@measure_theory.measure_space.mk.{u_1} α _inst_1
                           (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                     (λ (a : α), f a)
                     n))
               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                  x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  (λ (a : α), f a)
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.volume.{u_1} α
                    (@measure_theory.measure_space.mk.{u_1} α _inst_1
                       (@measure_theory.measure.join.{u_1} α _inst_1 m))
                    (@set.preimage.{u_1 0} α ennreal
                       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                          (@measure_theory.simple_func.{u_1 0} α
                             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                                (@measure_theory.measure_space.mk.{u_1} α _inst_1
                                   (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                             ennreal)
                          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                                (@measure_theory.measure_space.mk.{u_1} α _inst_1
                                   (@measure_theory.measure.join.{u_1} α _inst_1 m))))
                          (@measure_theory.simple_func.eapprox.{u_1} α
                             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                                (@measure_theory.measure_space.mk.{u_1} α _inst_1
                                   (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                             (λ (a : α), f a)
                             n))
                       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                          (@set.has_insert.{0} ennreal)
                          x))))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    simp [this],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat) (x : ennreal), @eq.{1} ennreal (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)) (@set.preimage.{u_1 0} α ennreal (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal) (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1) (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n)) (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x))) (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) m (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ) (@set.preimage.{u_1 0} α ennreal (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal) (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1) (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n)) (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  (λ (a : α), f a)
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.volume.{u_1} α
                    (@measure_theory.measure_space.mk.{u_1} α _inst_1
                       (@measure_theory.measure.join.{u_1} α _inst_1 m))
                    (@set.preimage.{u_1 0} α ennreal
                       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                          (@measure_theory.simple_func.{u_1 0} α
                             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                                (@measure_theory.measure_space.mk.{u_1} α _inst_1
                                   (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                             ennreal)
                          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal
                             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                                (@measure_theory.measure_space.mk.{u_1} α _inst_1
                                   (@measure_theory.measure.join.{u_1} α _inst_1 m))))
                          (@measure_theory.simple_func.eapprox.{u_1} α
                             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                                (@measure_theory.measure_space.mk.{u_1} α _inst_1
                                   (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                             (λ (a : α), f a)
                             n))
                       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                          (@set.has_insert.{0} ennreal)
                          x))))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126    transitivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    have : ∀(s : ℕ → finset ennreal) (f : ℕ → ennreal → measure α → ennreal)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → finset.{0} ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`finset α` is the type of finite sets of elements of `α`. It is implemented
 as a multiset (a list up to permutation) which has no duplicate elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The extended nonnegative real numbers. This is usually denoted [0, ∞],
 and is relevant as the codomain of a measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128      (hf : ∀n r, measurable (f n r)) (hm : monotone (λn μ, (s n).sum (λ r, r * f n r μ))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='monotone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type} [m₁ : measurable_space.{u_1} α] [m₂ : measurable_space.{0} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {β : Type u_1} [_inst_1 : preorder.{0} α] [_inst_2 : preorder.{u_1} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A function between preorders is monotone if
 `a ≤ b` implies `f a ≤ f b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129      (⨆n:ℕ, (s n).sum (λr, r * integral m (f n r))) =</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130      integral m (λμ, ⨆n:ℕ, (s n).sum (λr, r * f n r μ)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='lattice.supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α ι : Type} [_inst_1 : lattice.has_Sup.{0} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α ι : Type} [_inst_1 : lattice.has_Sup.{0} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Indexed supremum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed supremum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ ∀ (s : nat → finset.{0} ennreal) (f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              (s n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   (s n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f n r μ)))))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
this :
  ∀ (s : nat → finset.{0} ennreal) (f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              (s n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   (s n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f n r μ)))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    { assume s f hf hm,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ ∀ (s : nat → finset.{0} ennreal) (f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              (s n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   (s n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f n r μ)))))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
this :
  ∀ (s : nat → finset.{0} ennreal) (f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              (s n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   (s n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f n r μ)))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ ∀ (s : nat → finset.{0} ennreal) (f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              (s n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   (s n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f n r μ)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r μ)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132      symmetry,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1269, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='symmetry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r μ)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r μ)))))
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133      transitivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r μ)))))
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r μ)))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal ?m_1
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134      apply lintegral_supr,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.lintegral_supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 735, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α] {f : nat → α → ennreal}, (∀ (n : nat), @measurable.{u_1 0} α ennreal (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (f n)) → @monotone.{0 u_1} nat (α → ennreal) (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@pi.preorder.{u_1 0} α (λ (a : α), ennreal) (λ (i : α), @partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) f → @eq.{1} ennreal (@measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), @lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), f n a))) (@lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), f n a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Monotone convergence theorem -- somtimes called Beppo-Levi convergence.

See `lintegral_supr_directed` for a more general form.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r μ)))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal ?m_1
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ ∀ (n : nat),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m))
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r a)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (a : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r a)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r a)))))
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135      { exact assume n,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ ∀ (n : nat),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m))
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r a)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (a : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r a)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r a)))))
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ ∀ (n : nat),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m))
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136          measurable_finset_sum _ (assume r, ennreal.measurable.mul measurable_const (hf _ _)) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable_finset_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='ennreal.measurable.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 199, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 477, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : topological_space.{0} α] {ι : Type} [_inst_2 : add_comm_monoid.{0} α] [_inst_3 : @topological_add_monoid.{0} α _inst_1 (@add_comm_monoid.to_add_monoid.{0} α _inst_2)] [_inst_4 : @topological_space.second_countable_topology.{0} α _inst_1] [_inst_5 : measurable_space.{u_1} β] {f : ι → β → α} (s : finset.{0} ι), (∀ (i : ι), @measurable.{u_1 0} β α _inst_5 (@borel.{0} α _inst_1) (f i)) → @measurable.{u_1 0} β α _inst_5 (@borel.{0} α _inst_1) (λ (a : β), @finset.sum.{0 0} ι α _inst_2 s (λ (i : ι), f i a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {f g : α → ennreal}, @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f → @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) g → @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) (λ (a : α), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : measurable_space.{0} α] [_inst_2 : measurable_space.{u_1} β] {a : α}, @measurable.{u_1 0} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (n : nat) (r : ennreal), @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (f n r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ ∀ (n : nat),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m))
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (a : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r a)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r a)))))
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137      { exact hm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal) (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal) (λ (i : @measure_theory.measure.{u_1} α _inst_1), @partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) (s n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (f n r μ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (a : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r a)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r a)))))
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (a : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r a)))))
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138      congr, funext n,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 (s n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      (f n r a)))))
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (f n r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ)))
⊢ @eq.{1} (nat → ennreal)
    (λ (n : nat),
       @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m)
         (λ (a : @measure_theory.measure.{u_1} α _inst_1),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              (s n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (f n r a))))
    (λ (n : nat),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                 (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                 m
                 (f n r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal
    (@measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (f n r a))))
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (r : ennreal),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m
               (f n r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139      transitivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal
    (@measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (f n r a))))
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (r : ennreal),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m
               (f n r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal
    (@measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (f n r a))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal ?m_1
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (r : ennreal),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m
               (f n r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140      apply lintegral_finset_sum,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.lintegral_finset_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 855, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type} [_inst_1 : measure_theory.measure_space.{u_1} α] (s : finset.{0} β) {f : β → α → ennreal}, (∀ (b : β), @measurable.{u_1 0} α ennreal (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (f b)) → @eq.{1} ennreal (@measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), @finset.sum.{0 0} β ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) s (λ (b : β), f b a))) (@finset.sum.{0 0} β ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) s (λ (b : β), @measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), f b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal
    (@measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (s n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (f n r a))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal ?m_1
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (r : ennreal),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m
               (f n r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ ∀ (b : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m))
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @has_mul.mul.{0} ennreal
           (@mul_zero_class.to_has_mul.{0} ennreal
              (@semiring.to_mul_zero_class.{0} ennreal
                 (@comm_semiring.to_semiring.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1))))
           b
           (f n b a))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (b : ennreal),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 b
                 (f n b a))))
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (r : ennreal),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m
               (f n r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141      { exact assume r, ennreal.measurable.mul measurable_const (hf _ _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='ennreal.measurable.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 477, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {f g : α → ennreal}, @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f → @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) g → @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) (λ (a : α), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : measurable_space.{0} α] [_inst_2 : measurable_space.{u_1} β] {a : α}, @measurable.{u_1 0} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (n : nat) (r : ennreal), @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (f n r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ ∀ (b : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m))
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @has_mul.mul.{0} ennreal
           (@mul_zero_class.to_has_mul.{0} ennreal
              (@semiring.to_mul_zero_class.{0} ennreal
                 (@comm_semiring.to_semiring.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1))))
           b
           (f n b a))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (b : ennreal),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 b
                 (f n b a))))
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (r : ennreal),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m
               (f n r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ ∀ (b : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m))
      (@borel.{0} ennreal ennreal.topological_space)
      (λ (a : @measure_theory.measure.{u_1} α _inst_1),
         @has_mul.mul.{0} ennreal
           (@mul_zero_class.to_has_mul.{0} ennreal
              (@semiring.to_mul_zero_class.{0} ennreal
                 (@comm_semiring.to_semiring.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1))))
           b
           (f n b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (b : ennreal),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 b
                 (f n b a))))
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (r : ennreal),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m
               (f n r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142      congr, funext r,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} ennreal
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (b : ennreal),
          @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m)
            (λ (a : @measure_theory.measure.{u_1} α _inst_1),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 b
                 (f n b a))))
    (@finset.sum.{0 0} ennreal ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (s n)
       (λ (r : ennreal),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
               m
               (f n r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat
⊢ @eq.{1} (ennreal → ennreal)
    (λ (b : ennreal),
       @measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m)
         (λ (a : @measure_theory.measure.{u_1} α _inst_1),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              b
              (f n b a)))
    (λ (r : ennreal),
       @has_mul.mul.{0} ennreal
         (@mul_zero_class.to_has_mul.{0} ennreal
            (@semiring.to_mul_zero_class.{0} ennreal
               (@comm_semiring.to_semiring.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1))))
         r
         (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            m
            (f n r)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat,
r : ennreal
⊢ @eq.{1} ennreal
    (@measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (f n r a)))
    (@has_mul.mul.{0} ennreal
       (@mul_zero_class.to_has_mul.{0} ennreal
          (@semiring.to_mul_zero_class.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       r
       (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m
          (f n r)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143      apply lintegral_const_mul,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.lintegral_const_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 865, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α] (r : ennreal) {f : α → ennreal}, @measurable.{u_1 0} α ennreal (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) f → @eq.{1} ennreal (@measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (f a))) (@has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (@measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat,
r : ennreal
⊢ @eq.{1} ennreal
    (@measure_theory.lintegral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m)
       (λ (a : @measure_theory.measure.{u_1} α _inst_1),
          @has_mul.mul.{0} ennreal
            (@mul_zero_class.to_has_mul.{0} ennreal
               (@semiring.to_mul_zero_class.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            r
            (f n r a)))
    (@has_mul.mul.{0} ennreal
       (@mul_zero_class.to_has_mul.{0} ennreal
          (@semiring.to_mul_zero_class.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       r
       (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m
          (f n r)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat,
r : ennreal
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : @measure_theory.measure.{u_1} α _inst_1), f n r a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144      exact hf _ _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat) (r : ennreal), @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (f n r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
s : nat → finset.{0} ennreal,
f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal,
hf :
  ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      (f n r),
hm :
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         (s n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              (f n r μ))),
n : nat,
r : ennreal
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure_space.to_measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure_space.mk.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          m))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : @measure_theory.measure.{u_1} α _inst_1), f n r a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
this :
  ∀ (s : nat → finset.{0} ennreal) (f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              (s n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   (s n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f n r μ)))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145    specialize this (λn, simple_func.range (simple_func.eapprox f n)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='measure_theory.simple_func.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.simple_func.eapprox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : nat → finset.{0} ennreal) (f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal), (∀ (n : nat) (r : ennreal), @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (f n r)) → @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal) (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal) (λ (i : @measure_theory.measure.{u_1} α _inst_1), @partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) (s n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (f n r μ))) → @eq.{1} ennreal (@lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) (s n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) m (f n r))))) (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) m (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) (s n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (f n r μ)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type} [_inst_1 : measurable_space.{u_1} α], @measure_theory.simple_func.{u_1 0} α _inst_1 β → finset.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], (α → ennreal) → nat → @measure_theory.simple_func.{u_1 0} α _inst_1 ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Range of a simple function `α →ₛ β` as a `finset β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
this :
  ∀ (s : nat → finset.{0} ennreal) (f : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           (s n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              (s n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   (s n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f n r μ)))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
this :
  ∀ (f_1 : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f_1 n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           ((λ (n : nat),
               @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                 (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
              n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f_1 n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              ((λ (n : nat),
                  @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                 n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f_1 n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   ((λ (n : nat),
                       @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                         (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                      n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f_1 n r μ)))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    specialize this</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f_1 : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal), (∀ (n : nat) (r : ennreal), @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (f_1 n r)) → @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal) (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal) (λ (i : @measure_theory.measure.{u_1} α _inst_1), @partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ((λ (n : nat), @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1 (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n)) n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (f_1 n r μ))) → @eq.{1} ennreal (@lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ((λ (n : nat), @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1 (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n)) n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) m (f_1 n r))))) (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) m (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ((λ (n : nat), @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1 (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n)) n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (f_1 n r μ)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
this :
  ∀ (f_1 : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f_1 n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           ((λ (n : nat),
               @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                 (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
              n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f_1 n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              ((λ (n : nat),
                  @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                 n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f_1 n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   ((λ (n : nat),
                       @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                         (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                      n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f_1 n r μ)))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147      (λn r μ, @volume α { μ := μ } (⇑(simple_func.eapprox (λ (a : α), f a) n) ⁻¹&#x27; {r})),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='measure_theory.simple_func.eapprox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], (α → ennreal) → nat → @measure_theory.simple_func.{u_1 0} α _inst_1 ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type} [_inst_1 : has_emptyc.{0} γ] [_inst_2 : has_insert.{0 0} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
this :
  ∀ (f_1 : nat → ennreal → @measure_theory.measure.{u_1} α _inst_1 → ennreal),
    (∀ (n : nat) (r : ennreal),
       @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         (@borel.{0} ennreal ennreal.topological_space)
         (f_1 n r)) →
    @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
      (@partial_order.to_preorder.{0} nat
         (@ordered_comm_monoid.to_partial_order.{0} nat
            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
      (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
         (λ (i : @measure_theory.measure.{u_1} α _inst_1),
            @partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
      (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
         @finset.sum.{0 0} ennreal ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           ((λ (n : nat),
               @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                 (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
              n)
           (λ (r : ennreal),
              @has_mul.mul.{0} ennreal
                (@mul_zero_class.to_has_mul.{0} ennreal
                   (@semiring.to_mul_zero_class.{0} ennreal
                      (@comm_semiring.to_semiring.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1))))
                r
                (f_1 n r μ))) →
    @eq.{1} ennreal
      (@lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              ((λ (n : nat),
                  @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                 n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                      m
                      (f_1 n r)))))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @lattice.supr.{0 1} ennreal nat
              (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ (n : nat),
                 @finset.sum.{0 0} ennreal ennreal
                   (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                      (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                         (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                            ennreal.canonically_ordered_comm_semiring_1)))
                   ((λ (n : nat),
                       @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                         (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                      n)
                   (λ (r : ennreal),
                      @has_mul.mul.{0} ennreal
                        (@mul_zero_class.to_has_mul.{0} ennreal
                           (@semiring.to_mul_zero_class.{0} ennreal
                              (@comm_semiring.to_semiring.{0} ennreal
                                 (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                    ennreal.canonically_ordered_comm_semiring_1))))
                        r
                        (f_1 n r μ)))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
this :
  (∀ (n : nat) (r : ennreal),
     @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       (@borel.{0} ennreal ennreal.topological_space)
       ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
           @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
             (@set.preimage.{u_1 0} α ennreal
                (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                   (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                   (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                   r)))
          n
          r)) →
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         ((λ (n : nat),
             @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
            n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                  @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                    (@set.preimage.{u_1 0} α ennreal
                       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                          (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                          (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                          (@set.has_insert.{0} ennreal)
                          r)))
                 n
                 r
                 μ))) →
  @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            ((λ (n : nat),
                @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
               n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                        @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                          (@set.preimage.{u_1 0} α ennreal
                             (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                             (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                (@set.has_insert.{0} ennreal)
                                r)))
                       n
                       r)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 ((λ (n : nat),
                     @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                       (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                    n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                            (@set.preimage.{u_1 0} α ennreal
                               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                  (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                  (@set.has_insert.{0} ennreal)
                                  r)))
                         n
                         r
                         μ)))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    refine this _ _; clear this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(∀ (n : nat) (r : ennreal), @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ) (@set.preimage.{u_1 0} α ennreal (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal) (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1) (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n)) (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) r))) n r)) → @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal) (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal) (λ (i : @measure_theory.measure.{u_1} α _inst_1), @partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ((λ (n : nat), @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1 (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n)) n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ) (@set.preimage.{u_1 0} α ennreal (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal) (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1) (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n)) (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) r))) n r μ))) → @eq.{1} ennreal (@lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ((λ (n : nat), @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1 (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n)) n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) m ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ) (@set.preimage.{u_1 0} α ennreal (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal) (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1) (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n)) (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) r))) n r))))) (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) m (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @finset.sum.{0 0} ennreal ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ((λ (n : nat), @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1 (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n)) n) (λ (r : ennreal), @has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ) (@set.preimage.{u_1 0} α ennreal (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal) (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1) (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n)) (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) r))) n r μ)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
this :
  (∀ (n : nat) (r : ennreal),
     @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       (@borel.{0} ennreal ennreal.topological_space)
       ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
           @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
             (@set.preimage.{u_1 0} α ennreal
                (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                   (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                   (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                   r)))
          n
          r)) →
  @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         ((λ (n : nat),
             @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
            n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                  @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                    (@set.preimage.{u_1 0} α ennreal
                       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                          (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                          (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                          (@set.has_insert.{0} ennreal)
                          r)))
                 n
                 r
                 μ))) →
  @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            ((λ (n : nat),
                @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
               n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                        @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                          (@set.preimage.{u_1 0} α ennreal
                             (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                             (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                (@set.has_insert.{0} ennreal)
                                r)))
                       n
                       r)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 ((λ (n : nat),
                     @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                       (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                    n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                            (@set.preimage.{u_1 0} α ennreal
                               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                  (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                  (@set.has_insert.{0} ennreal)
                                  r)))
                         n
                         r
                         μ)))))
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            (@measure_theory.simple_func.range.{u_1 0} α ennreal
               (@measure_theory.measure_space.to_measurable_space.{u_1} α
                  (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m)))
               (@measure_theory.simple_func.eapprox.{u_1} α
                  (@measure_theory.measure_space.to_measurable_space.{u_1} α
                     (@measure_theory.measure_space.mk.{u_1} α _inst_1
                        (@measure_theory.measure.join.{u_1} α _inst_1 m)))
                  f
                  n))
            (λ (x : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 x
                 (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
                    m
                    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               x)))))))
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
            (@set.preimage.{u_1 0} α ennreal
               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                  r)))
         n
         r)

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         ((λ (n : nat),
             @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
            n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                  @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                    (@set.preimage.{u_1 0} α ennreal
                       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                          (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                          (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                          (@set.has_insert.{0} ennreal)
                          r)))
                 n
                 r
                 μ)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 ((λ (n : nat),
                     @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                       (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                    n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                            (@set.preimage.{u_1 0} α ennreal
                               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                  (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                  (@set.has_insert.{0} ennreal)
                                  r)))
                         n
                         r
                         μ)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    { assume n r,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
            (@set.preimage.{u_1 0} α ennreal
               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                  r)))
         n
         r)

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         ((λ (n : nat),
             @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
            n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                  @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                    (@set.preimage.{u_1 0} α ennreal
                       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                          (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                          (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                          (@set.has_insert.{0} ennreal)
                          r)))
                 n
                 r
                 μ)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 ((λ (n : nat),
                     @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                       (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                    n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                            (@set.preimage.{u_1 0} α ennreal
                               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                  (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                  (@set.has_insert.{0} ennreal)
                                  r)))
                         n
                         r
                         μ)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ ∀ (n : nat) (r : ennreal),
    @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
      (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
      (@borel.{0} ennreal ennreal.topological_space)
      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
            (@set.preimage.{u_1 0} α ennreal
               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                  r)))
         n
         r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n : nat,
r : ennreal
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
        @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
          (@set.preimage.{u_1 0} α ennreal
             (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
             (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                r)))
       n
       r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150      apply measurable_coe,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.measure.measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {s : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s → @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n : nat,
r : ennreal
⊢ @measurable.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1) ennreal
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
    (@borel.{0} ennreal ennreal.topological_space)
    ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
        @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
          (@set.preimage.{u_1 0} α ennreal
             (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
             (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                r)))
       n
       r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n : nat,
r : ennreal
⊢ @is_measurable.{u_1} α _inst_1
    (@set.preimage.{u_1 0} α ennreal
       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
          (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151      exact simple_func.measurable_sn _ _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.simple_func.measurable_sn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {β : Type} (c : @measure_theory.simple_func.{u_1 0} α _inst_1 β) (x : β), @is_measurable.{u_1} α _inst_1 (@set.preimage.{u_1 0} α β (@measure_theory.simple_func.to_fun.{u_1 0} α _inst_1 β c) (@singleton.{0 0} β (set.{0} β) (@set.has_emptyc.{0} β) (@set.has_insert.{0} β) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n : nat,
r : ennreal
⊢ @is_measurable.{u_1} α _inst_1
    (@set.preimage.{u_1 0} α ennreal
       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
          (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         ((λ (n : nat),
             @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
            n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                  @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                    (@set.preimage.{u_1 0} α ennreal
                       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                          (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                          (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                          (@set.has_insert.{0} ennreal)
                          r)))
                 n
                 r
                 μ)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 ((λ (n : nat),
                     @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                       (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                    n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                            (@set.preimage.{u_1 0} α ennreal
                               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                  (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                  (@set.has_insert.{0} ennreal)
                                  r)))
                         n
                         r
                         μ)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    { change monotone (λn μ, @simple_func.integral α {μ := μ} (simple_func.eapprox f n)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='monotone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.simple_func.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.simple_func.eapprox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 409, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {β : Type u_1} [_inst_1 : preorder.{0} α] [_inst_2 : preorder.{u_1} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], @measure_theory.simple_func.{u_1 0} α (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) ennreal → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], (α → ennreal) → nat → @measure_theory.simple_func.{u_1 0} α _inst_1 ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A function between preorders is monotone if
 `a ≤ b` implies `f a ≤ f b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Integral of a simple function whose codomain is `ennreal`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         ((λ (n : nat),
             @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
            n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                  @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                    (@set.preimage.{u_1 0} α ennreal
                       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                          (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                          (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                          (@set.has_insert.{0} ennreal)
                          r)))
                 n
                 r
                 μ)))

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 ((λ (n : nat),
                     @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                       (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                    n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                            (@set.preimage.{u_1 0} α ennreal
                               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                  (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                  (@set.has_insert.{0} ennreal)
                                  r)))
                         n
                         r
                         μ)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @finset.sum.{0 0} ennreal ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         ((λ (n : nat),
             @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
            n)
         (λ (r : ennreal),
            @has_mul.mul.{0} ennreal
              (@mul_zero_class.to_has_mul.{0} ennreal
                 (@semiring.to_mul_zero_class.{0} ennreal
                    (@comm_semiring.to_semiring.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1))))
              r
              ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                  @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                    (@set.preimage.{u_1 0} α ennreal
                       (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                          (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                          (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                          (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                       (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                          (@set.has_insert.{0} ennreal)
                          r)))
                 n
                 r
                 μ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
         (@measure_theory.simple_func.eapprox.{u_1} α
            (@measure_theory.measure_space.to_measurable_space.{u_1} α
               (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
            f
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153      assume n m h μ,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @monotone.{0 u_1} nat (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@pi.preorder.{u_1 0} (@measure_theory.measure.{u_1} α _inst_1)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal)
       (λ (i : @measure_theory.measure.{u_1} α _inst_1),
          @partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
    (λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
       @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
         (@measure_theory.simple_func.eapprox.{u_1} α
            (@measure_theory.measure_space.to_measurable_space.{u_1} α
               (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
            f
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n m : nat,
h :
  @has_le.le.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    n
    m,
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @has_le.le.{0} ((λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal) μ)
    (@preorder.to_has_le.{0} ((λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal) μ)
       ((λ (i : @measure_theory.measure.{u_1} α _inst_1),
           @partial_order.to_preorder.{0} ennreal
             (@ordered_comm_monoid.to_partial_order.{0} ennreal
                (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                   (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                      ennreal.canonically_ordered_comm_semiring_1))))
          μ))
    ((λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
        @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
          (@measure_theory.simple_func.eapprox.{u_1} α
             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
             f
             n))
       n
       μ)
    ((λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
        @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
          (@measure_theory.simple_func.eapprox.{u_1} α
             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
             f
             n))
       m
       μ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154      apply simple_func.integral_le_integral,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.simple_func.integral_le_integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 538, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α] (f g : @measure_theory.simple_func.{u_1 0} α (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) ennreal), @has_le.le.{u_1} (@measure_theory.simple_func.{u_1 0} α (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) ennreal) (@measure_theory.simple_func.has_le.{u_1 0} α ennreal (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))))) f g → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@measure_theory.simple_func.integral.{u_1} α _inst_1 f) (@measure_theory.simple_func.integral.{u_1} α _inst_1 g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n m : nat,
h :
  @has_le.le.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    n
    m,
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @has_le.le.{0} ((λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal) μ)
    (@preorder.to_has_le.{0} ((λ (μ : @measure_theory.measure.{u_1} α _inst_1), ennreal) μ)
       ((λ (i : @measure_theory.measure.{u_1} α _inst_1),
           @partial_order.to_preorder.{0} ennreal
             (@ordered_comm_monoid.to_partial_order.{0} ennreal
                (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                   (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                      ennreal.canonically_ordered_comm_semiring_1))))
          μ))
    ((λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
        @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
          (@measure_theory.simple_func.eapprox.{u_1} α
             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
             f
             n))
       n
       μ)
    ((λ (n : nat) (μ : @measure_theory.measure.{u_1} α _inst_1),
        @measure_theory.simple_func.integral.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
          (@measure_theory.simple_func.eapprox.{u_1} α
             (@measure_theory.measure_space.to_measurable_space.{u_1} α
                (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
             f
             n))
       m
       μ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n m : nat,
h :
  @has_le.le.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    n
    m,
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @has_le.le.{u_1}
    (@measure_theory.simple_func.{u_1 0} α
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
       ennreal)
    (@measure_theory.simple_func.has_le.{u_1 0} α ennreal
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
       (@preorder.to_has_le.{0} ennreal
          (@partial_order.to_preorder.{0} ennreal
             (@ordered_comm_monoid.to_partial_order.{0} ennreal
                (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                   (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                      ennreal.canonically_ordered_comm_semiring_1))))))
    (@measure_theory.simple_func.eapprox.{u_1} α
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
       f
       n)
    (@measure_theory.simple_func.eapprox.{u_1} α
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
       f
       m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155      apply simple_func.monotone_eapprox,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.simple_func.monotone_eapprox'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 364, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (f : α → ennreal), @monotone.{0 u_1} nat (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal) (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@measure_theory.simple_func.preorder.{u_1 0} α ennreal _inst_1 (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n m : nat,
h :
  @has_le.le.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    n
    m,
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @has_le.le.{u_1}
    (@measure_theory.simple_func.{u_1 0} α
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
       ennreal)
    (@measure_theory.simple_func.has_le.{u_1 0} α ennreal
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
       (@preorder.to_has_le.{0} ennreal
          (@partial_order.to_preorder.{0} ennreal
             (@ordered_comm_monoid.to_partial_order.{0} ennreal
                (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                   (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                      ennreal.canonically_ordered_comm_semiring_1))))))
    (@measure_theory.simple_func.eapprox.{u_1} α
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
       f
       n)
    (@measure_theory.simple_func.eapprox.{u_1} α
       (@measure_theory.measure_space.to_measurable_space.{u_1} α
          (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
       f
       m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n m : nat,
h :
  @has_le.le.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    n
    m,
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @has_le.le.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    n
    m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156      assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
n m : nat,
h :
  @has_le.le.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    n
    m,
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @has_le.le.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    n
    m'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 ((λ (n : nat),
                     @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                       (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                    n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                            (@set.preimage.{u_1 0} α ennreal
                               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                  (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                  (@set.has_insert.{0} ennreal)
                                  r)))
                         n
                         r
                         μ)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    congr, funext μ,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @lattice.supr.{0 1} ennreal nat
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (n : nat),
               @finset.sum.{0 0} ennreal ennreal
                 (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                    (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                       (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                          ennreal.canonically_ordered_comm_semiring_1)))
                 ((λ (n : nat),
                     @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                       (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                    n)
                 (λ (r : ennreal),
                    @has_mul.mul.{0} ennreal
                      (@mul_zero_class.to_has_mul.{0} ennreal
                         (@semiring.to_mul_zero_class.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      r
                      ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                          @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                            (@set.preimage.{u_1 0} α ennreal
                               (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                                  (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                                  (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                               (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                                  (@set.has_insert.{0} ennreal)
                                  r)))
                         n
                         r
                         μ)))))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       m
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x))))
⊢ @eq.{(max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
       @lattice.supr.{0 1} ennreal nat
         (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (n : nat),
            @finset.sum.{0 0} ennreal ennreal
              (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))
              ((λ (n : nat),
                  @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
                 n)
              (λ (r : ennreal),
                 @has_mul.mul.{0} ennreal
                   (@mul_zero_class.to_has_mul.{0} ennreal
                      (@semiring.to_mul_zero_class.{0} ennreal
                         (@comm_semiring.to_semiring.{0} ennreal
                            (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                               ennreal.canonically_ordered_comm_semiring_1))))
                   r
                   ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                       @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                         (@set.preimage.{u_1 0} α ennreal
                            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                               (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                               (@set.has_insert.{0} ennreal)
                               r)))
                      n
                      r
                      μ))))
    (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.integral.{u_1} α _inst_1 μ f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            ((λ (n : nat),
                @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
               n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                     @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                       (@set.preimage.{u_1 0} α ennreal
                          (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                             (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                             (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                             (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                          (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                             (@set.has_insert.{0} ennreal)
                             r)))
                    n
                    r
                    μ))))
    (@measure_theory.measure.integral.{u_1} α _inst_1 μ f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158    symmetry,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1269, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='symmetry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            ((λ (n : nat),
                @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
               n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                     @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                       (@set.preimage.{u_1 0} α ennreal
                          (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                             (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                             (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                             (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                          (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                             (@set.has_insert.{0} ennreal)
                             r)))
                    n
                    r
                    μ))))
    (@measure_theory.measure.integral.{u_1} α _inst_1 μ f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @eq.{1} ennreal (@measure_theory.measure.integral.{u_1} α _inst_1 μ f)
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            ((λ (n : nat),
                @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
               n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                     @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                       (@set.preimage.{u_1 0} α ennreal
                          (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                             (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                             (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                             (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                          (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                             (@set.has_insert.{0} ennreal)
                             r)))
                    n
                    r
                    μ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    apply lintegral_eq_supr_eapprox_integral,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.lintegral_eq_supr_eapprox_integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 815, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α] {f : α → ennreal}, @measurable.{u_1 0} α ennreal (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) f → @eq.{1} ennreal (@measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), f a)) (@lattice.supr.{0 1} ennreal nat (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (n : nat), @measure_theory.simple_func.integral.{u_1} α _inst_1 (@measure_theory.simple_func.eapprox.{u_1} α (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) f n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @eq.{1} ennreal (@measure_theory.measure.integral.{u_1} α _inst_1 μ f)
    (@lattice.supr.{0 1} ennreal nat
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (n : nat),
          @finset.sum.{0 0} ennreal ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            ((λ (n : nat),
                @measure_theory.simple_func.range.{u_1 0} α ennreal _inst_1
                  (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 f n))
               n)
            (λ (r : ennreal),
               @has_mul.mul.{0} ennreal
                 (@mul_zero_class.to_has_mul.{0} ennreal
                    (@semiring.to_mul_zero_class.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 r
                 ((λ (n : nat) (r : ennreal) (μ : @measure_theory.measure.{u_1} α _inst_1),
                     @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
                       (@set.preimage.{u_1 0} α ennreal
                          (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)}
                             (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                             (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                             (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                          (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal)
                             (@set.has_insert.{0} ennreal)
                             r)))
                    n
                    r
                    μ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @measurable.{u_1 0} α ennreal
    (@measure_theory.measure_space.to_measurable_space.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : α), f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    exact hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
f : α → ennreal,
hf : @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f,
this :
  ∀ (n : nat) (x : ennreal),
    @eq.{1} ennreal
      (@measure_theory.volume.{u_1} α
         (@measure_theory.measure_space.mk.{u_1} α _inst_1 (@measure_theory.measure.join.{u_1} α _inst_1 m))
         (@set.preimage.{u_1 0} α ennreal
            (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
               (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
               (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
            (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal) x)))
      (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         m
         (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
            @measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ)
              (@set.preimage.{u_1 0} α ennreal
                 (@coe_fn.{(max (u_1+1) 1) (max (u_1+1) 1)} (@measure_theory.simple_func.{u_1 0} α _inst_1 ennreal)
                    (@measure_theory.simple_func.has_coe_to_fun.{u_1 0} α ennreal _inst_1)
                    (@measure_theory.simple_func.eapprox.{u_1} α _inst_1 (λ (a : α), f a) n))
                 (@singleton.{0 0} ennreal (set.{0} ennreal) (@set.has_emptyc.{0} ennreal) (@set.has_insert.{0} ennreal)
                    x)))),
μ : @measure_theory.measure.{u_1} α _inst_1
⊢ @measurable.{u_1 0} α ennreal
    (@measure_theory.measure_space.to_measurable_space.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 μ))
    (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : α), f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  /-- Monadic bind on `measure`, only works in the category of measurable spaces and measurable</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  functions. When the function `f` is not measurable the result is not well defined. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  def bind (m : measure α) (f : α → measure β) : measure β := join (map f m)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 593, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], (α → β) → @measure_theory.measure.{u_1} α _inst_1 → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  @[simp] lemma bind_apply {m : measure α} {f : α → measure β} {s : set β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    (hs : is_measurable s) (hf : measurable f) : bind m f s = m.integral (λa, f a s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  by rw [bind, join_apply hs, integral_map (measurable_coe hs) hf]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.integral_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1254, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measurable_space.{?l_1} α] [_inst_2 : measurable_space.{?l_2} β], @measure_theory.measure.{?l_1} α _inst_1 → (α → @measure_theory.measure.{?l_2} β _inst_2) → @measure_theory.measure.{?l_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] {m : @measure_theory.measure.{u_2} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} α _inst_1)} {s : set.{u_2} α}, @is_measurable.{u_2} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) (@measure_theory.measure.join.{u_2} α _inst_1 m) s) (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} α _inst_1) m (λ (μ : @measure_theory.measure.{u_2} α _inst_1), @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] {m : @measure_theory.measure.{u_1} α _inst_1} [_inst_2 : measurable_space.{u_2} β] {f : β → ennreal} {g : α → β}, @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f → @measurable.{u_1 u_2} α β _inst_1 _inst_2 g → @eq.{1} ennreal (@measure_theory.measure.integral.{u_2} β _inst_2 (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 g m) f) (@measure_theory.measure.integral.{u_1} α _inst_1 m (@function.comp.{u_1+1 u_2+1 1} α β ennreal f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] {s : set.{u_2} α}, @is_measurable.{u_2} α _inst_1 s → @measurable.{u_2 0} (@measure_theory.measure.{u_2} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_2} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_2} α _inst_1), @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m f)
       s)
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            (f a)
            s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.join.{u_2} β _inst_2
          (@measure_theory.measure.map.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
             (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
             f
             m))
       s)
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            (f a)
            s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
          (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
          f
          m)
       (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            μ
            s))
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            (f a)
            s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m f)
       s)
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            (f a)
            s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m f)
       s)
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            (f a)
            s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  lemma measurable_bind&#x27; {g : α → measure β} (hg : measurable g) : measurable (λm, bind m g) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  measurable_join.comp (measurable_map _ hg)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.measurable_join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measurable.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.measurable_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 368, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α], @measurable.{u_2 u_2} (@measure_theory.measure.{u_2} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} α _inst_1)) (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} α _inst_1)) (@measure_theory.measure.measurable_space.{u_2} α _inst_1) (@measure_theory.measure.join.{u_2} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β γ : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β] [_inst_3 : measurable_space.{u_2} γ] {g : β → γ} {f : α → β}, @measurable.{u_2 u_2} β γ _inst_2 _inst_3 g → @measurable.{u_1 u_2} α β _inst_1 _inst_2 f → @measurable.{u_1 u_2} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_2+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β] (f : α → β), @measurable.{u_1 u_2} α β _inst_1 _inst_2 f → @measurable.{u_1 u_2} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.{u_2} β _inst_2) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} β _inst_2) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_2} β _inst_2) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  lemma integral_bind {m : measure α} {g : α → measure β} {f : β → ennreal}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='orange'><a title='The extended nonnegative real numbers. This is usually denoted [0, ∞],
 and is relevant as the codomain of a measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    (hg : measurable g) (hf : measurable f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    integral (bind m g) f = integral m (λa, integral (g a) f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1247, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} α _inst_1 → (α → ennreal) → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
g : α → @measure_theory.measure.{u_2} β _inst_2,
f : β → ennreal,
hg :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    g,
hf : @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} β _inst_2
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m g)
       f)
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α), @measure_theory.measure.integral.{u_2} β _inst_2 (g a) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178    transitivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
g : α → @measure_theory.measure.{u_2} β _inst_2,
f : β → ennreal,
hg :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    g,
hf : @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} β _inst_2
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m g)
       f)
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α), @measure_theory.measure.integral.{u_2} β _inst_2 (g a) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
g : α → @measure_theory.measure.{u_2} β _inst_2,
f : β → ennreal,
hg :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    g,
hf : @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} β _inst_2
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m g)
       f)
    ?m_1

α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
g : α → @measure_theory.measure.{u_2} β _inst_2,
f : β → ennreal,
hg :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    g,
hf : @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α), @measure_theory.measure.integral.{u_2} β _inst_2 (g a) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    exact integral_join hf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.measure.integral_join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] {m : @measure_theory.measure.{u_2} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} α _inst_1)} {f : α → ennreal}, @measurable.{u_2 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f → @eq.{1} ennreal (@measure_theory.measure.integral.{u_2} α _inst_1 (@measure_theory.measure.join.{u_2} α _inst_1 m) f) (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} α _inst_1) m (λ (μ : @measure_theory.measure.{u_2} α _inst_1), @measure_theory.measure.integral.{u_2} α _inst_1 μ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
g : α → @measure_theory.measure.{u_2} β _inst_2,
f : β → ennreal,
hg :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    g,
hf : @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} β _inst_2
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m g)
       f)
    ?m_1

α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
g : α → @measure_theory.measure.{u_2} β _inst_2,
f : β → ennreal,
hg :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    g,
hf : @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal ?m_1
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α), @measure_theory.measure.integral.{u_2} β _inst_2 (g a) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
g : α → @measure_theory.measure.{u_2} β _inst_2,
f : β → ennreal,
hg :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    g,
hf : @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
          (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
          g
          m)
       (λ (μ : @measure_theory.measure.{u_2} β _inst_2), @measure_theory.measure.integral.{u_2} β _inst_2 μ f))
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α), @measure_theory.measure.integral.{u_2} β _inst_2 (g a) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    exact integral_map (measurable_integral _ hf) hg</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.measure.integral_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.measurable_integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1254, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 71, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] {m : @measure_theory.measure.{u_1} α _inst_1} [_inst_2 : measurable_space.{u_2} β] {f : β → ennreal} {g : α → β}, @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f → @measurable.{u_1 u_2} α β _inst_1 _inst_2 g → @eq.{1} ennreal (@measure_theory.measure.integral.{u_2} β _inst_2 (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 g m) f) (@measure_theory.measure.integral.{u_1} α _inst_1 m (@function.comp.{u_1+1 u_2+1 1} α β ennreal f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] (f : α → ennreal), @measurable.{u_2 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f → @measurable.{u_2 0} (@measure_theory.measure.{u_2} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_2} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_2} α _inst_1), @measure_theory.measure.integral.{u_2} α _inst_1 μ f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_2} β _inst_2) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
m : @measure_theory.measure.{u_1} α _inst_1,
g : α → @measure_theory.measure.{u_2} β _inst_2,
f : β → ennreal,
hg :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    g,
hf : @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
          (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
          g
          m)
       (λ (μ : @measure_theory.measure.{u_2} β _inst_2), @measure_theory.measure.integral.{u_2} β _inst_2 μ f))
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α), @measure_theory.measure.integral.{u_2} β _inst_2 (g a) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  lemma bind_bind {γ} [measurable_space γ] {m : measure α} {f : α → measure β} {g : β → measure γ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='measurable_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184    (hf : measurable f) (hg : measurable g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → @measure_theory.measure.{u_3} γ _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185    bind (bind m f) g = bind m (λa, bind (f a) g) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → @measure_theory.measure.{u_3} γ _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → @measure_theory.measure.{u_3} γ _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  measure.ext $ assume s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 257, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : measurable_space.{u_3} α] {μ₁ μ₂ : @measure_theory.measure.{u_3} α _inst_1}, (∀ (s : set.{u_3} α), @is_measurable.{u_3} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_3} α _inst_1) μ₁ s) (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_3} α _inst_1) μ₂ s)) → @eq.{u_3+1} (@measure_theory.measure.{u_3} α _inst_1) μ₁ μ₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u_3} γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u_3} γ _inst_3 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
       (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
       (@measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3
          (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m f)
          g)
       s)
    (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
       (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
       (@measure_theory.measure.bind.{u_1 u_3} α γ _inst_1 _inst_3 m
          (λ (a : α), @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 (f a) g))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    rw [bind_apply hs hg, bind_apply hs ((measurable_bind&#x27; hg).comp hf), integral_bind hf],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='measure_theory.measure.bind_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.bind_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure.measurable_bind&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure.integral_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 171, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 174, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : measurable_space.{u_2} α] [_inst_2 : measurable_space.{u_3} β] {m : @measure_theory.measure.{u_2} α _inst_1} {f : α → @measure_theory.measure.{u_3} β _inst_2} {s : set.{u_3} β}, @is_measurable.{u_3} β _inst_2 s → @measurable.{u_2 u_3} α (@measure_theory.measure.{u_3} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_3} β _inst_2) f → @eq.{1} ennreal (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_3} β _inst_2) (@measure_theory.measure.bind.{u_2 u_3} α β _inst_1 _inst_2 m f) s) (@measure_theory.measure.integral.{u_2} α _inst_1 m (λ (a : α), @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_3} β _inst_2) (f a) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_3} γ _inst_3 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2 (@measure_theory.measure.measurable_space.{u_3} γ _inst_3) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_3} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_3} β] {m : @measure_theory.measure.{u_1} α _inst_1} {f : α → @measure_theory.measure.{u_3} β _inst_2} {s : set.{u_3} β}, @is_measurable.{u_3} β _inst_2 s → @measurable.{u_1 u_3} α (@measure_theory.measure.{u_3} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_3} β _inst_2) f → @eq.{1} ennreal (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_3} β _inst_2) (@measure_theory.measure.bind.{u_1 u_3} α β _inst_1 _inst_2 m f) s) (@measure_theory.measure.integral.{u_1} α _inst_1 m (λ (a : α), @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_3} β _inst_2) (f a) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_3} γ _inst_3 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : measurable_space.{u_2} α] [_inst_2 : measurable_space.{u_3} β] {g : α → @measure_theory.measure.{u_3} β _inst_2}, @measurable.{u_2 u_3} α (@measure_theory.measure.{u_3} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_3} β _inst_2) g → @measurable.{u_2 u_3} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.{u_3} β _inst_2) (@measure_theory.measure.measurable_space.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_3} β _inst_2) (λ (m : @measure_theory.measure.{u_2} α _inst_1), @measure_theory.measure.bind.{u_2 u_3} α β _inst_1 _inst_2 m g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2 (@measure_theory.measure.measurable_space.{u_3} γ _inst_3) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β] {m : @measure_theory.measure.{u_1} α _inst_1} {g : α → @measure_theory.measure.{u_2} β _inst_2} {f : β → ennreal}, @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_2} β _inst_2) g → @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f → @eq.{1} ennreal (@measure_theory.measure.integral.{u_2} β _inst_2 (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m g) f) (@measure_theory.measure.integral.{u_1} α _inst_1 m (λ (a : α), @measure_theory.measure.integral.{u_2} β _inst_2 (g a) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
       (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
       (@measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3
          (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m f)
          g)
       s)
    (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
       (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
       (@measure_theory.measure.bind.{u_1 u_3} α γ _inst_1 _inst_3 m
          (λ (a : α), @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 (f a) g))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} β _inst_2
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m f)
       (λ (a : β),
          @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
            (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
            (g a)
            s))
    (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
       (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
       (@measure_theory.measure.bind.{u_1 u_3} α γ _inst_1 _inst_3 m
          (λ (a : α), @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 (f a) g))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} β _inst_2
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m f)
       (λ (a : β),
          @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
            (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
            (g a)
            s))
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
            (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
            (@function.comp.{u_1+1 u_2+1 u_3+1} α (@measure_theory.measure.{u_2} β _inst_2)
               (@measure_theory.measure.{u_3} γ _inst_3)
               (λ (m : @measure_theory.measure.{u_2} β _inst_2),
                  @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 m g)
               f
               a)
            s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @measure_theory.measure.integral.{u_2} β _inst_2 (f a)
            (λ (a : β),
               @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
                 (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
                 (g a)
                 s)))
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
            (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
            (@function.comp.{u_1+1 u_2+1 u_3+1} α (@measure_theory.measure.{u_2} β _inst_2)
               (@measure_theory.measure.{u_3} γ _inst_3)
               (λ (m : @measure_theory.measure.{u_2} β _inst_2),
                  @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 m g)
               f
               a)
            s))

α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : β),
       @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
         (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
         (g a)
         s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189    { congr, funext a,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @measure_theory.measure.integral.{u_2} β _inst_2 (f a)
            (λ (a : β),
               @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
                 (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
                 (g a)
                 s)))
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
            (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
            (@function.comp.{u_1+1 u_2+1 u_3+1} α (@measure_theory.measure.{u_2} β _inst_2)
               (@measure_theory.measure.{u_3} γ _inst_3)
               (λ (m : @measure_theory.measure.{u_2} β _inst_2),
                  @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 m g)
               f
               a)
            s))

α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : β),
       @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
         (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
         (g a)
         s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @measure_theory.measure.integral.{u_2} β _inst_2 (f a)
            (λ (a : β),
               @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
                 (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
                 (g a)
                 s)))
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
            (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
            (@function.comp.{u_1+1 u_2+1 u_3+1} α (@measure_theory.measure.{u_2} β _inst_2)
               (@measure_theory.measure.{u_3} γ _inst_3)
               (λ (m : @measure_theory.measure.{u_2} β _inst_2),
                  @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 m g)
               f
               a)
            s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @eq.{(max (u_1+1) 1)} (α → ennreal)
    (λ (a : α),
       @measure_theory.measure.integral.{u_2} β _inst_2 (f a)
         (λ (a : β),
            @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
              (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
              (g a)
              s))
    (λ (a : α),
       @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
         (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
         (@function.comp.{u_1+1 u_2+1 u_3+1} α (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.{u_3} γ _inst_3)
            (λ (m : @measure_theory.measure.{u_2} β _inst_2),
               @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 m g)
            f
            a)
         s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s,
a : α
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} β _inst_2 (f a)
       (λ (a : β),
          @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
            (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
            (g a)
            s))
    (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
       (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
       (@function.comp.{u_1+1 u_2+1 u_3+1} α (@measure_theory.measure.{u_2} β _inst_2)
          (@measure_theory.measure.{u_3} γ _inst_3)
          (λ (m : @measure_theory.measure.{u_2} β _inst_2),
             @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 m g)
          f
          a)
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190      exact (bind_apply hs hg).symm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.measure.bind_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : measurable_space.{u_2} α] [_inst_2 : measurable_space.{u_3} β] {m : @measure_theory.measure.{u_2} α _inst_1} {f : α → @measure_theory.measure.{u_3} β _inst_2} {s : set.{u_3} β}, @is_measurable.{u_3} β _inst_2 s → @measurable.{u_2 u_3} α (@measure_theory.measure.{u_3} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_3} β _inst_2) f → @eq.{1} ennreal (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_3} β _inst_2) (@measure_theory.measure.bind.{u_2 u_3} α β _inst_1 _inst_2 m f) s) (@measure_theory.measure.integral.{u_2} α _inst_1 m (λ (a : α), @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_3} β _inst_2) (f a) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_3} γ _inst_3 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2 (@measure_theory.measure.measurable_space.{u_3} γ _inst_3) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s,
a : α
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} β _inst_2 (f a)
       (λ (a : β),
          @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
            (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
            (g a)
            s))
    (@coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
       (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
       (@function.comp.{u_1+1 u_2+1 u_3+1} α (@measure_theory.measure.{u_2} β _inst_2)
          (@measure_theory.measure.{u_3} γ _inst_3)
          (λ (m : @measure_theory.measure.{u_2} β _inst_2),
             @measure_theory.measure.bind.{u_2 u_3} β γ _inst_2 _inst_3 m g)
          f
          a)
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : β),
       @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
         (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
         (g a)
         s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191    exact (measurable_coe hs).comp hg</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.measure.measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : measurable_space.{u_3} α] {s : set.{u_3} α}, @is_measurable.{u_3} α _inst_1 s → @measurable.{u_3 0} (@measure_theory.measure.{u_3} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_3} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_3} α _inst_1), @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_3} α _inst_1) μ s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_3} γ _inst_3 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2 (@measure_theory.measure.measurable_space.{u_3} γ _inst_3) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
γ : Type u_3,
_inst_3 : measurable_space.{u_3} γ,
m : @measure_theory.measure.{u_1} α _inst_1,
f : α → @measure_theory.measure.{u_2} β _inst_2,
g : β → @measure_theory.measure.{u_3} γ _inst_3,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
hg :
  @measurable.{u_2 u_3} β (@measure_theory.measure.{u_3} γ _inst_3) _inst_2
    (@measure_theory.measure.measurable_space.{u_3} γ _inst_3)
    g,
s : set.{u_3} γ,
hs : @is_measurable.{u_3} γ _inst_3 s
⊢ @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space)
    (λ (a : β),
       @coe_fn.{u_3+1 (max (u_3+1) 1)} (@measure_theory.measure.{u_3} γ _inst_3)
         (@measure_theory.measure.has_coe_to_fun.{u_3} γ _inst_3)
         (g a)
         s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  lemma bind_dirac {f : α → measure β} (hf : measurable f) (a : α) : bind (dirac a) f = f a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 616, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], α → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The dirac measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  measure.ext $ assume s hs, by rw [bind_apply hs hf, integral_dirac a ((measurable_coe hs).comp hf)]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.measure.bind_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.integral_dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure.measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 257, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1266, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] {μ₁ μ₂ : @measure_theory.measure.{u_2} α _inst_1}, (∀ (s : set.{u_2} α), @is_measurable.{u_2} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ₁ s) (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ₂ s)) → @eq.{u_2+1} (@measure_theory.measure.{u_2} α _inst_1) μ₁ μ₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β] {m : @measure_theory.measure.{u_1} α _inst_1} {f : α → @measure_theory.measure.{u_2} β _inst_2} {s : set.{u_2} β}, @is_measurable.{u_2} β _inst_2 s → @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_2} β _inst_2) f → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2) (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 m f) s) (@measure_theory.measure.integral.{u_1} α _inst_1 m (λ (a : α), @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2) (f a) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (a : α) {f : α → ennreal}, @measurable.{u_1 0} α ennreal _inst_1 (@borel.{0} ennreal ennreal.topological_space) f → @eq.{1} ennreal (@measure_theory.measure.integral.{u_1} α _inst_1 (@measure_theory.measure.dirac.{u_1} α _inst_1 a) f) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] {s : set.{u_2} α}, @is_measurable.{u_2} α _inst_1 s → @measurable.{u_2 0} (@measure_theory.measure.{u_2} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_2} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_2} α _inst_1), @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → @measure_theory.measure.{u_2} β _inst_2,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 (@measure_theory.measure.dirac.{u_1} α _inst_1 a)
          f)
       s)
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (f a)
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → @measure_theory.measure.{u_2} β _inst_2,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 (@measure_theory.measure.dirac.{u_1} α _inst_1 a)
       (λ (a : α),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            (f a)
            s))
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (f a)
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → @measure_theory.measure.{u_2} β _inst_2,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 (@measure_theory.measure.dirac.{u_1} α _inst_1 a)
          f)
       s)
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (f a)
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → @measure_theory.measure.{u_2} β _inst_2,
hf :
  @measurable.{u_1 u_2} α (@measure_theory.measure.{u_2} β _inst_2) _inst_1
    (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
    f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.bind.{u_1 u_2} α β _inst_1 _inst_2 (@measure_theory.measure.dirac.{u_1} α _inst_1 a)
          f)
       s)
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (f a)
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  lemma dirac_bind {m : measure α} : bind m dirac = m :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 616, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], α → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The dirac measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  measure.ext $ assume s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 257, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {μ₁ μ₂ : @measure_theory.measure.{u_1} α _inst_1}, (∀ (s : set.{u_1} α), @is_measurable.{u_1} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ₁ s) (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ₂ s)) → @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) μ₁ μ₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       (@measure_theory.measure.bind.{u_1 u_1} α α _inst_1 _inst_1 m (@measure_theory.measure.dirac.{u_1} α _inst_1))
       s)
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200    rw [bind_apply hs measurable_dirac],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='measure_theory.measure.bind_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.measurable_dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_1} β] {m : @measure_theory.measure.{u_1} α _inst_1} {f : α → @measure_theory.measure.{u_1} β _inst_2} {s : set.{u_1} β}, @is_measurable.{u_1} β _inst_2 s → @measurable.{u_1 u_1} α (@measure_theory.measure.{u_1} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_1} β _inst_2) f → @eq.{1} ennreal (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_1} β _inst_2) (@measure_theory.measure.bind.{u_1 u_1} α β _inst_1 _inst_2 m f) s) (@measure_theory.measure.integral.{u_1} α _inst_1 m (λ (a : α), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_1} β _inst_2) (f a) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measurable.{u_1 u_1} α (@measure_theory.measure.{u_1} α _inst_1) _inst_1 (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@measure_theory.measure.dirac.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       (@measure_theory.measure.bind.{u_1 u_1} α α _inst_1 _inst_1 m (@measure_theory.measure.dirac.{u_1} α _inst_1))
       s)
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            (@measure_theory.measure.dirac.{u_1} α _inst_1 a)
            s))
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201    simp [dirac_apply _ hs],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.measure.dirac_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 619, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (a : α) {s : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) (@measure_theory.measure.dirac.{u_1} α _inst_1 a) s) (@lattice.supr.{0 0} ennreal (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s) (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s), @has_one.one.{0} ennreal (@zero_ne_one_class.to_has_one.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            (@measure_theory.measure.dirac.{u_1} α _inst_1 a)
            s))
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @lattice.supr.{0 0} ennreal (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s)
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s),
               @has_one.one.{0} ennreal
                 (@zero_ne_one_class.to_has_one.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202    transitivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @lattice.supr.{0 0} ennreal (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s)
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s),
               @has_one.one.{0} ennreal
                 (@zero_ne_one_class.to_has_one.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @lattice.supr.{0 0} ennreal (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s)
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s),
               @has_one.one.{0} ennreal
                 (@zero_ne_one_class.to_has_one.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal ?m_1
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203    apply lintegral_supr_const,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.lintegral_supr_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α] (r : ennreal) {s : set.{u_1} α}, @is_measurable.{u_1} α (@measure_theory.measure_space.to_measurable_space.{u_1} α _inst_1) s → @eq.{1} ennreal (@measure_theory.lintegral.{u_1} α _inst_1 (λ (a : α), @lattice.supr.{0 0} ennreal (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s) (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s), r))) (@has_mul.mul.{0} ennreal (@mul_zero_class.to_has_mul.{0} ennreal (@semiring.to_mul_zero_class.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) r (@measure_theory.volume.{u_1} α _inst_1 s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} α _inst_1 m
       (λ (a : α),
          @lattice.supr.{0 0} ennreal (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s)
            (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s),
               @has_one.one.{0} ennreal
                 (@zero_ne_one_class.to_has_one.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
    ?m_1

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal ?m_1
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @is_measurable.{u_1} α
    (@measure_theory.measure_space.to_measurable_space.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 m))
    s

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@has_mul.mul.{0} ennreal
       (@mul_zero_class.to_has_mul.{0} ennreal
          (@semiring.to_mul_zero_class.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@has_one.one.{0} ennreal
          (@zero_ne_one_class.to_has_one.{0} ennreal
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 m) s))
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204    assumption,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @is_measurable.{u_1} α
    (@measure_theory.measure_space.to_measurable_space.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 m))
    s

α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@has_mul.mul.{0} ennreal
       (@mul_zero_class.to_has_mul.{0} ennreal
          (@semiring.to_mul_zero_class.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@has_one.one.{0} ennreal
          (@zero_ne_one_class.to_has_one.{0} ennreal
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 m) s))
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@has_mul.mul.{0} ennreal
       (@mul_zero_class.to_has_mul.{0} ennreal
          (@semiring.to_mul_zero_class.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@has_one.one.{0} ennreal
          (@zero_ne_one_class.to_has_one.{0} ennreal
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 m) s))
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205    exact one_mul _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : monoid.{0} α] (a : α), @eq.{1} α (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@monoid.to_semigroup.{0} α _inst_1)) (@has_one.one.{0} α (@monoid.to_has_one.{0} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
m : @measure_theory.measure.{u_1} α _inst_1,
s : set.{u_1} α,
hs : @is_measurable.{u_1} α _inst_1 s
⊢ @eq.{1} ennreal
    (@has_mul.mul.{0} ennreal
       (@mul_zero_class.to_has_mul.{0} ennreal
          (@semiring.to_mul_zero_class.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@has_one.one.{0} ennreal
          (@zero_ne_one_class.to_has_one.{0} ennreal
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@measure_theory.volume.{u_1} α (@measure_theory.measure_space.mk.{u_1} α _inst_1 m) s))
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       m
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  lemma map_dirac {f : α → β} (hf : measurable f) (a : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    map f (dirac a) = dirac (f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 593, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 616, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 616, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], (α → β) → @measure_theory.measure.{u_1} α _inst_1 → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], α → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], α → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The dirac measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The dirac measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  measure.ext $ assume s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 257, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] {μ₁ μ₂ : @measure_theory.measure.{u_2} α _inst_1}, (∀ (s : set.{u_2} α), @is_measurable.{u_2} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ₁ s) (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ₂ s)) → @eq.{u_2+1} (@measure_theory.measure.{u_2} α _inst_1) μ₁ μ₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    by rw [dirac_apply (f a) hs, map_apply hf hs, dirac_apply a (hf s hs), set.mem_preimage]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.measure.dirac_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.map_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.dirac_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.mem_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 619, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 601, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 619, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 838, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] (a : α) {s : set.{u_2} α}, @is_measurable.{u_2} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) (@measure_theory.measure.dirac.{u_2} α _inst_1 a) s) (@lattice.supr.{0 0} ennreal (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) a s) (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (h : @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) a s), @has_one.one.{0} ennreal (@zero_ne_one_class.to_has_one.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β] {μ : @measure_theory.measure.{u_1} α _inst_1} {f : α → β}, @measurable.{u_1 u_2} α β _inst_1 _inst_2 f → ∀ {s : set.{u_2} β}, @is_measurable.{u_2} β _inst_2 s → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2) (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ) s) (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ (@set.preimage.{u_1 u_2} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (a : α) {s : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) (@measure_theory.measure.dirac.{u_1} α _inst_1 a) s) (@lattice.supr.{0 0} ennreal (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s) (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s), @has_one.one.{0} ennreal (@zero_ne_one_class.to_has_one.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measurable.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : set.{u_2} β} {a : α}, iff (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 u_2} α β f s)) (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f a) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f
          (@measure_theory.measure.dirac.{u_1} α _inst_1 a))
       s)
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.dirac.{u_2} β _inst_2 (f a))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f
          (@measure_theory.measure.dirac.{u_1} α _inst_1 a))
       s)
    (@lattice.supr.{0 0} ennreal (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f a) s)
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (h : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f a) s),
          @has_one.one.{0} ennreal
            (@zero_ne_one_class.to_has_one.{0} ennreal
               (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       (@measure_theory.measure.dirac.{u_1} α _inst_1 a)
       (@set.preimage.{u_1 u_2} α β f s))
    (@lattice.supr.{0 0} ennreal (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f a) s)
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (h : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f a) s),
          @has_one.one.{0} ennreal
            (@zero_ne_one_class.to_has_one.{0} ennreal
               (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@lattice.supr.{0 0} ennreal
       (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 u_2} α β f s))
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 u_2} α β f s)),
          @has_one.one.{0} ennreal
            (@zero_ne_one_class.to_has_one.{0} ennreal
               (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1))))
    (@lattice.supr.{0 0} ennreal (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f a) s)
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (h : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f a) s),
          @has_one.one.{0} ennreal
            (@zero_ne_one_class.to_has_one.{0} ennreal
               (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f
          (@measure_theory.measure.dirac.{u_1} α _inst_1 a))
       s)
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.dirac.{u_2} β _inst_2 (f a))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α,
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f
          (@measure_theory.measure.dirac.{u_1} α _inst_1 a))
       s)
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.dirac.{u_2} β _inst_2 (f a))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  lemma join_eq_bind (μ : measure (measure α)) : join μ = bind μ id :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_2} β _inst_2) → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  by rw [bind, map_id]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.map_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 606, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measurable_space.{?l_1} α] [_inst_2 : measurable_space.{?l_2} β], @measure_theory.measure.{?l_1} α _inst_1 → (α → @measure_theory.measure.{?l_2} β _inst_2) → @measure_theory.measure.{?l_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {μ : @measure_theory.measure.{u_1} α _inst_1}, @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.map.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α) μ) μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 μ)
    (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       _inst_1
       μ
       (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 μ)
    (@measure_theory.measure.join.{u_1} α _inst_1
       (@measure_theory.measure.map.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1))
          μ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 μ)
    (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       _inst_1
       μ
       (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 μ)
    (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       _inst_1
       μ
       (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  lemma join_map_map {f : α → β} (hf : measurable f) (μ : measure (measure α)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217    join (map (map f) μ) = map f (join μ) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 593, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 593, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 593, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], (α → β) → @measure_theory.measure.{u_1} α _inst_1 → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], (α → β) → @measure_theory.measure.{u_1} α _inst_1 → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], (α → β) → @measure_theory.measure.{u_1} α _inst_1 → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  measure.ext $ assume s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 257, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] {μ₁ μ₂ : @measure_theory.measure.{u_2} α _inst_1}, (∀ (s : set.{u_2} α), @is_measurable.{u_2} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ₁ s) (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ₂ s)) → @eq.{u_2+1} (@measure_theory.measure.{u_2} α _inst_1) μ₁ μ₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.join.{u_2} β _inst_2
          (@measure_theory.measure.map.{u_1 u_2} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.{u_2} β _inst_2)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
             (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f)
             μ))
       s)
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f
          (@measure_theory.measure.join.{u_1} α _inst_1 μ))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220      rw [join_apply hs, map_apply hf hs, join_apply,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.measure.join_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.map_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 601, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] {m : @measure_theory.measure.{u_2} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} α _inst_1)} {s : set.{u_2} α}, @is_measurable.{u_2} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) (@measure_theory.measure.join.{u_2} α _inst_1 m) s) (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} α _inst_1) m (λ (μ : @measure_theory.measure.{u_2} α _inst_1), @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β] {μ : @measure_theory.measure.{u_1} α _inst_1} {f : α → β}, @measurable.{u_1 u_2} α β _inst_1 _inst_2 f → ∀ {s : set.{u_2} β}, @is_measurable.{u_2} β _inst_2 s → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2) (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ) s) (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ (@set.preimage.{u_1 u_2} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {m : @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)} {s : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s → @eq.{1} ennreal (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 m) s) (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) m (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.join.{u_2} β _inst_2
          (@measure_theory.measure.map.{u_1 u_2} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.{u_2} β _inst_2)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
             (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f)
             μ))
       s)
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f
          (@measure_theory.measure.join.{u_1} α _inst_1 μ))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.{u_2} β _inst_2)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
          (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f)
          μ)
       (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            μ
            s))
    (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f
          (@measure_theory.measure.join.{u_1} α _inst_1 μ))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.{u_2} β _inst_2)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
          (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f)
          μ)
       (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            μ
            s))
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       (@measure_theory.measure.join.{u_1} α _inst_1 μ)
       (@set.preimage.{u_1 u_2} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.{u_2} β _inst_2)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
          (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f)
          μ)
       (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            μ
            s))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       μ
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            (@set.preimage.{u_1 u_2} α β f s)))

α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @is_measurable.{u_1} α _inst_1 (@set.preimage.{u_1 u_2} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221        integral_map (measurable_coe hs) (measurable_map f hf)],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='measure_theory.measure.integral_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.measurable_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure.measurable_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/integration.lean&#x27;, &#x27;line&#x27;: 1254, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] {m : @measure_theory.measure.{u_1} α _inst_1} [_inst_2 : measurable_space.{u_2} β] {f : β → ennreal} {g : α → β}, @measurable.{u_2 0} β ennreal _inst_2 (@borel.{0} ennreal ennreal.topological_space) f → @measurable.{u_1 u_2} α β _inst_1 _inst_2 g → @eq.{1} ennreal (@measure_theory.measure.integral.{u_2} β _inst_2 (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 g m) f) (@measure_theory.measure.integral.{u_1} α _inst_1 m (@function.comp.{u_1+1 u_2+1 1} α β ennreal f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : measurable_space.{u_2} α] {s : set.{u_2} α}, @is_measurable.{u_2} α _inst_1 s → @measurable.{u_2 0} (@measure_theory.measure.{u_2} α _inst_1) ennreal (@measure_theory.measure.measurable_space.{u_2} α _inst_1) (@borel.{0} ennreal ennreal.topological_space) (λ (μ : @measure_theory.measure.{u_2} α _inst_1), @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_2} α _inst_1) μ s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β] (f : α → β), @measurable.{u_1 u_2} α β _inst_1 _inst_2 f → @measurable.{u_1 u_2} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.{u_2} β _inst_2) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_2} β _inst_2) (λ (μ : @measure_theory.measure.{u_1} α _inst_1), @measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_2} (@measure_theory.measure.{u_2} β _inst_2)
       (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
       (@measure_theory.measure.map.{u_1 u_2} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.{u_2} β _inst_2)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_2} β _inst_2)
          (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f)
          μ)
       (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            μ
            s))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       μ
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            (@set.preimage.{u_1 u_2} α β f s)))

α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @is_measurable.{u_1} α _inst_1 (@set.preimage.{u_1 u_2} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       μ
       (@function.comp.{u_1+1 u_2+1 1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.{u_2} β _inst_2)
          ennreal
          (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
             @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
               (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
               μ
               s)
          (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
             @measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       μ
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            (@set.preimage.{u_1 u_2} α β f s)))

α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @is_measurable.{u_1} α _inst_1 (@set.preimage.{u_1 u_2} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222      { congr, funext ν, exact map_apply hf hs },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='measure_theory.measure.map_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 601, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β] {μ : @measure_theory.measure.{u_1} α _inst_1} {f : α → β}, @measurable.{u_1 u_2} α β _inst_1 _inst_2 f → ∀ {s : set.{u_2} β}, @is_measurable.{u_2} β _inst_2 s → @eq.{1} ennreal (@coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2) (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2) (@measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ) s) (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1) μ (@set.preimage.{u_1 u_2} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       μ
       (@function.comp.{u_1+1 u_2+1 1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.{u_2} β _inst_2)
          ennreal
          (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
             @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
               (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
               μ
               s)
          (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
             @measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       μ
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            (@set.preimage.{u_1 u_2} α β f s)))

α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @is_measurable.{u_1} α _inst_1 (@set.preimage.{u_1 u_2} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{1} ennreal
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       μ
       (@function.comp.{u_1+1 u_2+1 1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.{u_2} β _inst_2)
          ennreal
          (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
             @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
               (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
               μ
               s)
          (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
             @measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ)))
    (@measure_theory.measure.integral.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       μ
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
            μ
            (@set.preimage.{u_1 u_2} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @eq.{(max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1 → ennreal)
    (@function.comp.{u_1+1 u_2+1 1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.{u_2} β _inst_2)
       ennreal
       (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            μ
            s)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ))
    (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
       @coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
         μ
         (@set.preimage.{u_1 u_2} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s,
ν : @measure_theory.measure.{u_1} α _inst_1
⊢ @eq.{1} ennreal
    (@function.comp.{u_1+1 u_2+1 1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.{u_2} β _inst_2)
       ennreal
       (λ (μ : @measure_theory.measure.{u_2} β _inst_2),
          @coe_fn.{u_2+1 (max (u_2+1) 1)} (@measure_theory.measure.{u_2} β _inst_2)
            (@measure_theory.measure.has_coe_to_fun.{u_2} β _inst_2)
            μ
            s)
       (λ (μ : @measure_theory.measure.{u_1} α _inst_1),
          @measure_theory.measure.map.{u_1 u_2} α β _inst_1 _inst_2 f μ)
       ν)
    (@coe_fn.{u_1+1 (max (u_1+1) 1)} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.has_coe_to_fun.{u_1} α _inst_1)
       ν
       (@set.preimage.{u_1 u_2} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @is_measurable.{u_1} α _inst_1 (@set.preimage.{u_1 u_2} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223      exact hf s hs</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @is_measurable.{u_1} α _inst_1 (@set.preimage.{u_1 u_2} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224    end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : measurable_space.{u_1} α,
_inst_2 : measurable_space.{u_2} β,
f : α → β,
hf : @measurable.{u_1 u_2} α β _inst_1 _inst_2 f,
μ :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1),
s : set.{u_2} β,
hs : @is_measurable.{u_2} β _inst_2 s
⊢ @is_measurable.{u_1} α _inst_1 (@set.preimage.{u_1 u_2} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  lemma join_map_join (μ : measure (measure (measure α))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227    join (map join μ) = join (join μ) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 593, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], (α → β) → @measure_theory.measure.{u_1} α _inst_1 → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)) (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)) (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.join.{u_1} α _inst_1
       (@measure_theory.measure.map.{u_1 u_1}
          (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
          (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          (@measure_theory.measure.join.{u_1} α _inst_1)
          μ))
    (@measure_theory.measure.join.{u_1} α _inst_1
       (@measure_theory.measure.join.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          μ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    show bind μ join = join (join μ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_1} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_1} β _inst_2) → @measure_theory.measure.{u_1} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)) (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.join.{u_1} α _inst_1
       (@measure_theory.measure.map.{u_1 u_1}
          (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
          (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          (@measure_theory.measure.join.{u_1} α _inst_1)
          μ))
    (@measure_theory.measure.join.{u_1} α _inst_1
       (@measure_theory.measure.join.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          μ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.bind.{u_1 u_1}
       (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       α
       (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       _inst_1
       μ
       (@measure_theory.measure.join.{u_1} α _inst_1))
    (@measure_theory.measure.join.{u_1} α _inst_1
       (@measure_theory.measure.join.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          μ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230    rw [join_eq_bind, join_eq_bind, bind_bind measurable_id measurable_id],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='measure_theory.measure.join_eq_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join_eq_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.bind_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='measurable_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 213, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 213, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 183, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (μ : @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)), @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 μ) (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α (@measure_theory.measure.measurable_space.{u_1} α _inst_1) _inst_1 μ (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (μ : @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)), @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 μ) (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α (@measure_theory.measure.measurable_space.{u_1} α _inst_1) _inst_1 μ (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_1} β] {γ : Type u_1} [_inst_3 : measurable_space.{u_1} γ] {m : @measure_theory.measure.{u_1} α _inst_1} {f : α → @measure_theory.measure.{u_1} β _inst_2} {g : β → @measure_theory.measure.{u_1} γ _inst_3}, @measurable.{u_1 u_1} α (@measure_theory.measure.{u_1} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_1} β _inst_2) f → @measurable.{u_1 u_1} β (@measure_theory.measure.{u_1} γ _inst_3) _inst_2 (@measure_theory.measure.measurable_space.{u_1} γ _inst_3) g → @eq.{u_1+1} (@measure_theory.measure.{u_1} γ _inst_3) (@measure_theory.measure.bind.{u_1 u_1} β γ _inst_2 _inst_3 (@measure_theory.measure.bind.{u_1 u_1} α β _inst_1 _inst_2 m f) g) (@measure_theory.measure.bind.{u_1 u_1} α γ _inst_1 _inst_3 m (λ (a : α), @measure_theory.measure.bind.{u_1 u_1} β γ _inst_2 _inst_3 (f a) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measurable.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.bind.{u_1 u_1}
       (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       α
       (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       _inst_1
       μ
       (@measure_theory.measure.join.{u_1} α _inst_1))
    (@measure_theory.measure.join.{u_1} α _inst_1
       (@measure_theory.measure.join.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          μ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.bind.{u_1 u_1}
       (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       α
       (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       _inst_1
       μ
       (@measure_theory.measure.join.{u_1} α _inst_1))
    (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       _inst_1
       (@measure_theory.measure.join.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          μ)
       (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.bind.{u_1 u_1}
       (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       α
       (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       _inst_1
       μ
       (@measure_theory.measure.join.{u_1} α _inst_1))
    (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       _inst_1
       (@measure_theory.measure.bind.{u_1 u_1}
          (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
          (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
          μ
          (@id.{u_1+1}
             (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                (@measure_theory.measure.measurable_space.{u_1} α _inst_1))))
       (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.bind.{u_1 u_1}
       (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       α
       (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       _inst_1
       μ
       (@measure_theory.measure.join.{u_1} α _inst_1))
    (@measure_theory.measure.bind.{u_1 u_1}
       (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       α
       (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       _inst_1
       μ
       (λ
        (a :
          @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)),
          @measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            _inst_1
            (@id.{u_1+1}
               (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                  (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
               a)
            (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231    apply congr_arg (bind μ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} {a₁ a₂ : α} (f : α → β), @eq.{u_1+1} α a₁ a₂ → @eq.{u_1+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_1} β], @measure_theory.measure.{u_1} α _inst_1 → (α → @measure_theory.measure.{u_1} β _inst_2) → @measure_theory.measure.{u_1} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)) (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Monadic bind on `measure`, only works in the category of measurable spaces and measurable
functions. When the function `f` is not measurable the result is not well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.bind.{u_1 u_1}
       (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       α
       (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       _inst_1
       μ
       (@measure_theory.measure.join.{u_1} α _inst_1))
    (@measure_theory.measure.bind.{u_1 u_1}
       (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       α
       (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
          (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
       _inst_1
       μ
       (λ
        (a :
          @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)),
          @measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
            (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
            _inst_1
            (@id.{u_1+1}
               (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
                  (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
               a)
            (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1) →
     @measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.join.{u_1} α _inst_1)
    (λ
     (a :
       @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)),
       @measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         _inst_1
         (@id.{u_1+1}
            (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
            a)
         (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232    funext ν,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
⊢ @eq.{u_1+1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1) →
     @measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.join.{u_1} α _inst_1)
    (λ
     (a :
       @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)),
       @measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
         (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
         _inst_1
         (@id.{u_1+1}
            (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
               (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
            a)
         (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)),
ν :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 ν)
    (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       _inst_1
       (@id.{u_1+1}
          (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
          ν)
       (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233    exact join_eq_bind ν</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.measure.join_eq_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ν'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 213, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (μ : @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)), @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 μ) (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α (@measure_theory.measure.measurable_space.{u_1} α _inst_1) _inst_1 μ (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : measurable_space.{u_1} α,
μ :
  @measure_theory.measure.{u_1}
    (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
    (@measure_theory.measure.measurable_space.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)),
ν :
  @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
    (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
⊢ @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 ν)
    (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α
       (@measure_theory.measure.measurable_space.{u_1} α _inst_1)
       _inst_1
       (@id.{u_1+1}
          (@measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1)
             (@measure_theory.measure.measurable_space.{u_1} α _inst_1))
          ν)
       (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  lemma join_map_dirac (μ : measure α) : join (map dirac μ) = μ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 593, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 616, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_2} β], (α → β) → @measure_theory.measure.{u_1} α _inst_1 → @measure_theory.measure.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], α → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The dirac measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  dirac_bind</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.measure.dirac_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 197, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {m : @measure_theory.measure.{u_1} α _inst_1}, @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.bind.{u_1 u_1} α α _inst_1 _inst_1 m (@measure_theory.measure.dirac.{u_1} α _inst_1)) m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  lemma join_dirac (μ : measure α) : join (dirac μ) = μ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure.join'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 616, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1) → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], α → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title=' Monadic join on `measure` in the category of measurable spaces and measurable
functions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The dirac measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  eq.trans (join_eq_bind (dirac μ)) (bind_dirac measurable_id _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.join_eq_bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.measure.dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.measure.bind_dirac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measurable_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 213, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 616, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a b c : α}, @eq.{u_1+1} α a b → @eq.{u_1+1} α b c → @eq.{u_1+1} α a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] (μ : @measure_theory.measure.{u_1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.measurable_space.{u_1} α _inst_1)), @eq.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1) (@measure_theory.measure.join.{u_1} α _inst_1 μ) (@measure_theory.measure.bind.{u_1 u_1} (@measure_theory.measure.{u_1} α _inst_1) α (@measure_theory.measure.measurable_space.{u_1} α _inst_1) _inst_1 μ (@id.{u_1+1} (@measure_theory.measure.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], α → @measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.measure.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : measurable_space.{u_1} α] [_inst_2 : measurable_space.{u_1} β] {f : α → @measure_theory.measure.{u_1} β _inst_2}, @measurable.{u_1 u_1} α (@measure_theory.measure.{u_1} β _inst_2) _inst_1 (@measure_theory.measure.measurable_space.{u_1} β _inst_2) f → ∀ (a : α), @eq.{u_1+1} (@measure_theory.measure.{u_1} β _inst_2) (@measure_theory.measure.bind.{u_1 u_1} α β _inst_1 _inst_2 (@measure_theory.measure.dirac.{u_1} α _inst_1 a) f) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @measurable.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The dirac measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  end measure</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  end measure_theory</code></pre>
</body>