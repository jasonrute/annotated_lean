<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johannes Hölzl, Mario Carneiro</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Subtype of open subsets in a topological space.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import topology.bases topology.separation</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/bases.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open filter lattice</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  variables {α : Type*} {β : Type*} [topological_space α] [topological_space β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  namespace topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  variable (α)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  /-- The type of open subsets of a topological space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  def opens := {s : set α // _root_.is_open s}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  /-- The type of closed subsets of a topological space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  def closeds := {s : set α // is_closed s}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  /-- The type of non-empty compact subsets of a topological space. The</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  non-emptiness will be useful in metric spaces, as we will be able to put</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  a distance (and not merely an edistance) on this space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  def nonempty_compacts := {s : set α // s.nonempty ∧ compact s}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title=' The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A set `s` is compact if for every filter `f` that contains `s`,
   every set of `f` also meets every neighborhood of some `a ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  section nonempty_compacts</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  open topological_space set</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  variable {α}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  instance nonempty_compacts.to_compact_space {p : nonempty_compacts α} : compact_space p.val :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='blue'><a title='topological_space.nonempty_compacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='compact_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;line&#x27;: 24, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.nonempty_compacts.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title=' The type of non-empty compact subsets of a topological space. The
non-emptiness will be useful in metric spaces, as we will be able to put
a distance (and not merely an edistance) on this space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Type class for compact spaces. Separation is sometimes included in the definition, especially
in the French literature, but we do not include it here.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  ⟨compact_iff_compact_univ.1 p.property.2⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='compact_iff_compact_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 329, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, iff (@compact.{u} α _inst_1 s) (@compact.{u} (@subtype.{u+1} α s) (@subtype.topological_space.{u} α s _inst_1) (@set.univ.{u} (@subtype.{u+1} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_space.nonempty_compacts.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} (c : @subtype.{(max (u_1+1) 1)} α p), p (@subtype.val.{(max (u_1+1) 1)} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  instance nonempty_compacts.to_nonempty {p : nonempty_compacts α} : nonempty p.val :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='topological_space.nonempty_compacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;line&#x27;: 24, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.nonempty_compacts.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title=' The type of non-empty compact subsets of a topological space. The
non-emptiness will be useful in metric spaces, as we will be able to put
a distance (and not merely an edistance) on this space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  p.property.1.to_subtype</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.nonempty.to_subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 186, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.nonempty_compacts.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} (c : @subtype.{(max (u_1+1) 1)} α p), p (@subtype.val.{(max (u_1+1) 1)} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {s : set.{u_1} α}, @set.nonempty.{u_1} α s → nonempty.{(max 1 (u_1+1))} (@coe_sort.{(max (u_1+1) 1) (max 1 (u_1+1))+1} (set.{u_1} α) (@set.has_coe_to_sort.{u_1} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  /-- Associate to a nonempty compact subset the corresponding closed subset -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  def nonempty_compacts.to_closeds [t2_space α] (s : nonempty_compacts α) : closeds α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='topological_space.nonempty_compacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.closeds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 24, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title=' The type of non-empty compact subsets of a topological space. The
non-emptiness will be useful in metric spaces, as we will be able to put
a distance (and not merely an edistance) on this space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The type of closed subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  ⟨s.val, closed_of_compact _ s.property.2⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closed_of_compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.nonempty_compacts.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_3 : @t2_space.{u} α _inst_1] (s : set.{u} α), @compact.{u} α _inst_1 s → @is_closed.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_space.nonempty_compacts.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} (c : @subtype.{(max (u_1+1) 1)} α p), p (@subtype.val.{(max (u_1+1) 1)} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  end nonempty_compacts</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  variable {α}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  namespace opens</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  instance : has_coe (opens α) (set α) := { coe := subtype.val }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort v → Sort (max 1 (imax u v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {α : Sort u} {p : α → Prop}, @subtype.{u} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  instance : has_subset (opens α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  { subset := λ U V, U.val ⊆ V.val }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  instance : has_mem α (opens α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='out_param.{u+2} (Type u) → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  { mem := λ a U, a ∈ U.val }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  @[ext] lemma ext {U V : opens α} (h : U.val = V.val) : U = V := subtype.ext.mpr h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='subtype.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/subtype.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} {a1 a2 : @subtype.{(max (u_1+1) 1)} α (λ (x : α), p x)}, iff (@eq.{(max (u_1+1) 1)} (@subtype.{(max (u_1+1) 1)} α (λ (x : α), p x)) a1 a2) (@eq.{(max (u_1+1) 1)} α (@subtype.val.{(max (u_1+1) 1)} α (λ (x : α), p x) a1) (@subtype.val.{(max (u_1+1) 1)} α (λ (x : α), p x) a2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{(max (u_1+1) 1)} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  instance : partial_order (opens α) := subtype.partial_order _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='subtype.partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [i : partial_order.{u_1} α] (p : α → Prop), partial_order.{u_1} (@subtype.{u_1+1} α p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  def interior (s : set α) : opens α := ⟨interior s, is_open_interior⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 186, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, @is_open.{u} α _inst_1 (@interior.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  lemma gc : galois_connection (subtype.val : opens α → set α) interior :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='galois_connection'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens.interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/galois_connection.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : preorder.{u} α] [_inst_2 : preorder.{v} β], (α → β) → (β → α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {p : α → Prop}, @subtype.{u} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} α → @topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A Galois connection is a pair of functions `l` and `u` satisfying
 `l a ≤ b ↔ a ≤ u b`. They are closely connected to adjoint functors
 in category theory.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  λ U s, ⟨λ h, interior_maximal h U.property, λ h, le_trans h interior_subset⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='interior_maximal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='interior_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 192, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_le.le.{u_1} (set.{u_1} α) (@preorder.to_has_le.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s t : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) t s → @is_open.{u_1} α _inst_1 t → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) t (@interior.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (set.{u_1} α) (@preorder.to_has_le.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} (c : @subtype.{(max (u_1+1) 1)} α p), p (@subtype.val.{(max (u_1+1) 1)} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_le.le.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (@preorder.to_has_le.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (@subtype.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) U (@topological_space.opens.interior.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : preorder.{u_1} α] {a b c : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α _inst_1) a b → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α _inst_1) b c → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (@preorder.to_has_le.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (@subtype.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) U (@topological_space.opens.interior.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@interior.{u_1} α _inst_1 s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  def gi : @galois_insertion (order_dual (set α)) (order_dual (opens α)) _ _ interior (subtype.val) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='galois_insertion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='topological_space.opens.interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/galois_connection.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : preorder.{u_1} α] [_inst_2 : preorder.{u_2} β], (α → β) → (β → α) → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} α → @topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {p : α → Prop}, @subtype.{u} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' A Galois insertion is a Galois connection where `l ∘ u = id`. It also contains a constructive
choice function, to give better definitional equalities when lifting order structures.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  { choice := λ s hs, ⟨s, interior_eq_iff_open.mp $ le_antisymm interior_subset hs⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='interior_eq_iff_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='interior_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='order_dual.{u_1} (set.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@preorder.to_has_le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@order_dual.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) (@topological_space.opens.interior.{u_1} α _inst_1 s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='order_dual.{u_1} (set.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s : set.{u_1} α}, iff (@eq.{(max (u_1+1) 1)} (set.{u_1} α) (@interior.{u_1} α _inst_1 s) s) (@is_open.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) b a → @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@interior.{u} α _inst_1 s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@preorder.to_has_le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@order_dual.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) (@topological_space.opens.interior.{u_1} α _inst_1 s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    gc := gc.dual,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space.opens.gc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='galois_connection.dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/galois_connection.lean&#x27;, &#x27;line&#x27;: 165, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α], @galois_connection.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (@topological_space.opens.interior.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} [pα : preorder.{u_1} α] [pβ : preorder.{u_1} β] {l : α → β} {u : β → α}, @galois_connection.{u_1 u_1} α β pα pβ l u → @galois_connection.{u_1 u_1} (order_dual.{u_1} β) (order_dual.{u_1} α) (@order_dual.preorder.{u_1} β pβ) (@order_dual.preorder.{u_1} α pα) u l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    le_l_u := λ _, interior_subset,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='interior_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@interior.{u} α _inst_1 s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    choice_eq := λ s hs, le_antisymm interior_subset hs }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='interior_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='order_dual.{u_1} (set.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@preorder.to_has_le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@order_dual.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) (@topological_space.opens.interior.{u_1} α _inst_1 s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) b a → @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@interior.{u} α _inst_1 s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@preorder.to_has_le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@order_dual.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) (@topological_space.opens.interior.{u_1} α _inst_1 s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  @[simp] lemma gi_choice_val {s : order_dual (set α)} {hs} : (gi.choice s hs).val = s := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='topological_space.opens.gi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='galois_insertion.choice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 61, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/galois_connection.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], @galois_insertion.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α)) (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@order_dual.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))) (@order_dual.preorder.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@partial_order.to_preorder.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.partial_order.{u_1} α _inst_1))) (@topological_space.opens.interior.{u_1} α _inst_1) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1} [_inst_1 : preorder.{u_1} α] [_inst_2 : preorder.{u_1} β] {l : α → β} {u : β → α}, @galois_insertion.{u_1 u_1} α β _inst_1 _inst_2 l u → Π (x : α), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α _inst_1) (u (l x)) x → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='order_dual.{u_1} (set.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@preorder.to_has_le.{u_1} (order_dual.{u_1} (set.{u_1} α)) (@order_dual.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) (@topological_space.opens.interior.{u_1} α _inst_1 s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='order_dual.{u_1} (set.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{(max (u_1+1) 1)} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  instance : complete_lattice (opens α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lattice.complete_lattice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A complete lattice is a bounded lattice which
 has suprema and infima for every subset.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  complete_lattice.copy</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.complete_lattice.copy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} (c : lattice.complete_lattice.{u} α) (le : α → α → Prop), @eq.{(max (u+1) 1)} (α → α → Prop) le (@lattice.complete_lattice.le.{u} α c) → Π (top : α), @eq.{u+1} α top (@lattice.complete_lattice.top.{u} α c) → Π (bot : α), @eq.{u+1} α bot (@lattice.complete_lattice.bot.{u} α c) → Π (sup : α → α → α), @eq.{u+1} (α → α → α) sup (@lattice.complete_lattice.sup.{u} α c) → Π (inf : α → α → α), @eq.{u+1} (α → α → α) inf (@lattice.complete_lattice.inf.{u} α c) → Π (Sup : set.{u} α → α), @eq.{(max (u+1) 1)} (set.{u} α → α) Sup (@lattice.complete_lattice.Sup.{u} α c) → Π (Inf : set.{u} α → α), @eq.{(max (u+1) 1)} (set.{u} α → α) Inf (@lattice.complete_lattice.Inf.{u} α c) → lattice.complete_lattice.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  (@order_dual.lattice.complete_lattice _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='order_dual.lattice.complete_lattice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 818, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : lattice.complete_lattice.{u_1} α], lattice.complete_lattice.{u_1} (order_dual.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    (@galois_insertion.lift_complete_lattice</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='galois_insertion.lift_complete_lattice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/galois_connection.lean&#x27;, &#x27;line&#x27;: 260, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : partial_order.{v} β] {l : α → β} {u : β → α} [_inst_2 : lattice.complete_lattice.{u} α], @galois_insertion.{u v} α β (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_2)))) (@partial_order.to_preorder.{v} β _inst_1) l u → lattice.complete_lattice.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Lift all suprema and infima along a Galois insertion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73      (order_dual (set α)) (order_dual (opens α)) _ interior (subtype.val : opens α → set α) _ gi))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space.opens.interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.opens.gi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 61, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} α → @topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {p : α → Prop}, @subtype.{u} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], @galois_insertion.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α)) (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@order_dual.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))) (@order_dual.preorder.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@partial_order.to_preorder.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.partial_order.{u_1} α _inst_1))) (@topological_space.opens.interior.{u_1} α _inst_1) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  /- le  -/ (λ U V, U.1 ⊆ V.1) rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  /- top -/ ⟨set.univ, _root_.is_open_univ⟩ (subtype.ext.mpr interior_univ.symm)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='subtype.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='interior_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/subtype.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α], @is_open.{u} α t (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} {a1 a2 : @subtype.{(max (u_1+1) 1)} α (λ (x : α), p x)}, iff (@eq.{(max (u_1+1) 1)} (@subtype.{(max (u_1+1) 1)} α (λ (x : α), p x)) a1 a2) (@eq.{(max (u_1+1) 1)} α (@subtype.val.{(max (u_1+1) 1)} α (λ (x : α), p x) a1) (@subtype.val.{(max (u_1+1) 1)} α (λ (x : α), p x) a2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α], @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@interior.{u_1} α _inst_1 (@set.univ.{u_1} α)) (@set.univ.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, @eq.{(max (u_1+1) 1)} α a b → @eq.{(max (u_1+1) 1)} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  /- bot -/ ⟨∅, is_open_empty⟩ rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (α : Type u_1) [c : has_emptyc.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α], @is_open.{u} α _inst_1 (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  /- sup -/ (λ U V, ⟨U.1 ∪ V.1, _root_.is_open_union U.2 V.2⟩) rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_union.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {s₁ s₂ : set.{u} α} [_inst_1 : topological_space.{u} α], @is_open.{u} α _inst_1 s₁ → @is_open.{u} α _inst_1 s₂ → @is_open.{u} α _inst_1 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} (c : @subtype.{(max (u_1+1) 1)} α p), p (@subtype.val.{(max (u_1+1) 1)} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} (c : @subtype.{(max (u_1+1) 1)} α p), p (@subtype.val.{(max (u_1+1) 1)} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  /- inf -/ (λ U V, ⟨U.1 ∩ V.1, _root_.is_open_inter U.2 V.2⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_inter.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {s₁ s₂ : set.{u} α} [t : topological_space.{u} α], @is_open.{u} α t s₁ → @is_open.{u} α t s₂ → @is_open.{u} α t (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} (c : @subtype.{(max (u_1+1) 1)} α p), p (@subtype.val.{(max (u_1+1) 1)} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} (c : @subtype.{(max (u_1+1) 1)} α p), p (@subtype.val.{(max (u_1+1) 1)} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α
⊢ @eq.{u_1+1}
    (@topological_space.opens.{u_1} α _inst_1 →
     @topological_space.opens.{u_1} α _inst_1 → @topological_space.opens.{u_1} α _inst_1)
    (λ (U V : @topological_space.opens.{u_1} α _inst_1),
       @subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
         (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))
         (@is_open_inter.{u_1} α
            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
            _inst_1
            (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
            (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
               V)))
    (@lattice.complete_lattice.inf.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
          (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
             (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                (@topological_space.opens.partial_order.{u_1} α _inst_1))
             (@topological_space.opens.interior.{u_1} α _inst_1)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
             (@topological_space.opens.gi.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    funext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α
⊢ @eq.{u_1+1}
    (@topological_space.opens.{u_1} α _inst_1 →
     @topological_space.opens.{u_1} α _inst_1 → @topological_space.opens.{u_1} α _inst_1)
    (λ (U V : @topological_space.opens.{u_1} α _inst_1),
       @subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
         (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))
         (@is_open_inter.{u_1} α
            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
            _inst_1
            (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
            (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
               V)))
    (@lattice.complete_lattice.inf.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
          (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
             (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                (@topological_space.opens.partial_order.{u_1} α _inst_1))
             (@topological_space.opens.interior.{u_1} α _inst_1)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
             (@topological_space.opens.gi.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U V : @topological_space.opens.{u_1} α _inst_1
⊢ @eq.{(max (u_1+1) 1)}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))
       (@is_open_inter.{u_1} α
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
          _inst_1
          (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
          (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)))
    (@lattice.complete_lattice.inf.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
          (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
             (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                (@topological_space.opens.partial_order.{u_1} α _inst_1))
             (@topological_space.opens.interior.{u_1} α _inst_1)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
             (@topological_space.opens.gi.{u_1} α _inst_1)))
       U
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    apply subtype.ext.mpr,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U V : @topological_space.opens.{u_1} α _inst_1
⊢ @eq.{(max (u_1+1) 1)}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))
       (@is_open_inter.{u_1} α
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
          _inst_1
          (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
          (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)))
    (@lattice.complete_lattice.inf.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
          (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
             (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                (@topological_space.opens.partial_order.{u_1} α _inst_1))
             (@topological_space.opens.interior.{u_1} α _inst_1)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
             (@topological_space.opens.gi.{u_1} α _inst_1)))
       U
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U V : @topological_space.opens.{u_1} α _inst_1
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
          (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))
          (@is_open_inter.{u_1} α
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
             _inst_1
             (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                V))))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@lattice.complete_lattice.inf.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
                (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.partial_order.{u_1} α _inst_1))
                (@topological_space.opens.interior.{u_1} α _inst_1)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
                (@topological_space.opens.gi.{u_1} α _inst_1)))
          U
          V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    symmetry,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1269, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='symmetry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U V : @topological_space.opens.{u_1} α _inst_1
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
          (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))
          (@is_open_inter.{u_1} α
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
             _inst_1
             (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                V))))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@lattice.complete_lattice.inf.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
                (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.partial_order.{u_1} α _inst_1))
                (@topological_space.opens.interior.{u_1} α _inst_1)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
                (@topological_space.opens.gi.{u_1} α _inst_1)))
          U
          V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U V : @topological_space.opens.{u_1} α _inst_1
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@lattice.complete_lattice.inf.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
                (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.partial_order.{u_1} α _inst_1))
                (@topological_space.opens.interior.{u_1} α _inst_1)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
                (@topological_space.opens.gi.{u_1} α _inst_1)))
          U
          V))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
          (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))
          (@is_open_inter.{u_1} α
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
             _inst_1
             (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                V))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    apply interior_eq_of_open,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='interior_eq_of_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s : set.{u_1} α}, @is_open.{u_1} α _inst_1 s → @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@interior.{u_1} α _inst_1 s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U V : @topological_space.opens.{u_1} α _inst_1
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@lattice.complete_lattice.inf.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
                (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.partial_order.{u_1} α _inst_1))
                (@topological_space.opens.interior.{u_1} α _inst_1)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
                (@topological_space.opens.gi.{u_1} α _inst_1)))
          U
          V))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
          (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))
          (@is_open_inter.{u_1} α
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
             _inst_1
             (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
             (@subtype.property.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                V))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U V : @topological_space.opens.{u_1} α _inst_1
⊢ @is_open.{u_1} α _inst_1
    (@lattice.has_sup.sup.{u_1} (order_dual.{u_1} (set.{u_1} α))
       (@lattice.semilattice_sup.to_has_sup.{u_1} (order_dual.{u_1} (set.{u_1} α))
          (@lattice.lattice.to_semilattice_sup.{u_1} (order_dual.{u_1} (set.{u_1} α))
             (@lattice.bounded_lattice.to_lattice.{u_1} (order_dual.{u_1} (set.{u_1} α))
                (@lattice.complete_lattice.to_bounded_lattice.{u_1} (order_dual.{u_1} (set.{u_1} α))
                   (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    exact (_root_.is_open_inter U.2 V.2),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {s₁ s₂ : set.{u_1} α} [t : topological_space.{u_1} α], @is_open.{u_1} α t s₁ → @is_open.{u_1} α t s₂ → @is_open.{u_1} α t (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U V : @topological_space.opens.{u_1} α _inst_1
⊢ @is_open.{u_1} α _inst_1
    (@lattice.has_sup.sup.{u_1} (order_dual.{u_1} (set.{u_1} α))
       (@lattice.semilattice_sup.to_has_sup.{u_1} (order_dual.{u_1} (set.{u_1} α))
          (@lattice.lattice.to_semilattice_sup.{u_1} (order_dual.{u_1} (set.{u_1} α))
             (@lattice.bounded_lattice.to_lattice.{u_1} (order_dual.{u_1} (set.{u_1} α))
                (@lattice.complete_lattice.to_bounded_lattice.{u_1} (order_dual.{u_1} (set.{u_1} α))
                   (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  /- Sup -/ (λ Us, ⟨⋃₀ (subtype.val &#x27;&#x27; Us), _root_.is_open_sUnion $ λ U hU,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='Us'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Us'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} (set.{u_1} α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {p : α → Prop}, @subtype.{u} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, (α → β) → set.{u_1} α → set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α] {s : set.{u} (set.{u} α)}, (∀ (t_1 : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t_1 s → @is_open.{u} α t t_1) → @is_open.{u} α t (@set.sUnion.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U (@set.image.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) Us)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  by { rcases hU with ⟨⟨V, hV⟩, h, h&#x27;⟩, dsimp at h&#x27;, subst h&#x27;, exact hV}⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U (@set.image.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) Us)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (set.{u_1} α) V U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_1} α _inst_1 V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
U : set.{u_1} α,
hU :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       Us)
⊢ @is_open.{u_1} α _inst_1 U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
U V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
h :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
h&#x27; :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV))
    U
⊢ @is_open.{u_1} α _inst_1 U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
U V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
h :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
h&#x27; : @eq.{u_1+1} (set.{u_1} α) V U
⊢ @is_open.{u_1} α _inst_1 U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
h :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us
⊢ @is_open.{u_1} α _inst_1 V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α
⊢ @eq.{(max (u_1+1) 1)}
    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1) → @topological_space.opens.{u_1} α _inst_1)
    (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
       @subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
         (@set.sUnion.{u_1} α
            (@set.image.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1} α)
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               Us))
         (@is_open_sUnion.{u_1} α _inst_1
            (@set.image.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1} α)
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               Us)
            (λ (U : set.{u_1} α)
             (hU :
               @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U
                 (@set.image.{u_1 u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                    (set.{u_1} α)
                    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                    Us)),
               @Exists.dcases_on.{u_1+1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (λ
                  (a : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                    and
                      (@has_mem.mem.{u_1 u_1}
                         (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                         (set.{u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                         (@set.has_mem.{u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                         a
                         Us)
                      (@eq.{u_1+1} (set.{u_1} α)
                         (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                            a)
                         U))
                 (λ
                  (hU :
                    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                      U
                      (@set.image.{u_1 u_1}
                         (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                         (set.{u_1} α)
                         (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                         Us)), @is_open.{u_1} α _inst_1 U)
                 hU
                 (λ
                  (hU_w :
                    @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                  (hU_h :
                    and
                      (@has_mem.mem.{u_1 u_1}
                         (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                         (set.{u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                         (@set.has_mem.{u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                         hU_w
                         Us)
                      (@eq.{u_1+1} (set.{u_1} α)
                         (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                            hU_w)
                         U)),
                    @subtype.cases_on.{0 (max (u_1+1) 1)} (set.{u_1} α)
                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                      (λ
                       (hU_w :
                         @subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                           (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                         and
                           (@has_mem.mem.{u_1 u_1}
                              (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                              (set.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@set.has_mem.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              hU_w
                              Us)
                           (@eq.{u_1+1} (set.{u_1} α)
                              (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 hU_w)
                              U) →
                         @is_open.{u_1} α _inst_1 U)
                      hU_w
                      (λ (V : set.{u_1} α) (hV : @is_open.{u_1} α _inst_1 V)
                       (hU_h :
                         and
                           (@has_mem.mem.{u_1 u_1}
                              (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                              (set.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@set.has_mem.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 V
                                 hV)
                              Us)
                           (@eq.{u_1+1} (set.{u_1} α)
                              (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV))
                              U)),
                         @and.dcases_on.{0}
                           (@has_mem.mem.{u_1 u_1}
                              (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                              (set.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@set.has_mem.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 V
                                 hV)
                              Us)
                           (@eq.{u_1+1} (set.{u_1} α)
                              (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV))
                              U)
                           (λ
                            (hU_h :
                              and
                                (@has_mem.mem.{u_1 u_1}
                                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                   (set.{u_1}
                                      (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                         (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                   (@set.has_mem.{u_1}
                                      (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                         (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                   (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                      V
                                      hV)
                                   Us)
                                (@eq.{u_1+1} (set.{u_1} α)
                                   (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                      (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                         (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                         V
                                         hV))
                                   U)), @is_open.{u_1} α _inst_1 U)
                           hU_h
                           (λ
                            (h :
                              @has_mem.mem.{u_1 u_1}
                                (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                   (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                (set.{u_1}
                                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                (@set.has_mem.{u_1}
                                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                   (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                   V
                                   hV)
                                Us)
                            (h&#x27; :
                              @eq.{u_1+1} (set.{u_1} α)
                                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                   (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                   (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                      V
                                      hV))
                                U),
                              @id.{0}
                                (@eq.{u_1+1} (set.{u_1} α)
                                   (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                      (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                         (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                         V
                                         hV))
                                   U →
                                 @is_open.{u_1} α _inst_1 U)
                                (λ (h&#x27; : @eq.{u_1+1} (set.{u_1} α) V U),
                                   @eq.rec.{0 (max (u_1+1) 1)} (set.{u_1} α) V
                                     (λ (U : set.{u_1} α), @is_open.{u_1} α _inst_1 U)
                                     hV
                                     U
                                     h&#x27;)
                                h&#x27;))
                      hU_h))))
    (@lattice.complete_lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
          (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
             (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                (@topological_space.opens.partial_order.{u_1} α _inst_1))
             (@topological_space.opens.interior.{u_1} α _inst_1)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
             (@topological_space.opens.gi.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89    funext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α
⊢ @eq.{(max (u_1+1) 1)}
    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1) → @topological_space.opens.{u_1} α _inst_1)
    (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
       @subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
         (@set.sUnion.{u_1} α
            (@set.image.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1} α)
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               Us))
         (@is_open_sUnion.{u_1} α _inst_1
            (@set.image.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1} α)
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               Us)
            (λ (U : set.{u_1} α)
             (hU :
               @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U
                 (@set.image.{u_1 u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                    (set.{u_1} α)
                    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                    Us)),
               @Exists.dcases_on.{u_1+1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (λ
                  (a : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                    and
                      (@has_mem.mem.{u_1 u_1}
                         (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                         (set.{u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                         (@set.has_mem.{u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                         a
                         Us)
                      (@eq.{u_1+1} (set.{u_1} α)
                         (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                            a)
                         U))
                 (λ
                  (hU :
                    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                      U
                      (@set.image.{u_1 u_1}
                         (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                         (set.{u_1} α)
                         (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                         Us)), @is_open.{u_1} α _inst_1 U)
                 hU
                 (λ
                  (hU_w :
                    @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                  (hU_h :
                    and
                      (@has_mem.mem.{u_1 u_1}
                         (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                         (set.{u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                         (@set.has_mem.{u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                         hU_w
                         Us)
                      (@eq.{u_1+1} (set.{u_1} α)
                         (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                            hU_w)
                         U)),
                    @subtype.cases_on.{0 (max (u_1+1) 1)} (set.{u_1} α)
                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                      (λ
                       (hU_w :
                         @subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                           (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                         and
                           (@has_mem.mem.{u_1 u_1}
                              (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                              (set.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@set.has_mem.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              hU_w
                              Us)
                           (@eq.{u_1+1} (set.{u_1} α)
                              (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 hU_w)
                              U) →
                         @is_open.{u_1} α _inst_1 U)
                      hU_w
                      (λ (V : set.{u_1} α) (hV : @is_open.{u_1} α _inst_1 V)
                       (hU_h :
                         and
                           (@has_mem.mem.{u_1 u_1}
                              (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                              (set.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@set.has_mem.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 V
                                 hV)
                              Us)
                           (@eq.{u_1+1} (set.{u_1} α)
                              (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV))
                              U)),
                         @and.dcases_on.{0}
                           (@has_mem.mem.{u_1 u_1}
                              (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                              (set.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@set.has_mem.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 V
                                 hV)
                              Us)
                           (@eq.{u_1+1} (set.{u_1} α)
                              (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV))
                              U)
                           (λ
                            (hU_h :
                              and
                                (@has_mem.mem.{u_1 u_1}
                                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                   (set.{u_1}
                                      (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                         (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                   (@set.has_mem.{u_1}
                                      (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                         (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                   (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                      V
                                      hV)
                                   Us)
                                (@eq.{u_1+1} (set.{u_1} α)
                                   (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                      (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                         (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                         V
                                         hV))
                                   U)), @is_open.{u_1} α _inst_1 U)
                           hU_h
                           (λ
                            (h :
                              @has_mem.mem.{u_1 u_1}
                                (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                   (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                (set.{u_1}
                                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                (@set.has_mem.{u_1}
                                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                   (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                   V
                                   hV)
                                Us)
                            (h&#x27; :
                              @eq.{u_1+1} (set.{u_1} α)
                                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                   (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                   (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                      V
                                      hV))
                                U),
                              @id.{0}
                                (@eq.{u_1+1} (set.{u_1} α)
                                   (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                      (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                      (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                         (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                         V
                                         hV))
                                   U →
                                 @is_open.{u_1} α _inst_1 U)
                                (λ (h&#x27; : @eq.{u_1+1} (set.{u_1} α) V U),
                                   @eq.rec.{0 (max (u_1+1) 1)} (set.{u_1} α) V
                                     (λ (U : set.{u_1} α), @is_open.{u_1} α _inst_1 U)
                                     hV
                                     U
                                     h&#x27;)
                                h&#x27;))
                      hU_h))))
    (@lattice.complete_lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
          (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
             (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                (@topological_space.opens.partial_order.{u_1} α _inst_1))
             (@topological_space.opens.interior.{u_1} α _inst_1)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
             (@topological_space.opens.gi.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@set.sUnion.{u_1} α
          (@set.image.{u_1 u_1}
             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (set.{u_1} α)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             Us))
       (@is_open_sUnion.{u_1} α _inst_1
          (@set.image.{u_1 u_1}
             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (set.{u_1} α)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             Us)
          (λ (U : set.{u_1} α)
           (hU :
             @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U
               (@set.image.{u_1 u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                  (set.{u_1} α)
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                  Us)),
             @Exists.dcases_on.{u_1+1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (λ (a : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                  and
                    (@has_mem.mem.{u_1 u_1}
                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                       (set.{u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                       (@set.has_mem.{u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                       a
                       Us)
                    (@eq.{u_1+1} (set.{u_1} α)
                       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                          a)
                       U))
               (λ
                (hU :
                  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U
                    (@set.image.{u_1 u_1}
                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                       (set.{u_1} α)
                       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                       Us)), @is_open.{u_1} α _inst_1 U)
               hU
               (λ
                (hU_w : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (hU_h :
                  and
                    (@has_mem.mem.{u_1 u_1}
                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                       (set.{u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                       (@set.has_mem.{u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                       hU_w
                       Us)
                    (@eq.{u_1+1} (set.{u_1} α)
                       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                          hU_w)
                       U)),
                  @subtype.cases_on.{0 (max (u_1+1) 1)} (set.{u_1} α)
                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                    (λ
                     (hU_w :
                       @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                       and
                         (@has_mem.mem.{u_1 u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                            (set.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@set.has_mem.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            hU_w
                            Us)
                         (@eq.{u_1+1} (set.{u_1} α)
                            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               hU_w)
                            U) →
                       @is_open.{u_1} α _inst_1 U)
                    hU_w
                    (λ (V : set.{u_1} α) (hV : @is_open.{u_1} α _inst_1 V)
                     (hU_h :
                       and
                         (@has_mem.mem.{u_1 u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                            (set.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@set.has_mem.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               V
                               hV)
                            Us)
                         (@eq.{u_1+1} (set.{u_1} α)
                            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  V
                                  hV))
                            U)),
                       @and.dcases_on.{0}
                         (@has_mem.mem.{u_1 u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                            (set.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@set.has_mem.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               V
                               hV)
                            Us)
                         (@eq.{u_1+1} (set.{u_1} α)
                            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  V
                                  hV))
                            U)
                         (λ
                          (hU_h :
                            and
                              (@has_mem.mem.{u_1 u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                 (set.{u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                 (@set.has_mem.{u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV)
                                 Us)
                              (@eq.{u_1+1} (set.{u_1} α)
                                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       V
                                       hV))
                                 U)), @is_open.{u_1} α _inst_1 U)
                         hU_h
                         (λ
                          (h :
                            @has_mem.mem.{u_1 u_1}
                              (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                              (set.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@set.has_mem.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 V
                                 hV)
                              Us)
                          (h&#x27; :
                            @eq.{u_1+1} (set.{u_1} α)
                              (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV))
                              U),
                            @id.{0}
                              (@eq.{u_1+1} (set.{u_1} α)
                                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       V
                                       hV))
                                 U →
                               @is_open.{u_1} α _inst_1 U)
                              (λ (h&#x27; : @eq.{u_1+1} (set.{u_1} α) V U),
                                 @eq.rec.{0 (max (u_1+1) 1)} (set.{u_1} α) V
                                   (λ (U : set.{u_1} α), @is_open.{u_1} α _inst_1 U)
                                   hV
                                   U
                                   h&#x27;)
                              h&#x27;))
                    hU_h))))
    (@lattice.complete_lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
          (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
             (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                (@topological_space.opens.partial_order.{u_1} α _inst_1))
             (@topological_space.opens.interior.{u_1} α _inst_1)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
             (@topological_space.opens.gi.{u_1} α _inst_1)))
       Us)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    apply subtype.ext.mpr,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@set.sUnion.{u_1} α
          (@set.image.{u_1 u_1}
             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (set.{u_1} α)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             Us))
       (@is_open_sUnion.{u_1} α _inst_1
          (@set.image.{u_1 u_1}
             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (set.{u_1} α)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             Us)
          (λ (U : set.{u_1} α)
           (hU :
             @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U
               (@set.image.{u_1 u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                  (set.{u_1} α)
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                  Us)),
             @Exists.dcases_on.{u_1+1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (λ (a : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                  and
                    (@has_mem.mem.{u_1 u_1}
                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                       (set.{u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                       (@set.has_mem.{u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                       a
                       Us)
                    (@eq.{u_1+1} (set.{u_1} α)
                       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                          a)
                       U))
               (λ
                (hU :
                  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U
                    (@set.image.{u_1 u_1}
                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                       (set.{u_1} α)
                       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                       Us)), @is_open.{u_1} α _inst_1 U)
               hU
               (λ
                (hU_w : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (hU_h :
                  and
                    (@has_mem.mem.{u_1 u_1}
                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                       (set.{u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                       (@set.has_mem.{u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                       hU_w
                       Us)
                    (@eq.{u_1+1} (set.{u_1} α)
                       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                          hU_w)
                       U)),
                  @subtype.cases_on.{0 (max (u_1+1) 1)} (set.{u_1} α)
                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                    (λ
                     (hU_w :
                       @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                       and
                         (@has_mem.mem.{u_1 u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                            (set.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@set.has_mem.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            hU_w
                            Us)
                         (@eq.{u_1+1} (set.{u_1} α)
                            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               hU_w)
                            U) →
                       @is_open.{u_1} α _inst_1 U)
                    hU_w
                    (λ (V : set.{u_1} α) (hV : @is_open.{u_1} α _inst_1 V)
                     (hU_h :
                       and
                         (@has_mem.mem.{u_1 u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                            (set.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@set.has_mem.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               V
                               hV)
                            Us)
                         (@eq.{u_1+1} (set.{u_1} α)
                            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  V
                                  hV))
                            U)),
                       @and.dcases_on.{0}
                         (@has_mem.mem.{u_1 u_1}
                            (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                            (set.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@set.has_mem.{u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                            (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               V
                               hV)
                            Us)
                         (@eq.{u_1+1} (set.{u_1} α)
                            (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                               (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                               (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  V
                                  hV))
                            U)
                         (λ
                          (hU_h :
                            and
                              (@has_mem.mem.{u_1 u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                 (set.{u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                 (@set.has_mem.{u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV)
                                 Us)
                              (@eq.{u_1+1} (set.{u_1} α)
                                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       V
                                       hV))
                                 U)), @is_open.{u_1} α _inst_1 U)
                         hU_h
                         (λ
                          (h :
                            @has_mem.mem.{u_1 u_1}
                              (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                              (set.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@set.has_mem.{u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                              (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 V
                                 hV)
                              Us)
                          (h&#x27; :
                            @eq.{u_1+1} (set.{u_1} α)
                              (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                 (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV))
                              U),
                            @id.{0}
                              (@eq.{u_1+1} (set.{u_1} α)
                                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       V
                                       hV))
                                 U →
                               @is_open.{u_1} α _inst_1 U)
                              (λ (h&#x27; : @eq.{u_1+1} (set.{u_1} α) V U),
                                 @eq.rec.{0 (max (u_1+1) 1)} (set.{u_1} α) V
                                   (λ (U : set.{u_1} α), @is_open.{u_1} α _inst_1 U)
                                   hV
                                   U
                                   h&#x27;)
                              h&#x27;))
                    hU_h))))
    (@lattice.complete_lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
          (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
             (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                (@topological_space.opens.partial_order.{u_1} α _inst_1))
             (@topological_space.opens.interior.{u_1} α _inst_1)
             (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
             (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
             (@topological_space.opens.gi.{u_1} α _inst_1)))
       Us)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
          (@set.sUnion.{u_1} α
             (@set.image.{u_1 u_1}
                (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (set.{u_1} α)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                Us))
          (@is_open_sUnion.{u_1} α _inst_1
             (@set.image.{u_1 u_1}
                (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (set.{u_1} α)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                Us)
             (λ (U : set.{u_1} α)
              (hU :
                @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U
                  (@set.image.{u_1 u_1}
                     (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                     (set.{u_1} α)
                     (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                        (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                     Us)),
                @Exists.dcases_on.{u_1+1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                  (λ
                   (a : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                     and
                       (@has_mem.mem.{u_1 u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                          (set.{u_1}
                             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                          (@set.has_mem.{u_1}
                             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                          a
                          Us)
                       (@eq.{u_1+1} (set.{u_1} α)
                          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                             a)
                          U))
                  (λ
                   (hU :
                     @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α))
                       (@set.has_mem.{u_1} (set.{u_1} α))
                       U
                       (@set.image.{u_1 u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                          (set.{u_1} α)
                          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                          Us)), @is_open.{u_1} α _inst_1 U)
                  hU
                  (λ
                   (hU_w :
                     @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   (hU_h :
                     and
                       (@has_mem.mem.{u_1 u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                          (set.{u_1}
                             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                          (@set.has_mem.{u_1}
                             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                          hU_w
                          Us)
                       (@eq.{u_1+1} (set.{u_1} α)
                          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                             hU_w)
                          U)),
                     @subtype.cases_on.{0 (max (u_1+1) 1)} (set.{u_1} α)
                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                       (λ
                        (hU_w :
                          @subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                          and
                            (@has_mem.mem.{u_1 u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                               (set.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@set.has_mem.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               hU_w
                               Us)
                            (@eq.{u_1+1} (set.{u_1} α)
                               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  hU_w)
                               U) →
                          @is_open.{u_1} α _inst_1 U)
                       hU_w
                       (λ (V : set.{u_1} α) (hV : @is_open.{u_1} α _inst_1 V)
                        (hU_h :
                          and
                            (@has_mem.mem.{u_1 u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                               (set.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@set.has_mem.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  V
                                  hV)
                               Us)
                            (@eq.{u_1+1} (set.{u_1} α)
                               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                     V
                                     hV))
                               U)),
                          @and.dcases_on.{0}
                            (@has_mem.mem.{u_1 u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                               (set.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@set.has_mem.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  V
                                  hV)
                               Us)
                            (@eq.{u_1+1} (set.{u_1} α)
                               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                     V
                                     hV))
                               U)
                            (λ
                             (hU_h :
                               and
                                 (@has_mem.mem.{u_1 u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                    (set.{u_1}
                                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                    (@set.has_mem.{u_1}
                                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       V
                                       hV)
                                    Us)
                                 (@eq.{u_1+1} (set.{u_1} α)
                                    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                          V
                                          hV))
                                    U)), @is_open.{u_1} α _inst_1 U)
                            hU_h
                            (λ
                             (h :
                               @has_mem.mem.{u_1 u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                 (set.{u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                 (@set.has_mem.{u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV)
                                 Us)
                             (h&#x27; :
                               @eq.{u_1+1} (set.{u_1} α)
                                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       V
                                       hV))
                                 U),
                               @id.{0}
                                 (@eq.{u_1+1} (set.{u_1} α)
                                    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                          V
                                          hV))
                                    U →
                                  @is_open.{u_1} α _inst_1 U)
                                 (λ (h&#x27; : @eq.{u_1+1} (set.{u_1} α) V U),
                                    @eq.rec.{0 (max (u_1+1) 1)} (set.{u_1} α) V
                                      (λ (U : set.{u_1} α), @is_open.{u_1} α _inst_1 U)
                                      hV
                                      U
                                      h&#x27;)
                                 h&#x27;))
                       hU_h)))))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@lattice.complete_lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
                (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.partial_order.{u_1} α _inst_1))
                (@topological_space.opens.interior.{u_1} α _inst_1)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
                (@topological_space.opens.gi.{u_1} α _inst_1)))
          Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91    simp [Sup_range],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lattice.Sup_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 533, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Sort ?l_1} {α : Type ?l_2} [_inst_2 : lattice.has_Sup.{?l_2} α] {f : ι → α}, @eq.{?l_2+1} α (@lattice.Sup.{?l_2} α _inst_2 (@set.range.{?l_2 ?l_1} α ι f)) (@lattice.supr.{?l_2 ?l_1} α ι _inst_2 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
          (@set.sUnion.{u_1} α
             (@set.image.{u_1 u_1}
                (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (set.{u_1} α)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                Us))
          (@is_open_sUnion.{u_1} α _inst_1
             (@set.image.{u_1 u_1}
                (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (set.{u_1} α)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                Us)
             (λ (U : set.{u_1} α)
              (hU :
                @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) U
                  (@set.image.{u_1 u_1}
                     (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                     (set.{u_1} α)
                     (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                        (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                     Us)),
                @Exists.dcases_on.{u_1+1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                  (λ
                   (a : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                     and
                       (@has_mem.mem.{u_1 u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                          (set.{u_1}
                             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                          (@set.has_mem.{u_1}
                             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                          a
                          Us)
                       (@eq.{u_1+1} (set.{u_1} α)
                          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                             a)
                          U))
                  (λ
                   (hU :
                     @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α))
                       (@set.has_mem.{u_1} (set.{u_1} α))
                       U
                       (@set.image.{u_1 u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                          (set.{u_1} α)
                          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                          Us)), @is_open.{u_1} α _inst_1 U)
                  hU
                  (λ
                   (hU_w :
                     @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   (hU_h :
                     and
                       (@has_mem.mem.{u_1 u_1}
                          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                          (set.{u_1}
                             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                          (@set.has_mem.{u_1}
                             (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                          hU_w
                          Us)
                       (@eq.{u_1+1} (set.{u_1} α)
                          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                             (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                             hU_w)
                          U)),
                     @subtype.cases_on.{0 (max (u_1+1) 1)} (set.{u_1} α)
                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                       (λ
                        (hU_w :
                          @subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                            (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
                          and
                            (@has_mem.mem.{u_1 u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                               (set.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@set.has_mem.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               hU_w
                               Us)
                            (@eq.{u_1+1} (set.{u_1} α)
                               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  hU_w)
                               U) →
                          @is_open.{u_1} α _inst_1 U)
                       hU_w
                       (λ (V : set.{u_1} α) (hV : @is_open.{u_1} α _inst_1 V)
                        (hU_h :
                          and
                            (@has_mem.mem.{u_1 u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                               (set.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@set.has_mem.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  V
                                  hV)
                               Us)
                            (@eq.{u_1+1} (set.{u_1} α)
                               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                     V
                                     hV))
                               U)),
                          @and.dcases_on.{0}
                            (@has_mem.mem.{u_1 u_1}
                               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                               (set.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@set.has_mem.{u_1}
                                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                               (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  V
                                  hV)
                               Us)
                            (@eq.{u_1+1} (set.{u_1} α)
                               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                  (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                  (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                     (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                     V
                                     hV))
                               U)
                            (λ
                             (hU_h :
                               and
                                 (@has_mem.mem.{u_1 u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                    (set.{u_1}
                                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                    (@set.has_mem.{u_1}
                                       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       V
                                       hV)
                                    Us)
                                 (@eq.{u_1+1} (set.{u_1} α)
                                    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                          V
                                          hV))
                                    U)), @is_open.{u_1} α _inst_1 U)
                            hU_h
                            (λ
                             (h :
                               @has_mem.mem.{u_1 u_1}
                                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                                 (set.{u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                 (@set.has_mem.{u_1}
                                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    V
                                    hV)
                                 Us)
                             (h&#x27; :
                               @eq.{u_1+1} (set.{u_1} α)
                                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                    (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       V
                                       hV))
                                 U),
                               @id.{0}
                                 (@eq.{u_1+1} (set.{u_1} α)
                                    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                                       (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α)
                                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                                          V
                                          hV))
                                    U →
                                  @is_open.{u_1} α _inst_1 U)
                                 (λ (h&#x27; : @eq.{u_1+1} (set.{u_1} α) V U),
                                    @eq.rec.{0 (max (u_1+1) 1)} (set.{u_1} α) V
                                      (λ (U : set.{u_1} α), @is_open.{u_1} α _inst_1 U)
                                      hV
                                      U
                                      h&#x27;)
                                 h&#x27;))
                       hU_h)))))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@lattice.complete_lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
                (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.partial_order.{u_1} α _inst_1))
                (@topological_space.opens.interior.{u_1} α _inst_1)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
                (@topological_space.opens.gi.{u_1} α _inst_1)))
          Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@set.Union.{u_1 u_1+1} α
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (λ (x : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
          @set.Union.{u_1 0} α
            (@has_mem.mem.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
               (@set.has_mem.{u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
               x
               Us)
            (λ
             (H :
               @has_mem.mem.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                 (@set.has_mem.{u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                 x
                 Us),
               @subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) x)))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@lattice.complete_lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
                (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.partial_order.{u_1} α _inst_1))
                (@topological_space.opens.interior.{u_1} α _inst_1)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
                (@topological_space.opens.gi.{u_1} α _inst_1)))
          Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    refl,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@set.Union.{u_1 u_1+1} α
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (λ (x : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
          @set.Union.{u_1 0} α
            (@has_mem.mem.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
               (@set.has_mem.{u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
               x
               Us)
            (λ
             (H :
               @has_mem.mem.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                 (@set.has_mem.{u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                 x
                 Us),
               @subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) x)))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (x : set.{u_1} α), @is_open.{u_1} α _inst_1 x)
       (@lattice.complete_lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@order_dual.lattice.complete_lattice.{u_1} (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
             (@galois_insertion.lift_complete_lattice.{u_1 u_1} (order_dual.{u_1} (set.{u_1} α))
                (order_dual.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@order_dual.partial_order.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.partial_order.{u_1} α _inst_1))
                (@topological_space.opens.interior.{u_1} α _inst_1)
                (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                (@order_dual.lattice.complete_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
                (@topological_space.opens.gi.{u_1} α _inst_1)))
          Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  /- Inf -/ _ rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  instance : has_inter (opens α) := ⟨λ U V, U ⊓ V⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  instance : has_union (opens α) := ⟨λ U V, U ⊔ V⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_sup.sup'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_sup.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  instance : has_emptyc (opens α) := ⟨⊥⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  instance : inhabited (opens α) := ⟨∅⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (α : Type u_1) [c : has_emptyc.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  @[simp] lemma inter_eq (U V : opens α) : U ∩ V = U ⊓ V := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_inter.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  @[simp] lemma union_eq (U V : opens α) : U ∪ V = U ⊔ V := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_sup.sup'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_union.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_sup.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  @[simp] lemma empty_eq : (∅ : opens α) = ⊥ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π (α : Type u_1) [c : has_emptyc.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{(max (u_1+1) 1)} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  @[simp] lemma Sup_s {Us : set (opens α)} : (Sup Us).val = ⋃₀ (subtype.val &#x27;&#x27; Us) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='lattice.Sup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Us'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Us'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} [_inst_1 : lattice.has_Sup.{u} α], set.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} (set.{u_1} α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {p : α → Prop}, @subtype.{u} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, (α → β) → set.{u_1} α → set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Supremum of a set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
          Us))
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    rw [@galois_connection.l_Sup (opens α) (set α) _ _ (subtype.val : opens α → set α) interior gc Us, set.sUnion_image],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='galois_connection.l_Sup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens.interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.opens.gc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Us'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sUnion_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/galois_connection.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : lattice.complete_lattice.{u_1} α] [_inst_2 : lattice.complete_lattice.{u_1} β] {l : α → β} {u : β → α}, @galois_connection.{u_1 u_1} α β (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1)))) (@partial_order.to_preorder.{u_1} β (@lattice.order_bot.to_partial_order.{u_1} β (@lattice.bounded_lattice.to_order_bot.{u_1} β (@lattice.complete_lattice.to_bounded_lattice.{u_1} β _inst_2)))) l u → ∀ {s : set.{u_1} α}, @eq.{u_1+1} β (l (@lattice.Sup.{u_1} α (@lattice.complete_lattice.to_has_Sup.{u_1} α _inst_1) s)) (@lattice.supr.{u_1 u_1+1} β α (@lattice.complete_lattice.to_has_Sup.{u_1} β _inst_2) (λ (a : α), @lattice.supr.{u_1 0} β (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s) (@lattice.complete_lattice.to_has_Sup.{u_1} β _inst_2) (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s), l a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} α → @topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α], @galois_connection.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.preorder.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (@topological_space.opens.interior.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} (f : α → set.{u_1} β) (s : set.{u_1} α), @eq.{(max (u_1+1) 1)} (set.{u_1} β) (@set.sUnion.{u_1} β (@set.image.{u_1 u_1} α (set.{u_1} β) f s)) (@set.Union.{u_1 u_1+1} β α (λ (x : α), @set.Union.{u_1 0} β (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s) (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s), f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
          Us))
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@lattice.supr.{u_1 u_1+1} (set.{u_1} α) (@topological_space.opens.{u_1} α _inst_1)
       (@lattice.complete_lattice.to_has_Sup.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
       (λ (a : @topological_space.opens.{u_1} α _inst_1),
          @lattice.supr.{u_1 0} (set.{u_1} α)
            (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
               (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               a
               Us)
            (@lattice.complete_lattice.to_has_Sup.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 a
                 Us),
               @subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) a)))
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@lattice.supr.{u_1 u_1+1} (set.{u_1} α) (@topological_space.opens.{u_1} α _inst_1)
       (@lattice.complete_lattice.to_has_Sup.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
       (λ (a : @topological_space.opens.{u_1} α _inst_1),
          @lattice.supr.{u_1 0} (set.{u_1} α)
            (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
               (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               a
               Us)
            (@lattice.complete_lattice.to_has_Sup.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 a
                 Us),
               @subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) a)))
    (@set.Union.{u_1 u_1+1} α
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (λ (x : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
          @set.Union.{u_1 0} α
            (@has_mem.mem.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
               (@set.has_mem.{u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
               x
               Us)
            (λ
             (H :
               @has_mem.mem.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                 (@set.has_mem.{u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                 x
                 Us),
               @subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    congr</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@lattice.supr.{u_1 u_1+1} (set.{u_1} α) (@topological_space.opens.{u_1} α _inst_1)
       (@lattice.complete_lattice.to_has_Sup.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
       (λ (a : @topological_space.opens.{u_1} α _inst_1),
          @lattice.supr.{u_1 0} (set.{u_1} α)
            (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
               (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               a
               Us)
            (@lattice.complete_lattice.to_has_Sup.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 a
                 Us),
               @subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) a)))
    (@set.Union.{u_1 u_1+1} α
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (λ (x : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)),
          @set.Union.{u_1 0} α
            (@has_mem.mem.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
               (@set.has_mem.{u_1}
                  (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
               x
               Us)
            (λ
             (H :
               @has_mem.mem.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                 (@set.has_mem.{u_1}
                    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
                 x
                 Us),
               @subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  def is_basis (B : set (opens α)) : Prop := is_topological_basis (subtype.val &#x27;&#x27; B)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/bases.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {p : α → Prop}, @subtype.{u} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, (α → β) → set.{u_1} α → set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  lemma is_basis_iff_nbhd {B : set (opens α)} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    is_basis B ↔ ∀ {U : opens α} {x}, x ∈ U → ∃ U&#x27; ∈ B, x ∈ U&#x27; ∧ U&#x27; ⊆ U :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens.is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} (@topological_space.opens.{u_1} α _inst_1) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ iff (@topological_space.opens.is_basis.{u_1} α _inst_1 B)
    (∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
       @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
         (@topological_space.opens.has_mem.{u_1} α _inst_1)
         x
         U →
       @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
         (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
            @Exists.{0}
              (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 U&#x27;
                 B)
              (λ
               (H :
                 @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                   (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                   U&#x27;
                   B),
                 and
                   (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.has_mem.{u_1} α _inst_1)
                      x
                      U&#x27;)
                   (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.has_subset.{u_1} α _inst_1)
                      U&#x27;
                      U))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    split; intro h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ iff (@topological_space.opens.is_basis.{u_1} α _inst_1 B)
    (∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
       @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
         (@topological_space.opens.has_mem.{u_1} α _inst_1)
         x
         U →
       @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
         (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
            @Exists.{0}
              (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 U&#x27;
                 B)
              (λ
               (H :
                 @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                   (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                   U&#x27;
                   B),
                 and
                   (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.has_mem.{u_1} α _inst_1)
                      x
                      U&#x27;)
                   (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.has_subset.{u_1} α _inst_1)
                      U&#x27;
                      U))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B
⊢ ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    { rintros ⟨sU, hU⟩ x hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B
⊢ ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B
⊢ ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
x : α,
sU : set.{u_1} α,
hU : @is_open.{u_1} α _inst_1 sU,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU)
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU
                    hU))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118      rcases (mem_nhds_of_is_topological_basis h).mp (mem_nhds_sets hU hx) with ⟨sV, ⟨⟨V, H₁, H₂⟩, hsV⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='topological_space.mem_nhds_of_is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/bases.lean&#x27;, &#x27;line&#x27;: 210, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [t : topological_space.{u_1} α] {a : α} {s : set.{u_1} α} {b : set.{u_1} (set.{u_1} α)}, @topological_space.is_topological_basis.{u_1} α t b → iff (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s (@nhds.{u_1} α t a)) (@Exists.{u_1+1} (set.{u_1} α) (λ (t : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) t b) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) t b), and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a t) (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {a : α} {s : set.{u_1} α}, @is_open.{u_1} α _inst_1 s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s (@nhds.{u_1} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_1} α _inst_1 sU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.has_mem.{u_1} α _inst_1) x (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
x : α,
sU : set.{u_1} α,
hU : @is_open.{u_1} α _inst_1 sU,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU)
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU
                    hU))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
x : α,
sU : set.{u_1} α,
hU : @is_open.{u_1} α _inst_1 sU,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU),
sV : set.{u_1} α,
hsV :
  and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV)
    (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) sV sU),
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    V
    B,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sV
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU
                    hU))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119      refine ⟨V, H₁, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) (@set.has_mem.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) V B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
x : α,
sU : set.{u_1} α,
hU : @is_open.{u_1} α _inst_1 sU,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU),
sV : set.{u_1} α,
hsV :
  and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV)
    (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) sV sU),
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    V
    B,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sV
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU
                    hU))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
x : α,
sU : set.{u_1} α,
hU : @is_open.{u_1} α _inst_1 sU,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU),
sV : set.{u_1} α,
hsV :
  and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV)
    (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) sV sU),
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    V
    B,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sV
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       V)
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       V
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120      cases V, dsimp at H₂, subst H₂, exact hsV },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='H₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hsV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (set.{u_1} α) V_val sV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V_val) (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) V_val sU)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
x : α,
sU : set.{u_1} α,
hU : @is_open.{u_1} α _inst_1 sU,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU),
sV : set.{u_1} α,
hsV :
  and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV)
    (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) sV sU),
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    V
    B,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sV
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       V)
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       V
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
x : α,
sU : set.{u_1} α,
hU : @is_open.{u_1} α _inst_1 sU,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU),
sV : set.{u_1} α,
hsV :
  and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV)
    (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) sV sU),
V_val : set.{u_1} α,
V_property : @is_open.{u_1} α _inst_1 V_val,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val V_property)
    B,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val
          V_property))
    sV
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val
          V_property))
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val
          V_property)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
x : α,
sU : set.{u_1} α,
hU : @is_open.{u_1} α _inst_1 sU,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU),
sV : set.{u_1} α,
hsV :
  and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV)
    (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) sV sU),
V_val : set.{u_1} α,
V_property : @is_open.{u_1} α _inst_1 V_val,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val V_property)
    B,
H₂ : @eq.{u_1+1} (set.{u_1} α) V_val sV
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val
          V_property))
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val
          V_property)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
x : α,
sU : set.{u_1} α,
hU : @is_open.{u_1} α _inst_1 sU,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU),
V_val : set.{u_1} α,
V_property : @is_open.{u_1} α _inst_1 V_val,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val V_property)
    B,
hsV :
  and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V_val)
    (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) V_val sU)
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val
          V_property))
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V_val
          V_property)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hU))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    { refine is_topological_basis_of_open_of_nhds _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='topological_space.is_topological_basis_of_open_of_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/bases.lean&#x27;, &#x27;line&#x27;: 193, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [t : topological_space.{u_1} α] {s : set.{u_1} (set.{u_1} α)}, (∀ (u : set.{u_1} α), @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) u s → @is_open.{u_1} α t u) → (∀ (a : α) (u : set.{u_1} α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a u → @is_open.{u_1} α t u → @Exists.{u_1+1} (set.{u_1} α) (λ (v : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v s) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v s), and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a v) (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) v u)))) → @topological_space.is_topological_basis.{u_1} α t s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ ∀ (u : set.{u_1} α),
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) u
      (@set.image.{u_1 u_1}
         (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
         (set.{u_1} α)
         (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
         B) →
    @is_open.{u_1} α _inst_1 u

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ ∀ (a : α) (u : set.{u_1} α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a u →
    @is_open.{u_1} α _inst_1 u →
    @Exists.{u_1+1} (set.{u_1} α)
      (λ (v : set.{u_1} α),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
              (@set.image.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1} α)
                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 B))
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
                (@set.image.{u_1 u_1}
                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   (set.{u_1} α)
                   (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   B)),
              and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a v)
                (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) v u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122      { rintros sU ⟨U, ⟨H₁, H₂⟩⟩, subst H₂, exact U.property },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='H₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) sU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ ∀ (u : set.{u_1} α),
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) u
      (@set.image.{u_1 u_1}
         (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
         (set.{u_1} α)
         (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
         B) →
    @is_open.{u_1} α _inst_1 u

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ ∀ (a : α) (u : set.{u_1} α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a u →
    @is_open.{u_1} α _inst_1 u →
    @Exists.{u_1+1} (set.{u_1} α)
      (λ (v : set.{u_1} α),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
              (@set.image.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1} α)
                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 B))
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
                (@set.image.{u_1 u_1}
                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   (set.{u_1} α)
                   (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   B)),
              and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a v)
                (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) v u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ ∀ (u : set.{u_1} α),
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) u
      (@set.image.{u_1 u_1}
         (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
         (set.{u_1} α)
         (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
         B) →
    @is_open.{u_1} α _inst_1 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U))),
sU : set.{u_1} α,
U : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    U
    B,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    sU
⊢ @is_open.{u_1} α _inst_1 sU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U))),
U : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    U
    B
⊢ @is_open.{u_1} α _inst_1
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ ∀ (a : α) (u : set.{u_1} α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a u →
    @is_open.{u_1} α _inst_1 u →
    @Exists.{u_1+1} (set.{u_1} α)
      (λ (v : set.{u_1} α),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
              (@set.image.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1} α)
                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 B))
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
                (@set.image.{u_1 u_1}
                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   (set.{u_1} α)
                   (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   B)),
              and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a v)
                (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) v u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123      { intros x sU hx hsU,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))
⊢ ∀ (a : α) (u : set.{u_1} α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a u →
    @is_open.{u_1} α _inst_1 u →
    @Exists.{u_1+1} (set.{u_1} α)
      (λ (v : set.{u_1} α),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
              (@set.image.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1} α)
                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 B))
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
                (@set.image.{u_1 u_1}
                   (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   (set.{u_1} α)
                   (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                   B)),
              and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a v)
                (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) v u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U))),
x : α,
sU : set.{u_1} α,
hx : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sU,
hsU : @is_open.{u_1} α _inst_1 sU
⊢ @Exists.{u_1+1} (set.{u_1} α)
    (λ (v : set.{u_1} α),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
            (@set.image.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1} α)
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               B))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
              (@set.image.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1} α)
                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 B)),
            and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x v)
              (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) v sU)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124        rcases @h (⟨sU, hsU⟩ : opens α) x hx with ⟨V, hV, H⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='sU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hsU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α}, @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.has_mem.{u_1} α _inst_1) x U → @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1) (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1), @Exists.{0} (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1) (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1)) U&#x27; B) (λ (H : @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1) (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1)) U&#x27; B), and (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.has_mem.{u_1} α _inst_1) x U&#x27;) (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.has_subset.{u_1} α _inst_1) U&#x27; U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_1} α _inst_1 sU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U))),
x : α,
sU : set.{u_1} α,
hx : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sU,
hsU : @is_open.{u_1} α _inst_1 sU
⊢ @Exists.{u_1+1} (set.{u_1} α)
    (λ (v : set.{u_1} α),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
            (@set.image.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1} α)
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               B))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
              (@set.image.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1} α)
                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 B)),
            and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x v)
              (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) v sU)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U))),
x : α,
sU : set.{u_1} α,
hx : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sU,
hsU : @is_open.{u_1} α _inst_1 sU,
V : @topological_space.opens.{u_1} α _inst_1,
hV :
  @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    V
    B,
H :
  and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       V)
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       V
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hsU))
⊢ @Exists.{u_1+1} (set.{u_1} α)
    (λ (v : set.{u_1} α),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
            (@set.image.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1} α)
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               B))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
              (@set.image.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1} α)
                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 B)),
            and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x v)
              (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) v sU)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125        exact ⟨V, ⟨V, hV, rfl⟩, H⟩ } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1) (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1)) V B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.has_mem.{u_1} α _inst_1) x V) (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.has_subset.{u_1} α _inst_1) V (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hsU))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U))),
x : α,
sU : set.{u_1} α,
hx : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sU,
hsU : @is_open.{u_1} α _inst_1 sU,
V : @topological_space.opens.{u_1} α _inst_1,
hV :
  @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    V
    B,
H :
  and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       V)
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       V
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) sU hsU))
⊢ @Exists.{u_1+1} (set.{u_1} α)
    (λ (v : set.{u_1} α),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
            (@set.image.{u_1 u_1}
               (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               (set.{u_1} α)
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
               B))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) v
              (@set.image.{u_1 u_1}
                 (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 (set.{u_1} α)
                 (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
                 B)),
            and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x v)
              (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) v sU)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  lemma is_basis_iff_cover {B : set (opens α)} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    is_basis B ↔ ∀ U : opens α, ∃ Us ⊆ B, U = Sup Us :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.opens.is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Us'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.Sup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Us'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} (@topological_space.opens.{u_1} α _inst_1) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : lattice.has_Sup.{u} α], set.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Supremum of a set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ iff (@topological_space.opens.is_basis.{u_1} α _inst_1 B)
    (∀ (U : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
         (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
            @Exists.{0}
              (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 Us
                 B)
              (λ
               (H :
                 @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                   (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                   Us
                   B),
                 @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                   (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                         (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                      Us))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ iff (@topological_space.opens.is_basis.{u_1} α _inst_1 B)
    (∀ (U : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
         (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
            @Exists.{0}
              (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 Us
                 B)
              (λ
               (H :
                 @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                   (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                   Us
                   B),
                 @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                   (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                         (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                      Us))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @topological_space.opens.is_basis.{u_1} α _inst_1 B →
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us)))

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ (∀ (U : @topological_space.opens.{u_1} α _inst_1),
     @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
       (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
          @Exists.{0}
            (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               Us
               B)
            (λ
             (H :
               @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 Us
                 B),
               @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                 (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                       (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                    Us)))) →
  @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    { intros hB U,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @topological_space.opens.is_basis.{u_1} α _inst_1 B →
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us)))

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ (∀ (U : @topological_space.opens.{u_1} α _inst_1),
     @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
       (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
          @Exists.{0}
            (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               Us
               B)
            (λ
             (H :
               @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 Us
                 B),
               @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                 (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                       (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                    Us)))) →
  @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ @topological_space.opens.is_basis.{u_1} α _inst_1 B →
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1
⊢ @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
       @Exists.{0}
         (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            Us
            B)
         (λ
          (H :
            @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B),
            @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
              (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                 Us)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133      rcases sUnion_basis_of_is_open hB U.property with ⟨sUs, H, hU⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='topological_space.sUnion_basis_of_is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hB'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/bases.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [t : topological_space.{u_1} α] {B : set.{u_1} (set.{u_1} α)}, @topological_space.is_topological_basis.{u_1} α t B → ∀ {u : set.{u_1} α}, @is_open.{u_1} α t u → @Exists.{u_1+1} (set.{u_1} (set.{u_1} α)) (λ (S : set.{u_1} (set.{u_1} α)), @Exists.{0} (@has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) S B) (λ (H : @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) S B), @eq.{(max (u_1+1) 1)} (set.{u_1} α) u (@set.sUnion.{u_1} α S)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1
⊢ @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
       @Exists.{0}
         (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            Us
            B)
         (λ
          (H :
            @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B),
            @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
              (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                 Us)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
       @Exists.{0}
         (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            Us
            B)
         (λ
          (H :
            @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B),
            @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
              (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                 Us)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134      existsi {U : opens α | U ∈ B ∧ U.val ∈ sUs},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} (@topological_space.opens.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} (set.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
       @Exists.{0}
         (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            Us
            B)
         (λ
          (H :
            @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B),
            @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
              (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                 Us)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @Exists.{0}
    (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
       (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs)))
       B)
    (λ
     (H :
       @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
         (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
         (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
            (λ (U : @topological_space.opens.{u_1} α _inst_1),
               and
                 (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                    (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                    U
                    B)
                 (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                       U)
                    sUs)))
         B),
       @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
         (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
            (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
               (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
            (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
               (λ (U : @topological_space.opens.{u_1} α _inst_1),
                  and
                    (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                       (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                       (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                       U
                       B)
                    (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α))
                       (@set.has_mem.{u_1} (set.{u_1} α))
                       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                          U)
                       sUs)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135      split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @Exists.{0}
    (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
       (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs)))
       B)
    (λ
     (H :
       @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
         (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
         (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
            (λ (U : @topological_space.opens.{u_1} α _inst_1),
               and
                 (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                    (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                    U
                    B)
                 (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                       U)
                    sUs)))
         B),
       @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
         (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
            (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
               (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
            (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
               (λ (U : @topological_space.opens.{u_1} α _inst_1),
                  and
                    (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                       (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                       (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                       U
                       B)
                    (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α))
                       (@set.has_mem.{u_1} (set.{u_1} α))
                       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α)
                          (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                          U)
                       sUs)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (λ (U : @topological_space.opens.{u_1} α _inst_1),
          and
            (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
               (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               U
               B)
            (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
               sUs)))
    B

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
    (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136      { intros U hU, exact hU.left },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='hU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1) (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1)) U (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1) (λ (U : @topological_space.opens.{u_1} α _inst_1), and (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1) (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1)) U B) (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) sUs)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (λ (U : @topological_space.opens.{u_1} α _inst_1),
          and
            (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
               (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               U
               B)
            (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
               sUs)))
    B

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
    (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (λ (U : @topological_space.opens.{u_1} α _inst_1),
          and
            (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
               (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               U
               B)
            (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
               sUs)))
    B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
U : @topological_space.opens.{u_1} α _inst_1,
hU :
  @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    U
    (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (λ (U : @topological_space.opens.{u_1} α _inst_1),
          and
            (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
               (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               U
               B)
            (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
               (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
               sUs)))
⊢ @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    U
    B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
    (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137      { apply ext,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='topological_space.opens.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 52, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {U V : @topological_space.opens.{u_1} α _inst_1}, @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V) → @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
    (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
          (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (λ (U : @topological_space.opens.{u_1} α _inst_1),
                and
                  (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                     (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     U
                     B)
                  (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                     (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                        U)
                     sUs)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138        rw [Sup_s, hU],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='topological_space.opens.Sup_s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)}, @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1)) Us)) (@set.sUnion.{u_1} α (@set.image.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_1+1) 1)} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) (@set.sUnion.{u_1} α sUs)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
          (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (λ (U : @topological_space.opens.{u_1} α _inst_1),
                and
                  (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                     (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     U
                     B)
                  (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                     (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                        U)
                     sUs)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (λ (U : @topological_space.opens.{u_1} α _inst_1),
                and
                  (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                     (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     U
                     B)
                  (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                     (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                        U)
                     sUs)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@set.sUnion.{u_1} α sUs)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (λ (U : @topological_space.opens.{u_1} α _inst_1),
                and
                  (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                     (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     U
                     B)
                  (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                     (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                        U)
                     sUs)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139        congr,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@set.sUnion.{u_1} α sUs)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (λ (U : @topological_space.opens.{u_1} α _inst_1),
                and
                  (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                     (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                     U
                     B)
                  (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                     (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
                        U)
                     sUs)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140        ext s; split; intro hs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs)
⊢ @eq.{(max (u_1+1) 1)} (set.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
hs : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141        { rcases H hs with ⟨V, hV⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs (@set.image.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
hs : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))

α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
hs : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
hs : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
hV :
  and
    (@has_mem.mem.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
       (@set.has_mem.{u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
       V
       B)
    (@eq.{u_1+1} (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
       s)
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142          rw ← hV.right at hs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
hs : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
hV :
  and
    (@has_mem.mem.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
       (@set.has_mem.{u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
       V
       B)
    (@eq.{u_1+1} (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
       s)
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
hV :
  and
    (@has_mem.mem.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
       (@set.has_mem.{u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
       V
       B)
    (@eq.{u_1+1} (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
       s),
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sUs
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143          refine ⟨V, ⟨⟨hV.left, hs⟩, hV.right⟩⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V) sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) (@set.has_mem.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) V B) (@eq.{u_1+1} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
hV :
  and
    (@has_mem.mem.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
       (@set.has_mem.{u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
       V
       B)
    (@eq.{u_1+1} (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
       s),
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sUs
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144        { rcases hs with ⟨V, ⟨⟨H₁, H₂⟩, H₃⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s (@set.image.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1) (λ (U : @topological_space.opens.{u_1} α _inst_1), and (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1) (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1)) U B) (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) sUs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (@set_of.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (λ (U : @topological_space.opens.{u_1} α _inst_1),
             and
               (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                  (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                  U
                  B)
               (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
                  (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
                  sUs))))
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₃ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    s,
H₁ :
  @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    V
    B,
H₂ :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sUs
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145          subst H₃, exact H₂ } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='H₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='H₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V) sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
s : set.{u_1} α,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₃ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    s,
H₁ :
  @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    V
    B,
H₂ :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sUs
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) s sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hB : @topological_space.opens.is_basis.{u_1} α _inst_1 B,
U : @topological_space.opens.{u_1} α _inst_1,
sUs : set.{u_1} (set.{u_1} α),
H :
  @has_subset.subset.{u_1} (set.{u_1} (set.{u_1} α)) (@set.has_subset.{u_1} (set.{u_1} α)) sUs
    (@set.image.{u_1 u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       (set.{u_1} α)
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
       B),
hU :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α sUs),
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
    (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    V
    B,
H₂ :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sUs
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ (∀ (U : @topological_space.opens.{u_1} α _inst_1),
     @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
       (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
          @Exists.{0}
            (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               Us
               B)
            (λ
             (H :
               @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 Us
                 B),
               @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                 (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                       (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                    Us)))) →
  @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    { intro h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)
⊢ (∀ (U : @topological_space.opens.{u_1} α _inst_1),
     @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
       (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
          @Exists.{0}
            (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
               Us
               B)
            (λ
             (H :
               @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                 Us
                 B),
               @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                 (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                    (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                       (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                    Us)))) →
  @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us)))
⊢ @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147      rw is_basis_iff_nbhd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='topological_space.opens.is_basis_iff_nbhd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)}, iff (@topological_space.opens.is_basis.{u_1} α _inst_1 B) (∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α}, @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.has_mem.{u_1} α _inst_1) x U → @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1) (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1), @Exists.{0} (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1) (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1)) U&#x27; B) (λ (H : @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1) (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1)) U&#x27; B), and (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.has_mem.{u_1} α _inst_1) x U&#x27;) (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.has_subset.{u_1} α _inst_1) U&#x27; U))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us)))
⊢ @topological_space.opens.is_basis.{u_1} α _inst_1 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us)))
⊢ ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148      intros U x hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us)))
⊢ ∀ {U : @topological_space.opens.{u_1} α _inst_1} {x : α},
    @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
      (@topological_space.opens.has_mem.{u_1} α _inst_1)
      x
      U →
    @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
      (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
         @Exists.{0}
           (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B)
           (λ
            (H :
              @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
                (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                U&#x27;
                B),
              and
                (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_mem.{u_1} α _inst_1)
                   x
                   U&#x27;)
                (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@topological_space.opens.has_subset.{u_1} α _inst_1)
                   U&#x27;
                   U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    U
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149      rcases h U with ⟨Us, hUs, H⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (U : @topological_space.opens.{u_1} α _inst_1), @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)), @Exists.{0} (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)) Us B) (λ (H : @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)) Us B), @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1)) Us)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    U
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    U,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
    (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
       Us)
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150      replace H := congr_arg subtype.val H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} {a₁ a₂ : α} (f : α → β), @eq.{(max (u_1+1) 1)} α a₁ a₂ → @eq.{(max (u_1+1) 1)} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{(max (u_1+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1)) Us)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    U,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
    (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
       Us)
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    U,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
          Us))
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151      rw Sup_s at H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='topological_space.opens.Sup_s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)}, @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1) (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1)) Us)) (@set.sUnion.{u_1} α (@set.image.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    U,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
          (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
             (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
          Us))
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    U,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us))
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152      change x ∈ U.val at hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
hx :
  @has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_mem.{u_1} α _inst_1)
    x
    U,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us))
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153      rw H at hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_1+1) 1)} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) (@set.sUnion.{u_1} α (@set.image.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us))
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154      rcases set.mem_sUnion.mp hx with ⟨sV, ⟨⟨V, H₁, H₂⟩, hsV⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.mem_sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {x : α} {S : set.{u_1} (set.{u_1} α)}, iff (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.sUnion.{u_1} α S)) (@Exists.{u_1+1} (set.{u_1} α) (λ (t : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) t S) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) t S), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.sUnion.{u_1} α (@set.image.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us))
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
sV : set.{u_1} α,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    V
    Us,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sV
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155      refine ⟨V,hUs H₁,_⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hUs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1)) (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)) Us B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) (@set.has_mem.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) V Us'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
sV : set.{u_1} α,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    V
    Us,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sV
⊢ @Exists.{u_1+1} (@topological_space.opens.{u_1} α _inst_1)
    (λ (U&#x27; : @topological_space.opens.{u_1} α _inst_1),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
            (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
            U&#x27;
            B)
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (@topological_space.opens.{u_1} α _inst_1)
              (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_mem.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              U&#x27;
              B),
            and
              (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_mem.{u_1} α _inst_1)
                 x
                 U&#x27;)
              (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                 (@topological_space.opens.has_subset.{u_1} α _inst_1)
                 U&#x27;
                 U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
sV : set.{u_1} α,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    V
    Us,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sV
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       V)
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       V
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156      cases V with V hV,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
sV : set.{u_1} α,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV,
V : @subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s),
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    V
    Us,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V)
    sV
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       V)
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       V
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
sV : set.{u_1} α,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV,
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV))
    sV
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV))
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157      dsimp at H₂, subst H₂,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='H₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (set.{u_1} α) V sV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
sV : set.{u_1} α,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV,
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
H₂ :
  @eq.{u_1+1} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV))
    sV
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV))
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
sV : set.{u_1} α,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x sV,
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
H₂ : @eq.{u_1+1} (set.{u_1} α) V sV
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV))
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV))
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158      refine ⟨hsV,_⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hsV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V
⊢ and
    (@has_mem.mem.{u_1 u_1} α (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_mem.{u_1} α _inst_1)
       x
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV))
    (@has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
       (@topological_space.opens.has_subset.{u_1} α _inst_1)
       (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V
⊢ @has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_subset.{u_1} α _inst_1)
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159      change V ⊆ U.val, rw H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_1+1) 1)} (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U) (@set.sUnion.{u_1} α (@set.image.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} α) (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V
⊢ @has_subset.subset.{u_1} (@topological_space.opens.{u_1} α _inst_1)
    (@topological_space.opens.has_subset.{u_1} α _inst_1)
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    U'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V
⊢ @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) V
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V
⊢ @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) V
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160      exact set.subset_sUnion_of_mem ⟨⟨V, _⟩, ⟨H₁, rfl⟩⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.subset_sUnion_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {S : set.{u_1} (set.{u_1} α)} {t : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) t S → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) t (@set.sUnion.{u_1} α S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)) (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) (@set.has_mem.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))) (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV) Us'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
B : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
h :
  ∀ (U : @topological_space.opens.{u_1} α _inst_1),
    @Exists.{u_1+1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
      (λ (Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1)),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
              Us
              B)
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
                Us
                B),
              @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1) U
                (@lattice.Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                   (@lattice.complete_lattice.to_has_Sup.{u_1} (@topological_space.opens.{u_1} α _inst_1)
                      (@topological_space.opens.lattice.complete_lattice.{u_1} α _inst_1))
                   Us))),
U : @topological_space.opens.{u_1} α _inst_1,
x : α,
Us : set.{u_1} (@topological_space.opens.{u_1} α _inst_1),
hUs :
  @has_subset.subset.{u_1} (set.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    (@set.has_subset.{u_1} (@topological_space.opens.{u_1} α _inst_1))
    Us
    B,
H :
  @eq.{(max (u_1+1) 1)} (set.{u_1} α)
    (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U)
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
hx :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us)),
V : set.{u_1} α,
hV : @is_open.{u_1} α _inst_1 V,
H₁ :
  @has_mem.mem.{u_1 u_1}
    (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
    (set.{u_1} (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@set.has_mem.{u_1}
       (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)))
    (@subtype.mk.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) V hV)
    Us,
hsV : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x V
⊢ @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) V
    (@set.sUnion.{u_1} α
       (@set.image.{u_1 u_1}
          (@subtype.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          (set.{u_1} α)
          (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s))
          Us))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  end opens</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  end topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  namespace continuous</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  open topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  def comap {f : α → β} (hf : continuous f) (V : opens β) : opens α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  ⟨f ⁻¹&#x27; V.1, hf V.1 V.2⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_2} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {p : α → Prop}, @subtype.{(max (u_2+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@continuous.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {p : α → Prop}, @subtype.{(max (u_2+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_space.opens.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {p : α → Prop} (c : @subtype.{(max (u_2+1) 1)} α p), p (@subtype.val.{(max (u_2+1) 1)} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  @[simp] lemma comap_id (U : opens α) : (continuous_id).comap U = U := by { ext, refl }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='continuous_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 654, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 170, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α], @continuous.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_1} β] {f : α → β}, @continuous.{u_1 u_1} α β _inst_1 _inst_2 f → @topological_space.opens.{u_1} β _inst_2 → @topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                        </code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U : @topological_space.opens.{u_1} α _inst_1
⊢ @eq.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} α _inst_1)
    (@continuous.comap.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α) (@continuous_id.{u_1} α _inst_1) U)
    U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : topological_space.{u_1} α,
U : @topological_space.opens.{u_1} α _inst_1,
x : α
⊢ iff
    (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s)
          (@continuous.comap.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α) (@continuous_id.{u_1} α _inst_1) U)))
    (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
       (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  lemma comap_mono {f : α → β} (hf : continuous f) {V W : opens β} (hVW : V ⊆ W) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='topological_space.opens'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='W'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@topological_space.opens.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_subset.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The type of open subsets of a topological space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    hf.comap V ⊆ hf.comap W :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='W'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 170, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 170, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] {f : α → β}, @continuous.{u_1 u_2} α β _inst_1 _inst_2 f → @topological_space.opens.{u_2} β _inst_2 → @topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] {f : α → β}, @continuous.{u_1 u_2} α β _inst_1 _inst_2 f → @topological_space.opens.{u_2} β _inst_2 → @topological_space.opens.{u_1} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.opens.{u_2} β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  λ _ h, hVW h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hVW'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) _x (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) (@continuous.comap.{u_1 u_2} α β _inst_1 _inst_2 f hf V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_2} (@topological_space.opens.{u_2} β _inst_2) (@topological_space.opens.has_subset.{u_2} β _inst_2) V W'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) _x (@subtype.val.{(max (u_1+1) 1)} (set.{u_1} α) (λ (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s) (@continuous.comap.{u_1 u_2} α β _inst_1 _inst_2 f hf V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  end continuous</code></pre>
</body>