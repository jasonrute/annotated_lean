<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Johan Commelin. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johan Commelin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import group_theory.subgroup</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import algebra.ring</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  open group</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  variables {R : Type u} [ring R]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ring.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  section prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  set_option default_priority 100 -- see Note [default priority]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='default priority for attributes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  /-- `S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  class is_subring (S : set R) extends is_add_subgroup S, is_submonoid S : Prop.</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_add_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_submonoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {β : Type u} [_inst_2 : add_group.{u} β], set.{u} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : monoid.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`s` is an additive subgroup: a set containing 0 and closed under addition and negation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`s` is a submonoid: a set containing 1 and closed under multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  end prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  instance subset.ring {S : set R} [is_subring S] : ring S :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  by subtype_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/subtype_instance.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' builds instances for algebraic substructures

Example:
```lean
variables {α : Type*} [monoid α] {s : set α}

class is_submonoid (s : set α) : Prop :=
(one_mem : (1:α) ∈ s)
(mul_mem {a b} : a ∈ s → b ∈ s → a * b ∈ s)

instance subtype.monoid {s : set α} [is_submonoid s] : monoid s :=
by subtype_instance
````'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='subtype_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/subtype_instance.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' builds instances for algebraic substructures

Example:
```lean
variables {α : Type*} [monoid α] {s : set α}

class is_submonoid (s : set α) : Prop :=
(one_mem : (1:α) ∈ s)
(mul_mem {a b} : a ∈ s → b ∈ s → a * b ∈ s)

instance subtype.monoid {s : set α} [is_submonoid s] : monoid s :=
by subtype_instance
````'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='subtype_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  instance subtype.ring {S : set R} [is_subring S] : ring (subtype S) := subset.ring</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  namespace is_ring_hom</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  instance {S : set R} [is_subring S] : is_ring_hom (@subtype.val R S) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  by refine {..} ; intros ; refl</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  instance is_subring_preimage {R : Type u} {S : Type v} [ring R] [ring S]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    (f : R → S) [is_ring_hom f] (s : set S) [is_subring s] : is_subring (f ⁻¹&#x27; s) := {}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  instance is_subring_image {R : Type u} {S : Type v} [ring R] [ring S]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    (f : R → S) [is_ring_hom f] (s : set R) [is_subring s] : is_subring (f &#x27;&#x27; s) := {}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  instance is_subring_set_range {R : Type u} {S : Type v} [ring R] [ring S]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    (f : R → S) [is_ring_hom f] : is_subring (set.range f) := {}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R → S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  end is_ring_hom</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  instance subtype_val.is_ring_hom {s : set R} [is_subring s] :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    is_ring_hom (subtype.val : s → R) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  { ..subtype_val.is_add_group_hom, ..subtype_val.is_monoid_hom }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='blue'><a title='subtype_val.is_monoid_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] {s : set.{u_1} α} [_inst_3 : @is_submonoid.{u_1} α _inst_1 s], @is_monoid_hom.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)) α (@subtype.monoid.{u_1} α _inst_1 s _inst_3) _inst_1 (@subtype.val.{u_1+1} α (λ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='orange'><a title='The natural injection from a submonoid into the monoid is a monoid hom.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  instance coe.is_ring_hom {s : set R} [is_subring s] : is_ring_hom (coe : s → R) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  subtype_val.is_ring_hom</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype_val.is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s : set.{u} R} [_inst_2 : @is_subring.{u} R _inst_1 s], @is_ring_hom.{u u} (@subtype.{u+1} R (λ (x : R), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)) R (@subset.ring.{u} R _inst_1 s _inst_2) _inst_1 (@subtype.val.{u+1} R (λ (x : R), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  instance subtype_mk.is_ring_hom {γ : Type*} [ring γ] {s : set R} [is_subring s] (f : γ → R)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                  </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    [is_ring_hom f] (h : ∀ x, f x ∈ s) : is_ring_hom (λ x, (⟨f x, h x⟩ : s)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {β : Type u} [_inst_1 : ring.{u_1} α] [_inst_2 : ring.{u} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='γ → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='γ → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (x : γ), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (f x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  { ..subtype_mk.is_add_group_hom f h, ..subtype_mk.is_monoid_hom f h }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='subtype_mk.is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='subtype_mk.is_monoid_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 264, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : add_group.{u_1} α] [_inst_2 : add_group.{u_2} β] {s : set.{u_1} α} [_inst_3 : @is_add_subgroup.{u_1} α _inst_1 s] (f : β → α) [_inst_4 : @is_add_group_hom.{u_2 u_1} β α _inst_2 _inst_1 f] (h : ∀ (x : β), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (f x) s), @is_add_group_hom.{u_2 u_1} β (@subtype.{u_1+1} α (λ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)) _inst_2 (@subtype.add_group.{u_1} α _inst_1 s _inst_3) (λ (x : β), @subtype.mk.{u_1+1} α (λ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s) (f x) (h x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : γ), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (f x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] {s : set.{u_1} α} {γ : Type u_2} [_inst_3 : monoid.{u_2} γ] [_inst_4 : @is_submonoid.{u_1} α _inst_1 s] (f : γ → α) [_inst_5 : @is_monoid_hom.{u_2 u_1} γ α _inst_3 _inst_1 f] (h : ∀ (x : γ), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (f x) s), @is_monoid_hom.{u_2 u_1} γ (@subtype.{u_1+1} α (λ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)) _inst_3 (@subtype.monoid.{u_1} α _inst_1 s _inst_4) (λ (x : γ), @subtype.mk.{u_1+1} α (λ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s) (f x) (h x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : γ), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (f x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='Given a monoid hom `f : γ → α` whose image is contained in a submonoid `s`, the induced map
   from `γ` to `s` is a monoid hom.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  instance set_inclusion.is_ring_hom {s t : set R} [is_subring s] [is_subring t] (h : s ⊆ t) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    is_ring_hom (set.inclusion h) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inclusion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1594, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {s t : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s t → @coe_sort.{(max (u_1+1) 1) (max 1 (u_1+1))+1} (set.{u_1} α) (@set.has_coe_to_sort.{u_1} α) s → @coe_sort.{(max (u_1+1) 1) (max 1 (u_1+1))+1} (set.{u_1} α) (@set.has_coe_to_sort.{u_1} α) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`inclusion` is the &quot;identity&quot; function between two subsets `s` and `t`, where `s ⊆ t`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  subtype_mk.is_ring_hom _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype_mk.is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 50, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {γ : Type u_1} [_inst_2 : ring.{u_1} γ] {s : set.{u} R} [_inst_3 : @is_subring.{u} R _inst_1 s] (f : γ → R) [_inst_4 : @is_ring_hom.{u_1 u} γ R _inst_2 _inst_1 f] (h : ∀ (x : γ), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (f x) s), @is_ring_hom.{u_1 u} γ (@subtype.{u+1} R (λ (x : R), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)) _inst_2 (@subset.ring.{u} R _inst_1 s _inst_3) (λ (x : γ), @subtype.mk.{u+1} R (λ (x : R), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (f x) (h x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  variables {cR : Type u} [comm_ring cR]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  instance subset.comm_ring {S : set cR} [is_subring S] : comm_ring S :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} cR'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} cR'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  by subtype_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/subtype_instance.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' builds instances for algebraic substructures

Example:
```lean
variables {α : Type*} [monoid α] {s : set α}

class is_submonoid (s : set α) : Prop :=
(one_mem : (1:α) ∈ s)
(mul_mem {a b} : a ∈ s → b ∈ s → a * b ∈ s)

instance subtype.monoid {s : set α} [is_submonoid s] : monoid s :=
by subtype_instance
````'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='subtype_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='cR : Type u,
_inst_2 : comm_ring.{u} cR,
S : set.{u} cR,
_inst_3 : @is_subring.{u} cR (@comm_ring.to_ring.{u} cR _inst_2) S
⊢ comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} cR) (@set.has_coe_to_sort.{u} cR) S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/subtype_instance.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' builds instances for algebraic substructures

Example:
```lean
variables {α : Type*} [monoid α] {s : set α}

class is_submonoid (s : set α) : Prop :=
(one_mem : (1:α) ∈ s)
(mul_mem {a b} : a ∈ s → b ∈ s → a * b ∈ s)

instance subtype.monoid {s : set α} [is_submonoid s] : monoid s :=
by subtype_instance
````'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='subtype_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cR : Type u,
_inst_2 : comm_ring.{u} cR,
S : set.{u} cR,
_inst_3 : @is_subring.{u} cR (@comm_ring.to_ring.{u} cR _inst_2) S
⊢ comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} cR) (@set.has_coe_to_sort.{u} cR) S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  instance subtype.comm_ring {S : set cR} [is_subring S] : comm_ring (subtype S) := subset.comm_ring</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cR'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='subset.comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} cR'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, (α → Prop) → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} cR'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {cR : Type u} [_inst_2 : comm_ring.{u} cR] {S : set.{u} cR} [_inst_3 : @is_subring.{u} cR (@comm_ring.to_ring.{u} cR _inst_2) S], comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} cR) (@set.has_coe_to_sort.{u} cR) S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  instance subring.domain {D : Type*} [integral_domain D] (S : set D) [is_subring S] : integral_domain S :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='integral_domain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='integral_domain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 278, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 278, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u_1} [_inst_1 : ring.{u_1} R], set.{u_1} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                     </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  by subtype_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/subtype_instance.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' builds instances for algebraic substructures

Example:
```lean
variables {α : Type*} [monoid α] {s : set α}

class is_submonoid (s : set α) : Prop :=
(one_mem : (1:α) ∈ s)
(mul_mem {a b} : a ∈ s → b ∈ s → a * b ∈ s)

instance subtype.monoid {s : set α} [is_submonoid s] : monoid s :=
by subtype_instance
````'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='subtype_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='D : Type ?l_1,
_inst_3 : integral_domain.{?l_1} D,
S : set.{?l_1} D,
_inst_4 : @is_subring.{?l_1} D (@domain.to_ring.{?l_1} D (@integral_domain.to_domain.{?l_1} D _inst_3)) S
⊢ integral_domain.{?l_1}
    (@coe_sort.{(max (?l_1+1) 1) (max 1 (?l_1+1))+1} (set.{?l_1} D) (@set.has_coe_to_sort.{?l_1} D) S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/subtype_instance.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' builds instances for algebraic substructures

Example:
```lean
variables {α : Type*} [monoid α] {s : set α}

class is_submonoid (s : set α) : Prop :=
(one_mem : (1:α) ∈ s)
(mul_mem {a b} : a ∈ s → b ∈ s → a * b ∈ s)

instance subtype.monoid {s : set α} [is_submonoid s] : monoid s :=
by subtype_instance
````'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='subtype_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='D : Type ?l_1,
_inst_3 : integral_domain.{?l_1} D,
S : set.{?l_1} D,
_inst_4 : @is_subring.{?l_1} D (@domain.to_ring.{?l_1} D (@integral_domain.to_domain.{?l_1} D _inst_3)) S
⊢ integral_domain.{?l_1}
    (@coe_sort.{(max (?l_1+1) 1) (max 1 (?l_1+1))+1} (set.{?l_1} D) (@set.has_coe_to_sort.{?l_1} D) S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  instance is_subring.inter (S₁ S₂ : set R) [is_subring S₁] [is_subring S₂] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    is_subring (S₁ ∩ S₂) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='S₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  { }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  instance is_subring.Inter {ι : Sort*} (S : ι → set R) [h : ∀ y : ι, is_subring (S y)] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Sort u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Sort u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    is_subring (set.Inter S) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {ι : Sort x}, (ι → set.{v} β) → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed intersection of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  { }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  lemma is_subring_Union_of_directed {ι : Type*} [hι : nonempty ι]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    (s : ι → set R) [∀ i, is_subring (s i)]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    (directed : ∀ i j, ∃ k, s i ⊆ s k ∧ s j ⊆ s k) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    is_subring (⋃i, s i) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type u} {ι : Type u_1}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β : Type u} {ι : Type u_1}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  { to_is_add_subgroup := is_add_subgroup_Union_of_directed s directed,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='is_add_subgroup_Union_of_directed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='directed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 571, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] {ι : Type u_1} [hι : nonempty.{u_1+1} ι] (s : ι → set.{u} α) [_inst_3 : ∀ (i : ι), @is_add_subgroup.{u} α _inst_1 (s i)], (∀ (i j : ι), @Exists.{u_1+1} ι (λ (k : ι), and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s i) (s k)) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s k)))) → @is_add_subgroup.{u} α _inst_1 (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i j : ι), @Exists.{u_1+1} ι (λ (k : ι), and (@has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) (s i) (s k)) (@has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) (s j) (s k)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='A family of elements of α is directed (with respect to a relation `≼` on α)
 if there is a member of the family `≼`-above any pair in the family.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    to_is_submonoid := is_submonoid_Union_of_directed s directed }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='is_submonoid_Union_of_directed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='directed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 571, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {ι : Type u_1} [hι : nonempty.{u_1+1} ι] (s : ι → set.{u} α) [_inst_3 : ∀ (i : ι), @is_submonoid.{u} α _inst_1 (s i)], (∀ (i j : ι), @Exists.{u_1+1} ι (λ (k : ι), and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s i) (s k)) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s k)))) → @is_submonoid.{u} α _inst_1 (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i j : ι), @Exists.{u_1+1} ι (λ (k : ι), and (@has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) (s i) (s k)) (@has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) (s j) (s k)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The union of an indexed, directed, nonempty set of submonoids of a monoid `α` is a submonoid
   of `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A family of elements of α is directed (with respect to a relation `≼` on α)
 if there is a member of the family `≼`-above any pair in the family.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  namespace ring</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  def closure (s : set R) := add_group.closure (monoid.closure s)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_group.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='monoid.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 302, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : add_group.{u_1} α], set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : monoid.{u_1} α], set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='The inductively defined submonoid generated by a subset of a monoid.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  variable {s : set R}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  local attribute [reducible] closure</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='reducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  theorem exists_list_of_mem_closure {a : R} (h : a ∈ closure s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    (∃ L : list (list R), (∀ l ∈ L, ∀ x ∈ l, x ∈ s ∨ x = (-1:R)) ∧ (L.map list.prod).sum = a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u} (list.{u} R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='list.{u} (list.{u} R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, (α → β) → list.{u} α → list.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : has_mul.{u} α] [_inst_2 : has_one.{u} α], list.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : has_add.{u} α] [_inst_2 : has_zero.{u} α], list.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                        </code><font color='orange'><a title='Product of a list.

    prod [a, b, c] = ((1 * a) * b) * c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Sum of a list.

    sum [a, b, c] = ((0 + a) + b) + c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  add_group.in_closure.rec_on h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='add_group.in_closure.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] {s : set.{u} α} {C : α → Prop} {a : α}, @add_group.in_closure.{u} α _inst_1 s a → (∀ {a : α}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → C a) → C (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1))) → (∀ {a : α}, @add_group.in_closure.{u} α _inst_1 s a → C a → C (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) a)) → (∀ {a b : α}, @add_group.in_closure.{u} α _inst_1 s a → @add_group.in_closure.{u} α _inst_1 s b → C a → C b → C (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1))) a b)) → C a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    (λ x hx, match x, monoid.exists_list_of_mem_closure hx with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='monoid.exists_list_of_mem_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 349, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {s : set.{u} α} {a : α}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@monoid.closure.{u} α _inst_1 s) → @Exists.{u+1} (list.{u} α) (λ (l : list.{u} α), and (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) (@eq.{u+1} α (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) l) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Given an element `a` of the submonoid of a monoid `α` generated by a set `s`, there exists a list of
   elements of `s` whose product is `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95      | _, ⟨L, h1, rfl⟩ := ⟨[L], list.forall_mem_singleton.2 (λ r hr, or.inl (h1 r hr)), zero_add _⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.forall_mem_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ring.zero_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {T : Type u}, T → list.{u} T → list.{u} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u}, T → list.{u} T → list.{u} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a : α}, iff (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.cons.{u} α a (@list.nil.{u} α)) → p x) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) r L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) r L'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [c : ring.{u} α] (a : α), @eq.{u+1} α (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_semigroup.mk.{u} α (@ring.add.{u} α c) (@ring.add_assoc.{u} α c))) (@has_zero.zero.{u} α (@has_zero.mk.{u} α (@ring.zero.{u} α c))) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96      end)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97    ⟨[], list.forall_mem_nil _, rfl⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.forall_mem_nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 208, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {T : Type u}, list.{u} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (p : α → Prop) (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.nil.{u} α) → p x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    (λ b _ ih, match b, ih with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)) (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{u+1} (list.{u} (list.{u} R)) (λ (L : list.{u} (list.{u} R)), and (∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (@eq.{u+1} R (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) L)) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u+1} (list.{u} (list.{u} R)) (λ (L : list.{u} (list.{u} R)), and (∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (@eq.{u+1} R (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) L)) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99      | _, ⟨L1, h1, rfl⟩ := ⟨L1.map (list.cons (-1)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='L1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='list.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='list.{u} (list.{u} R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α β : Type u}, (α → β) → list.{u} α → list.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {T : Type u}, T → list.{u} T → list.{u} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100        λ L2 h2, match L2, list.mem_map.1 h2 with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='L2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='L2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.mem_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) L2 (@list.map.{u u} (list.{u} R) (list.{u} R) (@list.cons.{u} R (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))) L1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} {f : α → β} {b : β} {l : list.{u} α}, iff (@has_mem.mem.{u u} β (list.{u} β) (@list.has_mem.{u} β) b (@list.map.{u u} α β f l)) (@Exists.{u+1} α (λ (a : α), and (@has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) a l) (@eq.{u+1} β (f a) b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) L2 (@list.map.{u u} (list.{u} R) (list.{u} R) (@list.cons.{u} R (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))) L1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101          | _, ⟨L3, h3, rfl⟩ := list.forall_mem_cons.2 ⟨or.inr rfl, h1 L3 h3⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='L3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.forall_mem_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) L3 L1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a : α} {l : list.{u} α}, iff (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.cons.{u} α a l) → p x) (and (p a) (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l → p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102          end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103        by simp only [list.map_map, (∘), list.prod_cons, neg_one_mul];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='list.map_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (g : β → γ) (f : α → β) (l : list.{?l_1} α), @eq.{?l_3+1} (list.{?l_3} γ) (@list.map.{?l_2 ?l_3} β γ g (@list.map.{?l_1 ?l_2} α β f l)) (@list.map.{?l_1 ?l_3} α γ (@function.comp.{?l_1+1 ?l_2+1 ?l_3+1} α β γ g f) l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : monoid.{?l_1} α] {l : list.{?l_1} α} {a : α}, @eq.{?l_1+1} α (@list.prod.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) (@monoid.to_has_one.{?l_1} α _inst_1) (@list.cons.{?l_1} α a l)) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) a (@list.prod.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) (@monoid.to_has_one.{?l_1} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : ring.{?l_1} α] (a : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@mul_zero_class.to_has_mul.{?l_1} α (@semiring.to_mul_zero_class.{?l_1} α (@ring.to_semiring.{?l_1} α _inst_1))) (@has_neg.neg.{?l_1} α (@add_group.to_has_neg.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α (@ring.to_add_comm_group.{?l_1} α _inst_1))) (@has_one.one.{?l_1} α (@monoid.to_has_one.{?l_1} α (@ring.to_monoid.{?l_1} α _inst_1)))) a) (@has_neg.neg.{?l_1} α (@add_group.to_has_neg.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α (@ring.to_add_comm_group.{?l_1} α _inst_1))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The additive inverse of one multiplied by an element of a ring is the element&#x27;s additive
   inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) (list.{u} R)
             (@list.cons.{u} R
                (@has_neg.neg.{u} R
                   (@add_group.to_has_neg.{u} R
                      (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                   (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
             L1)))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104        exact list.rec_on L1 neg_zero.symm (λ hd tl ih,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='list.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='neg_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {T : Type u} {C : list.{u} T → Prop} (n : list.{u} T), C (@list.nil.{u} T) → (∀ (hd : T) (tl : list.{u} T), C tl → C (@list.cons.{u} T hd tl)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} (list.{u} R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α], @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))) (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) (list.{u} R)
             (@list.cons.{u} R
                (@has_neg.neg.{u} R
                   (@add_group.to_has_neg.{u} R
                      (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                   (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
             L1)))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105          by rw [list.map_cons, list.sum_cons, ih, list.map_cons, list.sum_cons, neg_add])⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='list.map_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.sum_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.map_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.sum_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (a : α) (l : list.{u} α), @eq.{u+1} (list.{u} β) (@list.map.{u u} α β f (@list.cons.{u} α a l)) (@list.cons.{u} β (f a) (@list.map.{u u} α β f l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.sum.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@add_monoid.to_has_zero.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) a (@list.sum.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@add_monoid.to_has_zero.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} R (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (λ (x : list.{u} R), @has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) x)) tl)) (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (a : α) (l : list.{u} α), @eq.{u+1} (list.{u} β) (@list.map.{u u} α β f (@list.cons.{u} α a l)) (@list.cons.{u} β (f a) (@list.map.{u u} α β f l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.sum.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@add_monoid.to_has_zero.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) a (@list.sum.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@add_monoid.to_has_zero.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_comm_group.{u} α] (a b : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)))) a b)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)) a) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α _inst_1)) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) (list.{u} R)
             (@list.cons.{u} R
                (@has_neg.neg.{u} R
                   (@add_group.to_has_neg.{u} R
                      (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                   (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
             L1)))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (λ (x : list.{u} R),
             @has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  x))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             tl)))
⊢ @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (λ (x : list.{u} R),
             @has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  x))
          (@list.cons.{u} (list.{u} R) hd tl)))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@list.cons.{u} (list.{u} R) hd tl))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (λ (x : list.{u} R),
             @has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  x))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             tl)))
⊢ @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.cons.{u} R
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                hd))
          (@list.map.{u u} (list.{u} R) R
             (λ (x : list.{u} R),
                @has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     x))
             tl)))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@list.cons.{u} (list.{u} R) hd tl))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (λ (x : list.{u} R),
             @has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  x))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             tl)))
⊢ @eq.{u+1} R
    (@has_add.add.{u} R
       (@add_semigroup.to_has_add.{u} R
          (@add_monoid.to_add_semigroup.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             hd))
       (@list.sum.{u} R
          (@add_semigroup.to_has_add.{u} R
             (@add_monoid.to_add_semigroup.{u} R
                (@add_group.to_add_monoid.{u} R
                   (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
          (@add_monoid.to_has_zero.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))
          (@list.map.{u u} (list.{u} R) R
             (λ (x : list.{u} R),
                @has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     x))
             tl)))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@list.cons.{u} (list.{u} R) hd tl))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (λ (x : list.{u} R),
             @has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  x))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             tl)))
⊢ @eq.{u+1} R
    (@has_add.add.{u} R
       (@add_semigroup.to_has_add.{u} R
          (@add_monoid.to_add_semigroup.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             hd))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
             (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@list.map.{u u} (list.{u} R) R
                (@list.prod.{u} R
                   (@mul_zero_class.to_has_mul.{u} R
                      (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                   (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                tl))))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@list.cons.{u} (list.{u} R) hd tl))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (λ (x : list.{u} R),
             @has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  x))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             tl)))
⊢ @eq.{u+1} R
    (@has_add.add.{u} R
       (@add_semigroup.to_has_add.{u} R
          (@add_monoid.to_add_semigroup.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             hd))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
             (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@list.map.{u u} (list.{u} R) R
                (@list.prod.{u} R
                   (@mul_zero_class.to_has_mul.{u} R
                      (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                   (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                tl))))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.cons.{u} R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                hd)
             (@list.map.{u u} (list.{u} R) R
                (@list.prod.{u} R
                   (@mul_zero_class.to_has_mul.{u} R
                      (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                   (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                tl))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (λ (x : list.{u} R),
             @has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  x))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             tl)))
⊢ @eq.{u+1} R
    (@has_add.add.{u} R
       (@add_semigroup.to_has_add.{u} R
          (@add_monoid.to_add_semigroup.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             hd))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
             (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@list.map.{u u} (list.{u} R) R
                (@list.prod.{u} R
                   (@mul_zero_class.to_has_mul.{u} R
                      (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                   (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                tl))))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_add.add.{u} R
          (@add_semigroup.to_has_add.{u} R
             (@add_monoid.to_add_semigroup.{u} R
                (@add_group.to_add_monoid.{u} R
                   (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             hd)
          (@list.sum.{u} R
             (@add_semigroup.to_has_add.{u} R
                (@add_monoid.to_add_semigroup.{u} R
                   (@add_group.to_add_monoid.{u} R
                      (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
             (@add_monoid.to_has_zero.{u} R
                (@add_group.to_add_monoid.{u} R
                   (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))
             (@list.map.{u u} (list.{u} R) R
                (@list.prod.{u} R
                   (@mul_zero_class.to_has_mul.{u} R
                      (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                   (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                tl))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
b : R,
_x :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    b,
ih :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            b)),
_match :
  ∀ (_a : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 _a))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) (list.{u} R)
             (@list.cons.{u} R
                (@has_neg.neg.{u} R
                   (@add_group.to_has_neg.{u} R
                      (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                   (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
             L1)))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106      end)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    (λ r1 r2 hr1 hr2 ih1 ih2, match r1, r2, ih1, ih2 with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='r1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='r1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='r2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)) (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s) r1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)) (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s) r2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{u+1} (list.{u} (list.{u} R)) (λ (L : list.{u} (list.{u} R)), and (∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (@eq.{u+1} R (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) L)) r1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{u+1} (list.{u} (list.{u} R)) (λ (L : list.{u} (list.{u} R)), and (∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (@eq.{u+1} R (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) L)) r2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u+1} (list.{u} (list.{u} R)) (λ (L : list.{u} (list.{u} R)), and (∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (@eq.{u+1} R (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) L)) r1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u+1} (list.{u} (list.{u} R)) (λ (L : list.{u} (list.{u} R)), and (∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (@eq.{u+1} R (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) L)) r2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108      | _, _, ⟨L1, h1, rfl⟩, ⟨L2, h2, rfl⟩ := ⟨L1 ++ L2, list.forall_mem_append.2 ⟨h1, h2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='L1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='L2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_append.append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.forall_mem_append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='list.{u} (list.{u} R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='list.{u} (list.{u} R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L2 → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [c : has_append.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {l₁ l₂ : list.{u} α}, iff (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@has_append.append.{u} (list.{u} α) (@list.has_append.{u} α) l₁ l₂) → p x) (and (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l₁ → p x) (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l₂ → p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109        by rw [list.map_append, list.sum_append]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='list.map_append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.sum_append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1504, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (l₁ l₂ : list.{u} α), @eq.{u+1} (list.{u} β) (@list.map.{u u} α β f (@has_append.append.{u} (list.{u} α) (@list.has_append.{u} α) l₁ l₂)) (@has_append.append.{u} (list.{u} β) (@list.has_append.{u} β) (@list.map.{u u} α β f l₁) (@list.map.{u u} α β f l₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] {l₁ l₂ : list.{u} α}, @eq.{u+1} α (@list.sum.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@add_monoid.to_has_zero.{u} α _inst_1) (@has_append.append.{u} (list.{u} α) (@list.has_append.{u} α) l₁ l₂)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@list.sum.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@add_monoid.to_has_zero.{u} α _inst_1) l₁) (@list.sum.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@add_monoid.to_has_zero.{u} α _inst_1) l₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
r1 r2 : R,
hr1 :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    r1,
hr2 :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    r2,
ih1 :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            r1)),
ih2 :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            r2)),
_match :
  ∀ (_a _a_1 : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a_1)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_add.add.{u} R
                 (@add_semigroup.to_has_add.{u} R
                    (@add_monoid.to_add_semigroup.{u} R
                       (@add_group.to_add_monoid.{u} R
                          (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
                 _a
                 _a_1))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L2 : list.{u} (list.{u} R),
h2 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L2 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@has_append.append.{u} (list.{u} (list.{u} R)) (@list.has_append.{u} (list.{u} R)) L1 L2)))
    (@has_add.add.{u} R
       (@add_semigroup.to_has_add.{u} R
          (@add_monoid.to_add_semigroup.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L1))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
a : R,
h : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s),
r1 r2 : R,
hr1 :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    r1,
hr2 :
  @add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))
    (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)
    r2,
ih1 :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            r1)),
ih2 :
  @Exists.{u+1} (list.{u} (list.{u} R))
    (λ (L : list.{u} (list.{u} R)),
       and
         (∀ (l : list.{u} R),
            @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
            ∀ (x : R),
              @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
              or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                (@eq.{u+1} R x
                   (@has_neg.neg.{u} R
                      (@add_group.to_has_neg.{u} R
                         (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                      (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
         (@eq.{u+1} R
            (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
               (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
               (@list.map.{u u} (list.{u} R) R
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                  L))
            r2)),
_match :
  ∀ (_a _a_1 : R),
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              _a_1)) →
    @Exists.{u+1} (list.{u} (list.{u} R))
      (λ (L : list.{u} (list.{u} R)),
         and
           (∀ (l : list.{u} R),
              @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
              ∀ (x : R),
                @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
                or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
                  (@eq.{u+1} R x
                     (@has_neg.neg.{u} R
                        (@add_group.to_has_neg.{u} R
                           (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                        (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
           (@eq.{u+1} R
              (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
                 (@mul_zero_class.to_has_zero.{u} R
                    (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                 (@list.map.{u u} (list.{u} R) R
                    (@list.prod.{u} R
                       (@mul_zero_class.to_has_mul.{u} R
                          (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
                    L))
              (@has_add.add.{u} R
                 (@add_semigroup.to_has_add.{u} R
                    (@add_monoid.to_add_semigroup.{u} R
                       (@add_group.to_add_monoid.{u} R
                          (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
                 _a
                 _a_1))),
L1 : list.{u} (list.{u} R),
h1 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L1 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L2 : list.{u} (list.{u} R),
h2 :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L2 →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @eq.{u+1} R
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@has_append.append.{u} (list.{u} R) (@list.has_append.{u} R)
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L1)
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L2)))
    (@has_add.add.{u} R
       (@add_semigroup.to_has_add.{u} R
          (@add_monoid.to_add_semigroup.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L1))
       (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
          (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             L2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110      end)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  @[elab_as_eliminator]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='instructs elaborator that the arguments of the function application (f ...) should be elaborated as f were an eliminator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  protected theorem in_closure.rec_on {C : R → Prop} {x : R} (hx : x ∈ closure s)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    (h1 : C 1) (hneg1 : C (-1)) (hs : ∀ z ∈ s, ∀ n, C n → C (z * n))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    (ha : ∀ {x y}, C x → C y → C (x + y)) : C x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R}, C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y)
⊢ C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    have h0 : C 0 := add_neg_self (1:R) ▸ ha h1 hneg1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='add_neg_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hneg1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] (a : α), @eq.{u+1} α (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1))) a (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) a)) (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {x y : R}, C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R}, C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y)
⊢ C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))))
⊢ C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118    rcases exists_list_of_mem_closure hx with ⟨L, HL, rfl⟩, clear hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ring.exists_list_of_mem_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s : set.{u} R} {a : R}, @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s) → @Exists.{u+1} (list.{u} (list.{u} R)) (λ (L : list.{u} (list.{u} R)), and (∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (@eq.{u+1} R (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) L)) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))))
⊢ C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
L : list.{u} (list.{u} R),
HL :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
hx :
  @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R)
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          L))
    (@ring.closure.{u} R _inst_1 s)
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
L : list.{u} (list.{u} R),
HL :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    induction L with hd tl ih, { exact h0 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='h0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} (list.{u} R)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C (@has_zero.zero.{u} R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
L : list.{u} (list.{u} R),
HL :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l L →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case list.nil
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
HL :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l
      (@list.nil.{u} (list.{u} R)) →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.nil.{u} (list.{u} R))))

case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l
      (@list.cons.{u} (list.{u} R) hd tl) →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.cons.{u} (list.{u} R) hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.nil
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
HL :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l
      (@list.nil.{u} (list.{u} R)) →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.nil.{u} (list.{u} R))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l
      (@list.cons.{u} (list.{u} R) hd tl) →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.cons.{u} (list.{u} R) hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    rw list.forall_mem_cons at HL,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.forall_mem_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a : α} {l : list.{u} α}, iff (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.cons.{u} α a l) → p x) (and (p a) (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l → p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  ∀ (l : list.{u} R),
    @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l
      (@list.cons.{u} (list.{u} R) hd tl) →
    ∀ (x : R),
      @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
      or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
        (@eq.{u+1} R x
           (@has_neg.neg.{u} R
              (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
              (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.cons.{u} (list.{u} R) hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.cons.{u} (list.{u} R) hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    suffices : C (list.prod hd),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : has_mul.{u} α] [_inst_2 : has_one.{u} α], list.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Product of a list.

    prod [a, b, c] = ((1 * a) * b) * c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.cons.{u} (list.{u} R) hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
this :
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.cons.{u} (list.{u} R) hd tl)))

R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    { rw [list.map_cons, list.sum_cons],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='list.map_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.sum_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (a : α) (l : list.{u} α), @eq.{u+1} (list.{u} β) (@list.map.{u u} α β f (@list.cons.{u} α a l)) (@list.cons.{u} β (f a) (@list.map.{u u} α β f l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.sum.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@add_monoid.to_has_zero.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) a (@list.sum.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) (@add_monoid.to_has_zero.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
this :
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.cons.{u} (list.{u} R) hd tl)))

R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
this :
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@list.cons.{u} (list.{u} R) hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
this :
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
⊢ C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.cons.{u} R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             hd)
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
this :
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
⊢ C
    (@has_add.add.{u} R
       (@add_semigroup.to_has_add.{u} R
          (@add_monoid.to_add_semigroup.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          hd)
       (@list.sum.{u} R
          (@add_semigroup.to_has_add.{u} R
             (@add_monoid.to_add_semigroup.{u} R
                (@add_group.to_add_monoid.{u} R
                   (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
          (@add_monoid.to_has_zero.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123      exact ha this (ih HL.2) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='HL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {x y : R}, C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(∀ (l : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl → ∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) → C (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@list.map.{u u} (list.{u} R) R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (∀ (x : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl → ∀ (x_1 : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s) (@eq.{u+1} R x_1 (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
this :
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
⊢ C
    (@has_add.add.{u} R
       (@add_semigroup.to_has_add.{u} R
          (@add_monoid.to_add_semigroup.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          hd)
       (@list.sum.{u} R
          (@add_semigroup.to_has_add.{u} R
             (@add_monoid.to_add_semigroup.{u} R
                (@add_group.to_add_monoid.{u} R
                   (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))))
          (@add_monoid.to_has_zero.{u} R
             (@add_group.to_add_monoid.{u} R
                (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))))
          (@list.map.{u u} (list.{u} R) R
             (@list.prod.{u} R
                (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
             tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    replace HL := HL.1, clear ih tl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='HL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (∀ (x : list.{u} R), @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl → ∀ (x_1 : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s) (@eq.{u+1} R x_1 (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  and
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : list.{u} R),
       @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) x tl →
       ∀ (x_1 : R),
         @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x_1 x →
         or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x_1 s)
           (@eq.{u+1} R x_1
              (@has_neg.neg.{u} R
                 (@add_group.to_has_neg.{u} R
                    (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                 (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
tl : list.{u} (list.{u} R),
ih :
  (∀ (l : list.{u} R),
     @has_mem.mem.{u u} (list.{u} R) (list.{u} (list.{u} R)) (@list.has_mem.{u} (list.{u} R)) l tl →
     ∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x l →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  C
    (@list.sum.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1))
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@list.map.{u u} (list.{u} R) R
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))
          tl)),
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    suffices : ∃ L : list R, (∀ x ∈ L, x ∈ s) ∧ (list.prod hd = list.prod L ∨ list.prod hd = -list.prod L),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : has_mul.{u} α] [_inst_2 : has_one.{u} α], list.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Product of a list.

    prod [a, b, c] = ((1 * a) * b) * c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
this :
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)

R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126    { rcases this with ⟨L, HL&#x27;, HP | HP⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (list.{u} R) (λ (L : list.{u} R), and (∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (or (@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) hd) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L)) (@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) hd) (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
this :
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)

R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
this :
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)

R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127      { rw HP, clear HP HL hd, induction L with hd tl ih, { exact h1 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='HP'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) hd) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)

R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case list.nil
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.nil.{u} R) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.nil.{u} R))

case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.nil
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.nil.{u} R) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.nil.{u} R))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128        rw list.forall_mem_cons at HL&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='list.forall_mem_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a : α} {l : list.{u} α}, iff (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.cons.{u} α a l) → p x) (and (p a) (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l → p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl),
HL&#x27; :
  and (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129        rw list.prod_cons,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl),
HL&#x27; :
  and (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl),
HL&#x27; :
  and (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
⊢ C
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130        exact hs _ HL&#x27;.1 _ (ih HL&#x27;.2) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='HL&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (z : R), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s → Π (n : R), C n → C (@has_mul.mul.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) z n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) → C (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) tl)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s) (∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl),
HL&#x27; :
  and (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
⊢ C
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131      rw HP, clear HP HL hd, induction L with hd tl ih, { exact hneg1 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='HP'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='hneg1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) hd) (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))
⊢ C
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       hd)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))
⊢ C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case list.nil
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.nil.{u} R) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          (@list.nil.{u} R)))

case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl)),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          (@list.cons.{u} R hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.nil
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.nil.{u} R) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          (@list.nil.{u} R)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl)),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          (@list.cons.{u} R hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132      rw [list.prod_cons, neg_mul_eq_mul_neg],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_mul_eq_mul_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : ring.{u} α] (a b : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a b)) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl)),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          (@list.cons.{u} R hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl)),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
          (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl)),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_mul.mul.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       hd
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl)),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_mul.mul.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       hd
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133      rw list.forall_mem_cons at HL&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list.forall_mem_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a : α} {l : list.{u} α}, iff (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.cons.{u} α a l) → p x) (and (p a) (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l → p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl)),
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s
⊢ C
    (@has_mul.mul.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       hd
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl)),
HL&#x27; :
  and (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
⊢ C
    (@has_mul.mul.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       hd
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134      exact hs _ HL&#x27;.1 _ (ih HL&#x27;.2) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='HL&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (z : R), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s → Π (n : R), C n → C (@has_mul.mul.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) z n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) → C (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s) (∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) →
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl)),
HL&#x27; :
  and (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
⊢ C
    (@has_mul.mul.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       hd
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    induction hd with hd tl ih,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : list.{u} R,
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x hd →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  hd)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case list.nil
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.nil.{u} R) →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.nil.{u} R))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.nil.{u} R))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    { exact ⟨[], list.forall_mem_nil _, or.inl rfl⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='list.forall_mem_nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 208, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (p : α → Prop) (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.nil.{u} α) → p x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case list.nil
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.nil.{u} R) →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.nil.{u} R))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.nil.{u} R))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.nil
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.nil.{u} R) →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.nil.{u} R))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.nil.{u} R))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    rw list.forall_mem_cons at HL,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.forall_mem_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a : α} {l : list.{u} α}, iff (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.cons.{u} α a l) → p x) (and (p a) (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l → p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x (@list.cons.{u} R hd tl) →
    or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
      (@eq.{u+1} R x
         (@has_neg.neg.{u} R
            (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
            (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    rcases ih HL.2 with ⟨L, HL&#x27;, HP | HP⟩; cases HL.1 with hhd hhd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='HL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='HL'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) → @Exists.{u+1} (list.{u} R) (λ (L : list.{u} R), and (∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (or (@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) tl) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L)) (@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) tl) (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s) (@eq.{u+1} R hd (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s) (@eq.{u+1} R hd (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) (∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl → or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s) (@eq.{u+1} R x (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    { exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL&#x27;⟩, or.inl $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.forall_mem_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hhd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='HL&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a : α} {l : list.{u} α}, iff (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.cons.{u} α a l) → p x) (and (p a) (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l → p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140        by rw [list.prod_cons, list.prod_cons, HP]⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='HP'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) tl) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd tl))
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    { exact ⟨L, HL&#x27;, or.inr $ by rw [list.prod_cons, hhd, neg_one_mul, HP]⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='HL&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hhd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='HP'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} R hd (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ring.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) (@has_one.one.{u} α (@monoid.to_has_one.{u} α (@ring.to_monoid.{u} α _inst_1)))) a) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) tl) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The additive inverse of one multiplied by an element of a ring is the element&#x27;s additive
   inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @eq.{u+1} R
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    { exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL&#x27;⟩, or.inr $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.forall_mem_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hhd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='HL&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a : α} {l : list.{u} α}, iff (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x (@list.cons.{u} α a l) → p x) (and (p a) (∀ (x : α), @has_mem.mem.{u u} α (list.{u} α) (@list.has_mem.{u} α) x l → p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))

case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143        by rw [list.prod_cons, list.prod_cons, HP, neg_mul_eq_mul_neg]⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='HP'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_mul_eq_mul_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) tl) (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : ring.{u} α] (a b : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a b)) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          (@list.cons.{u} R hd L)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          (@list.cons.{u} R hd L)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
          (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             L)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             L)))
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
          (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             L)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    { exact ⟨L, HL&#x27;, or.inl $ by rw [list.prod_cons, hhd, HP, neg_one_mul, neg_neg]⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='HL&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hhd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='HP'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : R), @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {l : list.{u} α} {a : α}, @eq.{u+1} α (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) (@list.cons.{u} α a l)) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a (@list.prod.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) (@monoid.to_has_one.{u} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} R hd (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} R (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) tl) (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@list.prod.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)) L))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ring.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) (@has_one.one.{u} α (@monoid.to_has_one.{u} α (@ring.to_monoid.{u} α _inst_1)))) a) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] (a : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) a)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The additive inverse of one multiplied by an element of a ring is the element&#x27;s additive
   inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       (@list.cons.{u} R hd tl))
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) hd
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
       (@list.prod.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          tl))
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @eq.{u+1} R
    (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1)))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             L)))
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @eq.{u+1} R
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@list.prod.{u} R
             (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
             (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
             L)))
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
R : Type u,
_inst_1 : ring.{u} R,
s : set.{u} R,
C : R → Prop,
h1 : C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))),
hneg1 :
  C
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))),
hs :
  ∀ (z : R),
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s →
    ∀ (n : R),
      C n →
      C
        (@has_mul.mul.{u} R
           (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
           z
           n),
ha :
  ∀ {x y : R},
    C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y),
h0 :
  C
    (@has_zero.zero.{u} R
       (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))),
hd : R,
tl : list.{u} R,
ih :
  (∀ (x : R),
     @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
     or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
       (@eq.{u+1} R x
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))) →
  @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  tl)
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L))))),
HL :
  and
    (or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) hd s)
       (@eq.{u+1} R hd
          (@has_neg.neg.{u} R
             (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
             (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))))
    (∀ (x : R),
       @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x tl →
       or (@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (@eq.{u+1} R x
            (@has_neg.neg.{u} R
               (@add_group.to_has_neg.{u} R
                  (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
               (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))),
L : list.{u} R,
HL&#x27; :
  ∀ (x : R),
    @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
    @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s,
HP :
  @eq.{u+1} R
    (@list.prod.{u} R
       (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
       (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
       tl)
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@list.prod.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
          L)),
hhd :
  @eq.{u+1} R hd
    (@has_neg.neg.{u} R
       (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
       (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
⊢ @Exists.{u+1} (list.{u} R)
    (λ (L : list.{u} R),
       and
         (∀ (x : R),
            @has_mem.mem.{u u} R (list.{u} R) (@list.has_mem.{u} R) x L →
            @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x s)
         (or
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  L))
            (@eq.{u+1} R
               (@list.prod.{u} R
                  (@mul_zero_class.to_has_mul.{u} R
                     (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                  (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                  (@list.cons.{u} R hd tl))
               (@has_neg.neg.{u} R
                  (@add_group.to_has_neg.{u} R
                     (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
                  (@list.prod.{u} R
                     (@mul_zero_class.to_has_mul.{u} R
                        (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
                     (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))
                     L)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  instance : is_subring (closure s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  { one_mem := add_group.mem_closure (is_submonoid.one_mem _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='add_group.mem_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_submonoid.one_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 449, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_group.{u_1} α] {s : set.{u_1} α} {a : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@add_group.closure.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (s : set.{u_1} α) [c : @is_submonoid.{u_1} α _inst_1 s], @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    mul_mem := λ a b ha hb, add_group.in_closure.rec_on hb</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_group.in_closure.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) b (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_group.{u_1} α] {s : set.{u_1} α} {C : α → Prop} {a : α}, @add_group.in_closure.{u_1} α _inst_1 s a → (∀ {a : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → C a) → C (@has_zero.zero.{u_1} α (@add_monoid.to_has_zero.{u_1} α (@add_group.to_add_monoid.{u_1} α _inst_1))) → (∀ {a : α}, @add_group.in_closure.{u_1} α _inst_1 s a → C a → C (@has_neg.neg.{u_1} α (@add_group.to_has_neg.{u_1} α _inst_1) a)) → (∀ {a b : α}, @add_group.in_closure.{u_1} α _inst_1 s a → @add_group.in_closure.{u_1} α _inst_1 s b → C a → C b → C (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α (@add_group.to_add_monoid.{u_1} α _inst_1))) a b)) → C a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) b (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150      (λ b hb, add_group.in_closure.rec_on ha</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_group.in_closure.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) b (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_group.{u_1} α] {s : set.{u_1} α} {C : α → Prop} {a : α}, @add_group.in_closure.{u_1} α _inst_1 s a → (∀ {a : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → C a) → C (@has_zero.zero.{u_1} α (@add_monoid.to_has_zero.{u_1} α (@add_group.to_add_monoid.{u_1} α _inst_1))) → (∀ {a : α}, @add_group.in_closure.{u_1} α _inst_1 s a → C a → C (@has_neg.neg.{u_1} α (@add_group.to_has_neg.{u_1} α _inst_1) a)) → (∀ {a b : α}, @add_group.in_closure.{u_1} α _inst_1 s a → @add_group.in_closure.{u_1} α _inst_1 s b → C a → C b → C (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α (@add_group.to_add_monoid.{u_1} α _inst_1))) a b)) → C a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151        (λ a ha, add_group.subset_closure (is_submonoid.mul_mem ha hb))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_group.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_submonoid.mul_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 456, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_group.{u_1} α] {s : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s (@add_group.closure.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] {s : set.{u_1} α} [c : @is_submonoid.{u_1} α _inst_1 s] {a b : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) b (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152        ((zero_mul b).symm ▸ is_add_submonoid.zero_mem _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ring.zero_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_add_submonoid.zero_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 171, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ring.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α (@ring.to_distrib.{u} α _inst_1)) (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))))) a) (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{u+1} α a b → @eq.{u+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u_2} [_inst_2 : add_monoid.{u_2} β] (s : set.{u_2} β) [c : @is_add_submonoid.{u_2} β _inst_2 s], @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (@has_zero.zero.{u_2} β (@add_monoid.to_has_zero.{u_2} β _inst_2)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153        (λ a ha hab, (neg_mul_eq_neg_mul a b) ▸ is_add_subgroup.neg_mem hab)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='neg_mul_eq_neg_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_add_subgroup.neg_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)) (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [s : ring.{u} α] (a b : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a b)) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) a) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u_2} [_inst_2 : add_group.{u_2} β] {s : set.{u_2} β} [c : @is_add_subgroup.{u_2} β _inst_2 s] {a : β}, @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) a s → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (@has_neg.neg.{u_2} β (@add_group.to_has_neg.{u_2} β _inst_2) a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154        (λ a c ha hc hab hcb, (add_mul a c b).symm ▸ is_add_submonoid.add_mem hab hcb))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hcb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_add_submonoid.add_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hcb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)) (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)) (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s) c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) c b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : distrib.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α _inst_1) a b) c) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) a c) (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{u+1} α a b → @eq.{u+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u_2} [_inst_2 : add_monoid.{u_2} β] {s : set.{u_2} β} [c : @is_add_submonoid.{u_2} β _inst_2 s] {a b : β}, @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) a s → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b s → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (@has_add.add.{u_2} β (@add_semigroup.to_has_add.{u_2} β (@add_monoid.to_add_semigroup.{u_2} β _inst_2)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) c b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155      ((mul_zero a).symm ▸ is_add_submonoid.zero_mem _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ring.mul_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_add_submonoid.zero_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 165, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ring.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α (@ring.to_distrib.{u} α _inst_1)) a (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1)))))) (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{u+1} α a b → @eq.{u+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u_2} [_inst_2 : add_monoid.{u_2} β] (s : set.{u_2} β) [c : @is_add_submonoid.{u_2} β _inst_2 s], @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (@has_zero.zero.{u_2} β (@add_monoid.to_has_zero.{u_2} β _inst_2)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156      (λ b hb hab, (neg_mul_eq_mul_neg a b) ▸ is_add_subgroup.neg_mem hab)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='neg_mul_eq_mul_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_add_subgroup.neg_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)) (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [s : ring.{u} α] (a b : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a b)) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u_2} [_inst_2 : add_group.{u_2} β] {s : set.{u_2} β} [c : @is_add_subgroup.{u_2} β _inst_2 s] {a : β}, @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) a s → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (@has_neg.neg.{u_2} β (@add_group.to_has_neg.{u_2} β _inst_2) a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157      (λ b c hb hc hab hac, (mul_add a b c).symm ▸ is_add_submonoid.add_mem hab hac),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mul_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_add_submonoid.add_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hac'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)) (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@add_group.in_closure.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)) (@monoid.closure.{u} R (@ring.to_monoid.{u} R _inst_1) s) c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a c) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : distrib.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) a (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α _inst_1) b c)) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) a b) (@has_mul.mul.{u_1} α (@distrib.to_has_mul.{u_1} α _inst_1) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{u+1} α a b → @eq.{u+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u_2} [_inst_2 : add_monoid.{u_2} β] {s : set.{u_2} β} [c : @is_add_submonoid.{u_2} β _inst_2 s] {a b : β}, @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) a s → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b s → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (@has_add.add.{u_2} β (@add_semigroup.to_has_add.{u_2} β (@add_monoid.to_add_semigroup.{u_2} β _inst_2)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a b) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) (@has_mul.mul.{u} R (@semigroup.to_has_mul.{u} R (@monoid.to_semigroup.{u} R (@ring.to_monoid.{u} R _inst_1))) a c) (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158    .. add_group.closure.is_add_subgroup _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_group.closure.is_add_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 452, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_group.{u_1} α] (s : set.{u_1} α), @is_add_subgroup.{u_1} α _inst_1 (@add_group.closure.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  theorem mem_closure {a : R} : a ∈ s → a ∈ closure s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  add_group.mem_closure ∘ @monoid.subset_closure _ _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='add_group.mem_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='monoid.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 449, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 310, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] {s : set.{u} α} {a : α}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@add_group.closure.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β φ : Prop}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {s : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@monoid.closure.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A subset of a monoid is contained in the submonoid it generates.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  theorem subset_closure : s ⊆ closure s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  λ _, mem_closure</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ring.mem_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 160, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s : set.{u} R} {a : R}, @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a s → @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) a (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  theorem closure_subset {t : set R} [is_subring t] : s ⊆ t → closure s ⊆ t :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  add_group.closure_subset ∘ monoid.closure_subset</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='add_group.closure_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='monoid.closure_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 459, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] {s t : set.{u} α} [_inst_2 : @is_add_subgroup.{u} α _inst_1 t], @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@add_group.closure.{u} α _inst_1 s) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β φ : Prop}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {s t : set.{u} α} [_inst_3 : @is_submonoid.{u} α _inst_1 t], @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@monoid.closure.{u} α _inst_1 s) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The submonoid generated by a set is contained in any submonoid that contains the set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  theorem closure_subset_iff (s t : set R) [is_subring t] : closure s ⊆ t ↔ s ⊆ t :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='`S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  (add_group.closure_subset_iff _ t).trans</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='add_group.closure_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 463, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] (s t : set.{u} α) [_inst_2 : @is_add_subgroup.{u} α _inst_1 t], iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@add_group.closure.{u} α _inst_1 s) t) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b c : Prop}, iff a b → iff b c → iff a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    ⟨set.subset.trans monoid.subset_closure, monoid.closure_subset⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='monoid.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='monoid.closure_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 310, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {a b c : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b c → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {s : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@monoid.closure.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {s t : set.{u} α} [_inst_3 : @is_submonoid.{u} α _inst_1 t], @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@monoid.closure.{u} α _inst_1 s) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A subset of a monoid is contained in the submonoid it generates.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The submonoid generated by a set is contained in any submonoid that contains the set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  theorem closure_mono {s t : set R} (H : s ⊆ t) : closure s ⊆ closure t :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  closure_subset $ set.subset.trans H subset_closure</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring.closure_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 166, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s t : set.{u} R} [_inst_3 : @is_subring.{u} R _inst_1 t], @has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) s t → @has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) (@ring.closure.{u} R _inst_1 s) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {a b c : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b c → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s : set.{u} R}, @has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) s (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  lemma image_closure {S : Type*} [ring S] (f : R → S) [is_ring_hom f] (s : set R) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type u_1} [_inst_1 : ring.{u} α] [_inst_2 : ring.{u_1} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='R → S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    f &#x27;&#x27; closure s = closure (f &#x27;&#x27; s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='R → S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type u_1}, (α → β) → set.{u} α → set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='R → S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type u_1}, (α → β) → set.{u} α → set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  le_antisymm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : partial_order.{u_1} α] {a b : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1)) a b → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1)) b a → @eq.{u_1+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R
⊢ @has_le.le.{u_1} (set.{u_1} S)
    (@preorder.to_has_le.{u_1} (set.{u_1} S)
       (@partial_order.to_preorder.{u_1} (set.{u_1} S)
          (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} S)
             (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} S)
                (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} S) (@set.lattice_set.{u_1} S))))))
    (@set.image.{u u_1} R S f (@ring.closure.{u} R _inst_1 s))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180      rintros _ ⟨x, hx, rfl⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R
⊢ @has_le.le.{u_1} (set.{u_1} S)
    (@preorder.to_has_le.{u_1} (set.{u_1} S)
       (@partial_order.to_preorder.{u_1} (set.{u_1} S)
          (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} S)
             (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} S)
                (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} S) (@set.lattice_set.{u_1} S))))))
    (@set.image.{u u_1} R S f (@ring.closure.{u} R _inst_1 s))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181      apply in_closure.rec_on hx; intros,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ring.in_closure.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s : set.{u} R} {C : R → Prop} {x : R}, @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s) → C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) → C (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))) → (∀ (z : R), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s → ∀ (n : R), C n → C (@has_mul.mul.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) z n)) → (∀ {x y : R}, C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y)) → C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
z : R,
H : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s,
n : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f n)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_mul.mul.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          z
          n))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x_1 y))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182      { rw [is_monoid_hom.map_one f], apply is_submonoid.one_mem },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_monoid_hom.map_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_submonoid.one_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} [_inst_1 : monoid.{u} α] [_inst_2 : monoid.{u_1} β] (f : α → β) [c : @is_monoid_hom.{u u_1} α β _inst_1 _inst_2 f], @eq.{u_1+1} β (f (@has_one.one.{u} α (@monoid.to_has_one.{u} α _inst_1))) (@has_one.one.{u_1} β (@monoid.to_has_one.{u_1} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='R → S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (s : set.{u_1} α) [c : @is_submonoid.{u_1} α _inst_1 s], @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
z : R,
H : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s,
n : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f n)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_mul.mul.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          z
          n))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x_1 y))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (@has_one.one.{u_1} S (@monoid.to_has_one.{u_1} S (@ring.to_monoid.{u_1} S _inst_3)))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
z : R,
H : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s,
n : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f n)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_mul.mul.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          z
          n))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x_1 y))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183      { rw [is_ring_hom.map_neg f, is_monoid_hom.map_one f],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_ring_hom.map_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_monoid_hom.map_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} [_inst_1 : ring.{u} α] [_inst_2 : ring.{u_1} β] (f : α → β) [_inst_3 : @is_ring_hom.{u u_1} α β _inst_1 _inst_2 f] {x : α}, @eq.{u_1+1} β (f (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) x)) (@has_neg.neg.{u_1} β (@add_group.to_has_neg.{u_1} β (@add_comm_group.to_add_group.{u_1} β (@ring.to_add_comm_group.{u_1} β _inst_2))) (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='R → S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} [_inst_1 : monoid.{u} α] [_inst_2 : monoid.{u_1} β] (f : α → β) [c : @is_monoid_hom.{u u_1} α β _inst_1 _inst_2 f], @eq.{u_1+1} β (f (@has_one.one.{u} α (@monoid.to_has_one.{u} α _inst_1))) (@has_one.one.{u_1} β (@monoid.to_has_one.{u_1} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='R → S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Ring homomorphisms preserve additive inverses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
z : R,
H : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s,
n : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f n)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_mul.mul.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          z
          n))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x_1 y))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_neg.neg.{u} R
          (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1)))
          (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (@has_neg.neg.{u_1} S
       (@add_group.to_has_neg.{u_1} S (@add_comm_group.to_add_group.{u_1} S (@ring.to_add_comm_group.{u_1} S _inst_3)))
       (f (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (@has_neg.neg.{u_1} S
       (@add_group.to_has_neg.{u_1} S (@add_comm_group.to_add_group.{u_1} S (@ring.to_add_comm_group.{u_1} S _inst_3)))
       (@has_one.one.{u_1} S (@monoid.to_has_one.{u_1} S (@ring.to_monoid.{u_1} S _inst_3))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184        apply is_add_subgroup.neg_mem, apply is_submonoid.one_mem },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='is_add_subgroup.neg_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_submonoid.one_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u_1} [_inst_2 : add_group.{u_1} β] {s : set.{u_1} β} [c : @is_add_subgroup.{u_1} β _inst_2 s] {a : β}, @has_mem.mem.{u_1 u_1} β (set.{u_1} β) (@set.has_mem.{u_1} β) a s → @has_mem.mem.{u_1 u_1} β (set.{u_1} β) (@set.has_mem.{u_1} β) (@has_neg.neg.{u_1} β (@add_group.to_has_neg.{u_1} β _inst_2) a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (s : set.{u_1} α) [c : @is_submonoid.{u_1} α _inst_1 s], @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (@has_neg.neg.{u_1} S
       (@add_group.to_has_neg.{u_1} S (@add_comm_group.to_add_group.{u_1} S (@ring.to_add_comm_group.{u_1} S _inst_3)))
       (@has_one.one.{u_1} S (@monoid.to_has_one.{u_1} S (@ring.to_monoid.{u_1} S _inst_3))))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s)
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (@has_one.one.{u_1} S (@monoid.to_has_one.{u_1} S (@ring.to_monoid.{u_1} S _inst_3)))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
z : R,
H : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s,
n : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f n)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_mul.mul.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          z
          n))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x_1 y))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185      { rw [is_monoid_hom.map_mul f],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_monoid_hom.map_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} [_inst_1 : monoid.{u} α] [_inst_2 : monoid.{u_1} β] (f : α → β) [_inst_3 : @is_monoid_hom.{u u_1} α β _inst_1 _inst_2 f] (x y : α), @eq.{u_1+1} β (f (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) x y)) (@has_mul.mul.{u_1} β (@semigroup.to_has_mul.{u_1} β (@monoid.to_semigroup.{u_1} β _inst_2)) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='R → S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A monoid homomorphism preserves multiplication.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
z : R,
H : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s,
n : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f n)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_mul.mul.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          z
          n))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x_1 y))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
z : R,
H : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s,
n : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f n)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f
       (@has_mul.mul.{u} R
          (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))
          z
          n))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
z : R,
H : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s,
n : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f n)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (@has_mul.mul.{u_1} S
       (@semigroup.to_has_mul.{u_1} S (@monoid.to_semigroup.{u_1} S (@ring.to_monoid.{u_1} S _inst_3)))
       (f z)
       (f n))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186        apply is_submonoid.mul_mem; solve_by_elim [subset_closure, set.mem_image_of_mem] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='is_submonoid.mul_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='ring.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_image_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/solve_by_elim.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/solve_by_elim.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 899, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/solve_by_elim.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] {s : set.{u_1} α} [c : @is_submonoid.{u_1} α _inst_1 s] {a b : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.by_elim_opt {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u_1} [_inst_1 : ring.{u_1} R] {s : set.{u_1} R}, @has_subset.subset.{u_1} (set.{u_1} R) (@set.has_subset.{u_1} R) s (@ring.closure.{u_1} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.by_elim_opt {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} (f : α → β) {x : α} {a : set.{u} α}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x a → @has_mem.mem.{u_1 u_1} β (set.{u_1} β) (@set.has_mem.{u_1} β) (f x) (@set.image.{u u_1} α β f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.by_elim_opt {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches
and then repeatedly calls `apply` on the generated subgoals until no subgoals remain,
performing at most `max_rep` recursive steps.

`solve_by_elim` discharges the current goal or fails.

`solve_by_elim` performs back-tracking if `apply_assumption` chooses an unproductive assumption.

By default, the assumptions passed to apply_assumption are the local context, `rfl`, `trivial`, `congr_fun` and
`congr_arg`.

`solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the named lemmas.

`solve_by_elim with attr₁ ... attrᵣ also applied all lemmas tagged with the specified attributes.

`solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context, `rfl`, `trivial`, `congr_fun`, or `congr_arg`
unless they are explicitly included.

`solve_by_elim [-id]` removes a specified assumption.

`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.

optional arguments:
- discharger: a subsidiary tactic to try at each step (e.g. `cc` may be helpful)
- max_rep: number of attempts at discharging generated sub-goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches
and then repeatedly calls `apply` on the generated subgoals until no subgoals remain,
performing at most `max_rep` recursive steps.

`solve_by_elim` discharges the current goal or fails.

`solve_by_elim` performs back-tracking if `apply_assumption` chooses an unproductive assumption.

By default, the assumptions passed to apply_assumption are the local context, `rfl`, `trivial`, `congr_fun` and
`congr_arg`.

`solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the named lemmas.

`solve_by_elim with attr₁ ... attrᵣ also applied all lemmas tagged with the specified attributes.

`solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context, `rfl`, `trivial`, `congr_fun`, or `congr_arg`
unless they are explicitly included.

`solve_by_elim [-id]` removes a specified assumption.

`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.

optional arguments:
- discharger: a subsidiary tactic to try at each step (e.g. `cc` may be helpful)
- max_rep: number of attempts at discharging generated sub-goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches
and then repeatedly calls `apply` on the generated subgoals until no subgoals remain,
performing at most `max_rep` recursive steps.

`solve_by_elim` discharges the current goal or fails.

`solve_by_elim` performs back-tracking if `apply_assumption` chooses an unproductive assumption.

By default, the assumptions passed to apply_assumption are the local context, `rfl`, `trivial`, `congr_fun` and
`congr_arg`.

`solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the named lemmas.

`solve_by_elim with attr₁ ... attrᵣ also applied all lemmas tagged with the specified attributes.

`solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context, `rfl`, `trivial`, `congr_fun`, or `congr_arg`
unless they are explicitly included.

`solve_by_elim [-id]` removes a specified assumption.

`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.

optional arguments:
- discharger: a subsidiary tactic to try at each step (e.g. `cc` may be helpful)
- max_rep: number of attempts at discharging generated sub-goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='solve_by_elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='solve_by_elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='solve_by_elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;*?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.by_elim_opt?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;*?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.by_elim_opt?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;*?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.by_elim_opt?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
z : R,
H : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s,
n : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f n)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (@has_mul.mul.{u_1} S
       (@semigroup.to_has_mul.{u_1} S (@monoid.to_semigroup.{u_1} S (@ring.to_monoid.{u_1} S _inst_3)))
       (f z)
       (f n))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x_1 y))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187      { rw [is_ring_hom.map_add f], apply is_add_submonoid.add_mem, assumption&#x27; },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_ring_hom.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_add_submonoid.add_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 231, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} [_inst_1 : ring.{u} α] [_inst_2 : ring.{u_1} β] (f : α → β) [c : @is_ring_hom.{u u_1} α β _inst_1 _inst_2 f] {x y : α}, @eq.{u_1+1} β (f (@has_add.add.{u} α (@distrib.to_has_add.{u} α (@ring.to_distrib.{u} α _inst_1)) x y)) (@has_add.add.{u_1} β (@distrib.to_has_add.{u_1} β (@ring.to_distrib.{u_1} β _inst_2)) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='R → S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u_1} [_inst_2 : add_monoid.{u_1} β] {s : set.{u_1} β} [c : @is_add_submonoid.{u_1} β _inst_2 s] {a b : β}, @has_mem.mem.{u_1 u_1} β (set.{u_1} β) (@set.has_mem.{u_1} β) a s → @has_mem.mem.{u_1 u_1} β (set.{u_1} β) (@set.has_mem.{u_1} β) b s → @has_mem.mem.{u_1 u_1} β (set.{u_1} β) (@set.has_mem.{u_1} β) (@has_add.add.{u_1} β (@add_semigroup.to_has_add.{u_1} β (@add_monoid.to_add_semigroup.{u_1} β _inst_2)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='Try to apply `assumption` to all goals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='assumption&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (f (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x_1 y))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S)
    (@has_add.add.{u_1} S (@distrib.to_has_add.{u_1} S (@ring.to_distrib.{u_1} S _inst_3)) (f x_1) (f y))
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))

R : Type u,
_inst_1 : ring.{u} R,
S : Type u_1,
_inst_3 : ring.{u_1} S,
f : R → S,
_inst_4 : @is_ring_hom.{u u_1} R S _inst_1 _inst_3 f,
s : set.{u} R,
x : R,
hx : @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s),
x_1 y : R,
a :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f x_1)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s)),
a_1 :
  @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))
⊢ @has_mem.mem.{u_1 u_1} S (set.{u_1} S) (@set.has_mem.{u_1} S) (f y)
    (@ring.closure.{u_1} S _inst_3 (@set.image.{u u_1} R S f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189    (closure_subset $ set.image_subset _ subset_closure)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ring.closure_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.image_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ring.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 166, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 958, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {R : Type u_1} [_inst_1 : ring.{u_1} R] {s t : set.{u_1} R} [_inst_3 : @is_subring.{u_1} R _inst_1 t], @has_subset.subset.{u_1} (set.{u_1} R) (@set.has_subset.{u_1} R) s t → @has_subset.subset.{u_1} (set.{u_1} R) (@set.has_subset.{u_1} R) (@ring.closure.{u_1} R _inst_1 s) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} {a b : set.{u} α} (f : α → β), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u_1} (set.{u_1} β) (@set.has_subset.{u_1} β) (@set.image.{u u_1} α β f a) (@set.image.{u u_1} α β f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s : set.{u} R}, @has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) s (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  end ring</code></pre>
</body>