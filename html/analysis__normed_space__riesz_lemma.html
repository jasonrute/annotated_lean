<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Jean Lo. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Jean Lo</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import analysis.normed_space.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import topology.metric_space.hausdorff_distance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  # Riesz&#x27;s lemma</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  Riesz&#x27;s lemma, stated for a normed space over a normed field: for any</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  closed proper subspace F of E, there is a nonzero x such that ∥x - F∥</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  is at least r * ∥x∥ for any r &lt; 1.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  variables {𝕜 : Type*} [normed_field 𝕜]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  variables {E : Type*} [normed_group E] [normed_space 𝕜 E]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  /-- Riesz&#x27;s lemma, which usually states that it is possible to find a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  vector with norm 1 whose distance to a closed proper subspace is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  arbitrarily close to 1. The statement here is in terms of multiples of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  norms, since in general the existence of an element of norm exactly 1</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  is not guaranteed. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  lemma riesz_lemma {F : subspace 𝕜 E} (hFc : is_closed (F : set E))</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27    (hF : ∃ x : E, x ∉ F) {r : ℝ} (hr : r &lt; 1) :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    ∃ x₀ : E, x₀ ∉ F ∧ ∀ y ∈ F, r * ∥x₀∥ ≤ ∥x₀ - y∥ :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    classical,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Make every propositions in the context decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='classical'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    obtain ⟨x, hx⟩ : ∃ x : E, x ∉ F := hF,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    let d := metric.inf_dist x F,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    have hFn : (F : set E).nonempty, from ⟨_, submodule.zero F⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34    have hdp : 0 &lt; d,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35      from lt_of_le_of_ne metric.inf_dist_nonneg (λ heq, hx</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36      ((metric.mem_iff_inf_dist_zero_of_closed hFc hFn).2 heq.symm)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='metric.mem_iff_inf_dist_zero_of_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hFc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hFn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean&#x27;, &#x27;line&#x27;: 483, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : metric_space.{u_2} α] {s : set.{u_2} α} {x : α}, @is_closed.{u_2} α (@uniform_space.to_topological_space.{u_2} α (@metric_space.to_uniform_space&#x27;.{u_2} α _inst_1)) s → @set.nonempty.{u_2} α s → iff (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) x s) (@eq.{1} real (@metric.inf_dist.{u_2} α _inst_1 x s) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_closed.{u_2} E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@coe.{u_2+1 (max (u_2+1) 1)} (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_to_lift.{u_2+1 (max (u_2+1) 1)} (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_base.{u_2+1 (max (u_2+1) 1)} (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@submodule.has_coe.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)))) F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.nonempty.{u_2} E (@coe.{u_2+1 (max (u_2+1) 1)} (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_to_lift.{u_2+1 (max (u_2+1) 1)} (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_base.{u_2+1 (max (u_2+1) 1)} (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@submodule.has_coe.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)))) F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} {a b : α}, @eq.{1} α a b → @eq.{1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F)
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d

𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    let r&#x27; := max r 2⁻¹,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_inv.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    have hr&#x27; : r&#x27; &lt; 1, by { simp [r&#x27;, hr], norm_num },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='r&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='r&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt r (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))

𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    have hlt : 0 &lt; r&#x27; := lt_of_lt_of_le (by norm_num) (le_max_right r 2⁻¹),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='r&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lt_of_lt_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='le_max_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] (a b : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) b (@max.{0} α _inst_1 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40    have hdlt : d &lt; d / r&#x27;, from lt_div_of_mul_lt hlt ((mul_lt_iff_lt_one_right hdp).2 hr&#x27;),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lt_div_of_mul_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mul_lt_iff_lt_one_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hdp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_field.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 135, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_field.{0} α] {a b c : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@ordered_ring.to_ordered_comm_group.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α _inst_1)))))) (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α (@division_ring.to_zero_ne_one_class.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α _inst_1))))) c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@ordered_ring.to_ordered_comm_group.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α _inst_1)))))) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α _inst_1)))))) a c) b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@ordered_ring.to_ordered_comm_group.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α _inst_1)))))) a (@has_div.div.{0} α (@division_ring_has_div.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α _inst_1)) (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α _inst_1))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) r&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_semiring.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) b → iff (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))) b a) b) (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) a (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt r&#x27; (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;
⊢ @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)

𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    obtain ⟨y₀, hy₀F, hxy₀⟩ : ∃ y ∈ F, dist x y &lt; d / r&#x27; :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='r&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [c : has_dist.{u_2} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42      metric.exists_dist_lt_of_inf_dist_lt hdlt hFn,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='metric.exists_dist_lt_of_inf_dist_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hdlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hFn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean&#x27;, &#x27;line&#x27;: 433, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : metric_space.{u_2} α] {s : set.{u_2} α} {x : α} {r : real}, @has_lt.lt.{0} real real.has_lt (@metric.inf_dist.{u_2} α _inst_1 x s) r → @set.nonempty.{u_2} α s → @Exists.{u_2+1} α (λ (y : α), @Exists.{0} (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) y s) (λ (H : @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) y s), @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u_2} α (@metric_space.to_has_dist.{u_2} α _inst_1) x y) r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.nonempty.{u_2} E (@coe.{u_2+1 (max (u_2+1) 1)} (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_to_lift.{u_2+1 (max (u_2+1) 1)} (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_base.{u_2+1 (max (u_2+1) 1)} (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@submodule.has_coe.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)))) F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If the minimal distance to a set is `&lt;r`, there exists a point in this set at distance `&lt;r`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43    have x_ne_y₀ : x - y₀ ∉ F,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₀'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [c : has_sub.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)
⊢ not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F)

𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    { by_contradiction h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1498, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the target of the main goal is a proposition `p`, `by_contradiction h` reduces the goal to proving `false` using the additional hypothesis `h : ¬ p`. If `h` is omitted, a name is generated automatically.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)
⊢ not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F)

𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)
⊢ not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
h :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{u_2} E
       (@add_group_has_sub.{u_2} E
          (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
       x
       y₀)
    F
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45      have : (x - y₀) + y₀ ∈ F, from F.add h hy₀F,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y₀'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy₀F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (@submodule.has_mem.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (@has_sub.sub.{u_2} E (@add_group_has_sub.{u_2} E (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2))) x y₀) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀ (λ (y : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y (@coe.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_to_lift.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_base.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@submodule.has_coe.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)))) F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
h :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{u_2} E
       (@add_group_has_sub.{u_2} E
          (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
       x
       y₀)
    F
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
h :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{u_2} E
       (@add_group_has_sub.{u_2} E
          (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
       x
       y₀)
    F
⊢ @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       y₀)
    F

𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
h :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{u_2} E
       (@add_group_has_sub.{u_2} E
          (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
       x
       y₀)
    F,
this :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       y₀)
    F
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
h :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{u_2} E
       (@add_group_has_sub.{u_2} E
          (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
       x
       y₀)
    F,
this :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       y₀)
    F
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46      simp only [neg_add_cancel_right, sub_eq_add_neg] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='neg_add_cancel_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_eq_add_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_group.{?l_1} α] (a b : α), @eq.{?l_1+1} α (@has_add.add.{?l_1} α (@add_semigroup.to_has_add.{?l_1} α (@add_monoid.to_add_semigroup.{?l_1} α (@add_group.to_add_monoid.{?l_1} α _inst_1))) (@has_add.add.{?l_1} α (@add_semigroup.to_has_add.{?l_1} α (@add_monoid.to_add_semigroup.{?l_1} α (@add_group.to_add_monoid.{?l_1} α _inst_1))) a (@has_neg.neg.{?l_1} α (@add_group.to_has_neg.{?l_1} α _inst_1) b)) b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_group.{?l_1} α] (a b : α), @eq.{?l_1+1} α (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α _inst_1) a b) (@has_add.add.{?l_1} α (@add_semigroup.to_has_add.{?l_1} α (@add_monoid.to_add_semigroup.{?l_1} α (@add_group.to_add_monoid.{?l_1} α _inst_1))) a (@has_neg.neg.{?l_1} α (@add_group.to_has_neg.{?l_1} α _inst_1) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
h :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{u_2} E
       (@add_group_has_sub.{u_2} E
          (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
       x
       y₀)
    F,
this :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       y₀)
    F
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
h :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{u_2} E
       (@add_group_has_sub.{u_2} E
          (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
       x
       y₀)
    F,
this :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    x
    F
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47      exact hx this },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u_2 u_2} E (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (@submodule.has_mem.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) x F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (@submodule.has_mem.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) x F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
h :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_sub.sub.{u_2} E
       (@add_group_has_sub.{u_2} E
          (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
       x
       y₀)
    F,
this :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    x
    F
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48    refine ⟨x - y₀, x_ne_y₀, λy hy, le_of_lt _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y₀'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x_ne_y₀'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u_2 u_2} E (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (@submodule.has_mem.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (@has_sub.sub.{u_2} E (@add_group_has_sub.{u_2} E (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2))) x y₀) F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F)
⊢ @Exists.{u_2+1} E
    (λ (x₀ : E),
       and
         (not
            (@has_mem.mem.{u_2 u_2} E
               (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (@submodule.has_mem.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               x₀
               F))
         (∀ (y : E),
            @has_mem.mem.{u_2 u_2} E
              (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              (@submodule.has_mem.{u_1 u_2} 𝕜 E
                 (@domain.to_ring.{u_1} 𝕜
                    (@division_ring.to_domain.{u_1} 𝕜
                       (@field.to_division_ring.{u_1} 𝕜
                          (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                 (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                 (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
              y
              F →
            @has_le.le.{0} real real.has_le
              (@has_mul.mul.{0} real
                 (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 r
                 (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2) x₀))
              (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
                 (@has_sub.sub.{u_2} E
                    (@add_group_has_sub.{u_2} E
                       (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
                    x₀
                    y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    have hy₀y : y₀ + y ∈ F, from F.add hy₀F hy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='y₀'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy₀F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀ (λ (y : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y (@coe.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_to_lift.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@coe_base.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (set.{u_2} E) (@submodule.has_coe.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)))) F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (@submodule.has_mem.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) y F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F
⊢ @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F

𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    calc</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51      r * ∥x - y₀∥ ≤ r&#x27; * ∥x - y₀∥ : mul_le_mul_of_nonneg_right (le_max_left _ _) (norm_nonneg _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='r&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y₀'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mul_le_mul_of_nonneg_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_max_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='norm_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 135, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_semiring.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1)))) c → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1))) a c) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] (a b : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) a (@max.{0} α _inst_1 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : normed_group.{u_2} α] (g : α), @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (@has_norm.norm.{u_2} α (@normed_group.to_has_norm.{u_2} α _inst_1) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52      ... &lt; d : by { rw ←dist_eq_norm, exact (lt_div_iff&#x27; hlt).1 hxy₀ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='dist_eq_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='lt_div_iff&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hxy₀'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 82, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_field.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : normed_group.{u_2} α] (g h : α), @eq.{1} real (@has_dist.dist.{u_2} α (@metric_space.to_has_dist.{u_2} α (@normed_group.to_metric_space.{u_2} α _inst_1)) g h) (@has_norm.norm.{u_2} α (@normed_group.to_has_norm.{u_2} α _inst_1) (@has_sub.sub.{u_2} α (@add_group_has_sub.{u_2} α (@add_comm_group.to_add_group.{u_2} α (@normed_group.to_add_comm_group.{u_2} α _inst_1))) g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_field.{0} α] {a b c : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α _inst_1)))))))) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α _inst_1)))))) c → iff (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α _inst_1)))))))) a (@has_div.div.{0} α (@division_ring_has_div&#x27;.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α _inst_1))) b c)) (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α _inst_1)))))))) (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α _inst_1))))) c a) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) r&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀) (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r&#x27;
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r&#x27;
       (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x
          y₀))
    d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53      ... ≤ dist x (y₀ + y) : metric.inf_dist_le_dist_of_mem hy₀y</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='metric.inf_dist_le_dist_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy₀y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean&#x27;, &#x27;line&#x27;: 417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_2} [c : has_dist.{u_2} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : metric_space.{u_2} α] {s : set.{u_2} α} {x y : α}, @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) y s → @has_le.le.{0} real real.has_le (@metric.inf_dist.{u_2} α _inst_1 x s) (@has_dist.dist.{u_2} α (@metric_space.to_has_dist.{u_2} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (@submodule.has_mem.{u_1 u_2} 𝕜 E (@domain.to_ring.{u_1} 𝕜 (@division_ring.to_domain.{u_1} 𝕜 (@field.to_division_ring.{u_1} 𝕜 (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1))))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3)) (@has_add.add.{u_2} E (@add_semigroup.to_has_add.{u_2} E (@add_monoid.to_add_semigroup.{u_2} E (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2))))) y₀ y) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The minimal distance to a set is bounded by the distance to any point in this set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54      ... = ∥x - y₀ - y∥ : by { rw [sub_sub, dist_eq_norm] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='sub_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dist_eq_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 399, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 82, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : add_comm_group.{u_2} α] (a b c : α), @eq.{u_2+1} α (@has_sub.sub.{u_2} α (@add_group_has_sub.{u_2} α (@add_comm_group.to_add_group.{u_2} α _inst_1)) (@has_sub.sub.{u_2} α (@add_group_has_sub.{u_2} α (@add_comm_group.to_add_group.{u_2} α _inst_1)) a b) c) (@has_sub.sub.{u_2} α (@add_group_has_sub.{u_2} α (@add_comm_group.to_add_group.{u_2} α _inst_1)) a (@has_add.add.{u_2} α (@add_semigroup.to_has_add.{u_2} α (@add_monoid.to_add_semigroup.{u_2} α (@add_group.to_add_monoid.{u_2} α (@add_comm_group.to_add_group.{u_2} α _inst_1)))) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : normed_group.{u_2} α] (g h : α), @eq.{1} real (@has_dist.dist.{u_2} α (@metric_space.to_has_dist.{u_2} α (@normed_group.to_metric_space.{u_2} α _inst_1)) g h) (@has_norm.norm.{u_2} α (@normed_group.to_has_norm.{u_2} α _inst_1) (@has_sub.sub.{u_2} α (@add_group_has_sub.{u_2} α (@add_comm_group.to_add_group.{u_2} α (@normed_group.to_add_comm_group.{u_2} α _inst_1))) g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @eq.{1} real
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
          y₀
          y))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @eq.{1} real
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
          y₀
          y))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
             y₀
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E _inst_1 _inst_2,
F :
  @subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
    (@normed_group.to_add_comm_group.{u_2} E _inst_2)
    (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3),
hFc :
  @is_closed.{u_2} E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
r : real,
hr :
  @has_lt.lt.{0} real real.has_lt r
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
_inst : Π (a : Prop), decidable a,
x : E,
hx :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       x
       F),
d : real :=
  @metric.inf_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2) x
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hFn :
  @set.nonempty.{u_2} E
    (@coe.{u_2+1 (max (u_2+1) 1)}
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (set.{u_2} E)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
             (@normed_group.to_add_comm_group.{u_2} E _inst_2)
             (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
          (set.{u_2} E)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
             (set.{u_2} E)
             (@submodule.has_coe.{u_1 u_2} 𝕜 E
                (@domain.to_ring.{u_1} 𝕜
                   (@division_ring.to_domain.{u_1} 𝕜
                      (@field.to_division_ring.{u_1} 𝕜
                         (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
       F),
hdp :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    d,
r&#x27; : real :=
  @max.{0} real real.decidable_linear_order r
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring)
       (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))),
hr&#x27; :
  @has_lt.lt.{0} real real.has_lt r&#x27;
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
hlt :
  @has_lt.lt.{0} real real.has_lt
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    r&#x27;,
hdlt :
  @has_lt.lt.{0} real real.has_lt d (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
y₀ : E,
hy₀F :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y₀
    (λ (y : E),
       @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
         (@coe.{u_2+1 (max (u_2+1) 1)}
            (@submodule.{u_1 u_2} 𝕜 E
               (@domain.to_ring.{u_1} 𝕜
                  (@division_ring.to_domain.{u_1} 𝕜
                     (@field.to_division_ring.{u_1} 𝕜
                        (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
               (@normed_group.to_add_comm_group.{u_2} E _inst_2)
               (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
            (set.{u_2} E)
            (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} 𝕜 E
                  (@domain.to_ring.{u_1} 𝕜
                     (@division_ring.to_domain.{u_1} 𝕜
                        (@field.to_division_ring.{u_1} 𝕜
                           (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                  (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                  (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
               (set.{u_2} E)
               (@coe_base.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
                  (set.{u_2} E)
                  (@submodule.has_coe.{u_1 u_2} 𝕜 E
                     (@domain.to_ring.{u_1} 𝕜
                        (@division_ring.to_domain.{u_1} 𝕜
                           (@field.to_division_ring.{u_1} 𝕜
                              (@discrete_field.to_field.{u_1} 𝕜
                                 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
                     (@normed_group.to_add_comm_group.{u_2} E _inst_2)
                     (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))))
            F)),
hxy₀ :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x y₀)
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) d r&#x27;),
x_ne_y₀ :
  not
    (@has_mem.mem.{u_2 u_2} E
       (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@submodule.has_mem.{u_1 u_2} 𝕜 E
          (@domain.to_ring.{u_1} 𝕜
             (@division_ring.to_domain.{u_1} 𝕜
                (@field.to_division_ring.{u_1} 𝕜
                   (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
          (@normed_group.to_add_comm_group.{u_2} E _inst_2)
          (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          x
          y₀)
       F),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    y
    F,
hy₀y :
  @has_mem.mem.{u_2 u_2} E
    (@subspace.{u_1 u_2} 𝕜 E (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u_1 u_2} 𝕜 E
       (@domain.to_ring.{u_1} 𝕜
          (@division_ring.to_domain.{u_1} 𝕜
             (@field.to_division_ring.{u_1} 𝕜
                (@discrete_field.to_field.{u_1} 𝕜 (@normed_field.to_discrete_field.{u_1} 𝕜 _inst_1)))))
       (@normed_group.to_add_comm_group.{u_2} E _inst_2)
       (@normed_space.to_module.{u_1 u_2} 𝕜 E _inst_1 _inst_2 _inst_3))
    (@has_add.add.{u_2} E
       (@add_semigroup.to_has_add.{u_2} E
          (@add_monoid.to_add_semigroup.{u_2} E
             (@add_group.to_add_monoid.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
       y₀
       y)
    F
⊢ @eq.{1} real
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)) x
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))))
          y₀
          y))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_2)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_2)))
             x
             y₀)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font></pre>
</body>